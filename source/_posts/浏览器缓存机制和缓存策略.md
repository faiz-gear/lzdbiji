---
title:  浏览器缓存机制和缓存策略
tag: 浏览器缓存机制和缓存策略
keywords: 浏览器缓存机制和缓存策略
categories: 浏览器相关知识
---
# 浏览器缓存机制和缓存策略

## 1.前言

**浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP的缓存标识进行的**

## 2.缓存过程分析

**浏览器和服务器的通信方式为应答模式**。即浏览器发起HTTP--服务端响应HTTP请求。浏览器第一次发起请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否将响应结果缓存，缓存，则将请求结果和缓存标识存入到浏览器缓存当中

## 3.缓存策略

**浏览器缓存策略分为两种：强缓存和协商缓存**。并且缓存策略都是通过设置HTTP header来实现的。

客户端第一次向服务器请求数据，存在缓存时，客户端会将请求结果和缓存标识存入到内存或硬盘当中；当再次获取相同的资源，强缓存和协商缓存的应对方式也有所不同

**强缓存**：客户端再次请求相同的资源时，不会向服务器发送请求，而是根据强缓存标识决定是否直接从内存/硬盘中读取数据

**协商缓存**：客户端再次请求相同的资源时，先向服务器发起请求“询问”在本地缓存的资源文件相比服务器上的文件是否发生修改，如果有更改，则获取最新的文件资源并缓存，如果没有则从内存/硬盘中读取

### 3.1强缓存

**强缓存就是向浏览器缓存查找请求结果，并且根据该结果的缓存规则来决定是否使用该缓存结果的过程*

强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的network选中可以看到该请求返回200的状态码，并且SIze显示from disk cache或from memory cache

强缓存可以通过设置两种HTTP Header实现： Expires 和 Cache-Control。

强缓存的情况主要有以下三种：

1. 不存在该缓存结果和缓存标识，强缓存失效，直接向服务器发起请求（和第一次发起请求一致）
2. 存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存
3. 存在该缓存结果和缓存标识，且该结果没有生效，强缓存生效，直接返回该结果

当浏览器向服务器发送请求的时候，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强缓存的字段分别是Expires和Cache-Control，其中Cache-Control的优先级比Expires高。

#### 3.1.1Expires

缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和last-modified结合使用。

Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，而无需再次请求。

Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效

到了HTTP/1.1，Expires已经被Cache-Control替代。

原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存可能会失效。

#### 3.1.2Cache-Control

在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control：max-age=300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会命中强缓存。

Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：

- public：**所有内容都将被缓存（客户端和代理服务器都可缓存）**。具体来说响应可被任何中间节点缓存，如Browser <-- proxy1 <-- proxy2 <-- Server， 中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给Browser而不再向proxy2要
- private：**所以内容只有客户端可以缓存， Cache-Control的默认取值**。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy会老老实实把Server返回的数据发送给Browser，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据
- no-cache：**客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定**。表示不使用Cache-Control的缓存控制方式做前置验证号，而是使用Etag或者Last-Modified字段来控制缓存。注意：no-cache这个名字有一点误导。设置no-cahce，不代表浏览器不缓存水，而是浏览器在使用缓存数据时，通过协商缓存来判断数据是否和服务器保持一致
- no-store：**所有内容都不会被缓存**，即不使用强制缓存，也不使用协商缓存
- max-age：max-age=xxx 表示**缓存内容将在xxx秒后失效**
- s-maxage： 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒钟，及时更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires。

### 3.2协商缓存

*协商缓存就是强缓存失效后，浏览器写到缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，*主要有以下两种情况

**协商缓存生效，返回304和Not Modified**

**协商缓存失效，返回200和请求结果**

协商缓存可以通过设置两种HTTP Header实现： Last-modified 和 ETag。

#### 3.2.1 Last-Modified 和 If-Modified-Since

Last-Modified:

- 浏览器在第一次访问资源的情况下，浏览器会在返回资源的同事，在response header中添加Last-Modified的header
- header的值是这个资源在服务器上的最后修改时间
- 浏览器接收后，缓存这个文件和header

If-Modified-Since：

- 浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是浏览器添加If-Modified-Since这个header，值就是Last-Modified的值。
- 服务器再次受到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比。如果没有变化，返回304和空的响应体，直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200.

但是Last-Modified也存在一些弊端：

- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

#### 3.2.2 ETag 和 If-None-Match

**直接根据文件内容是否修改来决定缓存策略**。

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。

- 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。
  - 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。
  - 如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。

### 3.3比较

- 在精确度上，Etag要优于Last-Modified。    Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
- 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
- 在优先级上，服务器校验优先考虑Etag

## 4.缓存位置

从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache