{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"04fcc5625b3d24333525a5c2f767700b1576968d","modified":1649742184909},{"_id":"source/404/index.md","hash":"f856d43418c22a2e0acda0dc8dfc338c5f591fb4","modified":1633947728096},{"_id":"source/_posts/.DS_Store","hash":"ba861401097c3e4b4095171fec3d1d2428d8f48b","modified":1648109923111},{"_id":"source/_posts/d3.md","hash":"5b2ce760d36ab67d16c2771e5f2fea102021fae2","modified":1634175521000},{"_id":"source/_posts/echarts.md","hash":"059c379416e2e5e044d66181ec797652efba9043","modified":1634174676537},{"_id":"source/_posts/h5与ue4通讯.md","hash":"c5562e3be23fdbcb155d7c035216e355a9bdfbeb","modified":1634549897537},{"_id":"source/_posts/react.md","hash":"f67e6336fb5ae333db43b5392bd6ffdd82d1611e","modified":1634174567096},{"_id":"source/_posts/svg.md","hash":"076ade0f068720fd93ae5efff7552bb639ac96cc","modified":1634007704120},{"_id":"source/about/index.md","hash":"64e5c8f7a85a56901fc9933819166691c4b9405b","modified":1633947611008},{"_id":"source/_posts/浏览器进程和线程.md","hash":"2eff2c952258da4166657c63b87b298eae3aaa5b","modified":1648046676804},{"_id":"source/_posts/浏览器页面的渲染过程.md","hash":"48b48bf9b5c8933b5e2fe5110b2c790fd6268e78","modified":1645462020322},{"_id":"source/_posts/搭建jenkins.md","hash":"dab80db49c2acd4bbf186a0733d5f556943c422e","modified":1644477686000},{"_id":"source/categories/index.md","hash":"4f7d18516ccfef716cde6a0bbacbfdd026bca636","modified":1633967054888},{"_id":"source/tags/index.md","hash":"2174b6bda01163c45fd2e4451484f9a27a8c9d5c","modified":1633967131503},{"_id":"source/contact/index.md","hash":"a35f736aafe98684cf3656a769dcb58cf08602d9","modified":1633967103582},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1653560635208},{"_id":"themes/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1653560635208},{"_id":"themes/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/package.json","hash":"980a730164d9f145a3271ed64d7122b7cee6d590","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/_config.yml","hash":"d5ed15fd87806915a5d1ca822d2218862f788a95","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/about.ejs","hash":"23e5db06cfdc1cb26503204f074db58647adfbf3","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/index.ejs","hash":"952d3f27cd7a245848fa1c4a1f5c8912500c2ee1","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/layout.ejs","hash":"1452acee33611685b199c50e1bd4ecddbf6424e3","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/links.ejs","hash":"edcbef65037759c3a7b3539f2edcd72b082267e9","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/page.ejs","hash":"a4a6b184bd91d9fe090da28891e74afc3b71c7fd","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/post.ejs","hash":"3a812de943457c0c544832daa1957420883aca96","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/head.ejs","hash":"eb2c46aa2508ea65d6e5c397c4bc20d05761d754","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/header.ejs","hash":"536eedc03faae3b35dc69abd478634d453061a0a","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"3d8912b68fcf51c38f6e1c5dd2bd74657bb3b7fb","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1653560635223},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1653560635223},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1653560635225},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"57358e2164284f33f3bc81d5f602c620aeab942f","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"ef56f0903762a7a2c853417dfa6b0463440295e0","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"129a8b19ab26efd02ff1806ff4012376d2cd3497","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"c80bdc171aa53eb7205dcdc77764cec87a1dafd6","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"359cbcb0e222c23c8a0c5a99034a8a51f667a9ce","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"cb78296da15c7a8a6957cff2129294cc4815513b","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/source/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1653560635225},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"54933c294d9b469a76a5ed36328e778ed740158f","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_variables/base.styl","hash":"2465f604eea63b14cd2b0cc142769d963a0193a0","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"5f4a17a20ddbf18c8ea6c66638b764905e4386b3","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"e6e48d6ba2951ce4abc2876600f85eef64095338","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"e24cd1186aae10bf897eed9cfd5278247b6300eb","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"078e5496a1852952ce4ee49016e86b9f70d31908","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"696e429284bda7ae0fffe62ca84cb01a9243ecf0","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1653560635223},{"_id":"public/img/avatar.png","hash":"9658ed8a36f7617349cb887684892ba9037c0ef4","modified":1653560653884},{"_id":"public/img/fluid.png","hash":"1c6171b4c36a70419f31c5de8c9de1f2fb8bafac","modified":1653560653884},{"_id":"public/search.xml","hash":"292b80da075babf6441b7c70e434fb5b4ffa4bd8","modified":1653560653884},{"_id":"public/local-search.xml","hash":"aa908614c7a1c60081be02793299b18549f996c9","modified":1653560653884},{"_id":"public/404/index.html","hash":"be4bb564ad859199b5c4db511fbf96f97bf86a1f","modified":1653560653884},{"_id":"public/categories/index.html","hash":"a0cae0cca2fc678c3447a769e519c2094845d930","modified":1653560653884},{"_id":"public/contact/index.html","hash":"a0f5ba98ca0d3cf9b1bb3a154eedec3a9678136b","modified":1653560653884},{"_id":"public/about/index.html","hash":"ed01033294ef8e5fd48ebe5a6b747c01d4507c27","modified":1653560653884},{"_id":"public/tags/index.html","hash":"daa9856ce70495beda0108b3476e08095659c160","modified":1653560653884},{"_id":"public/categories/h5与ue4/index.html","hash":"79f4f74c143f559a81ed2fbc85268aba513c04a9","modified":1653560653884},{"_id":"public/categories/前端可视化库/index.html","hash":"3cdb73d421f98c252a3890d11fd4c91eba89c038","modified":1653560653884},{"_id":"public/categories/自动化部署/index.html","hash":"1902b2ed5a70039cc9e84396763774b5d02a8f0f","modified":1653560653884},{"_id":"public/categories/浏览器相关知识/index.html","hash":"1d3415f4208cd27574945920b1854b178478ac65","modified":1653560653884},{"_id":"public/categories/前端框架/index.html","hash":"1e50b421e537d35105a2b5230cc4af48d4608200","modified":1653560653884},{"_id":"public/tags/h5与ue4/index.html","hash":"b541d3dbe46e279ce6244e6c3f82afbefdbba10d","modified":1653560653884},{"_id":"public/tags/echarts/index.html","hash":"b9dea265c9c4ab74f780e321751523d90ec2d774","modified":1653560653884},{"_id":"public/tags/jenkins/index.html","hash":"3644c9223638f6c80413f787cbf6ec38cececdb1","modified":1653560653884},{"_id":"public/tags/浏览器渲染/index.html","hash":"5b2145fee2a6123af1785dc1b640d2053e87c3e3","modified":1653560653884},{"_id":"public/tags/d3js/index.html","hash":"342527f95408480d08fa61de4a45d07fbf340447","modified":1653560653884},{"_id":"public/tags/浏览器的进程和线程/index.html","hash":"7895cc5672d4b1d886d9db6f259165210e1c500e","modified":1653560653884},{"_id":"public/tags/svg/index.html","hash":"588a91d3f392c2b9a42c8512870c246f356e0da5","modified":1653560653884},{"_id":"public/tags/react/index.html","hash":"d6a160666cd29d3a815c57815ce4620ae762799b","modified":1653560653884},{"_id":"public/archives/index.html","hash":"07cab6be122de6609de48ce629e0d626cee91b53","modified":1653560653884},{"_id":"public/archives/2021/index.html","hash":"d6ffb8dfe4a22d27fbe1c3f6d0d39b0fe3f48459","modified":1653560653884},{"_id":"public/archives/2021/07/index.html","hash":"782a68dcb94626ea6eade2911e699c5924a982d6","modified":1653560653884},{"_id":"public/archives/2021/08/index.html","hash":"9004669280a0d18559a47c8d563a9a73363cf3b5","modified":1653560653884},{"_id":"public/archives/2021/09/index.html","hash":"ad91ccd33cd90502b295b8bdb629c071315c5540","modified":1653560653884},{"_id":"public/archives/2021/10/index.html","hash":"bc924de643b7dd7772fd5806b6cc817ecc704a8e","modified":1653560653884},{"_id":"public/archives/2022/index.html","hash":"eb266b7af3e2360bf7d7017a0033396456288efc","modified":1653560653884},{"_id":"public/archives/2022/02/index.html","hash":"40cc2bfcca4fae93e1aec295bce6e3b0d009e9e5","modified":1653560653884},{"_id":"public/archives/2022/03/index.html","hash":"b7da44ad8f30203bc640ac494d00b060c6c1e176","modified":1653560653884},{"_id":"public/404.html","hash":"a54817566dc7823eb4ea1c8bab0d1d32609342a1","modified":1653560653884},{"_id":"public/2022/03/23/liu-lan-qi-jin-cheng-he-xian-cheng/index.html","hash":"f840785c2f70ea37d74a7dc4a3e5fe23f13e2e4a","modified":1653560653884},{"_id":"public/2022/02/22/liu-lan-qi-ye-mian-de-xuan-ran-guo-cheng/index.html","hash":"07413fc9f57ec3ebeb10cab273f272ac627278e6","modified":1653560653884},{"_id":"public/2022/02/10/da-jian-jenkins/index.html","hash":"d195da12c4defb81dafb02351683d2142e3ede83","modified":1653560653884},{"_id":"public/2021/10/18/h5-yu-ue4-tong-xun/index.html","hash":"9c9317b910d2177fb7d3d093b03169e0c774a4fb","modified":1653560653884},{"_id":"public/2021/09/22/svg/index.html","hash":"3a74612c20bc8ebf34158f506460246b8954737b","modified":1653560653884},{"_id":"public/2021/08/25/react/index.html","hash":"b13cedca5cb053705f284ef06c62ad688e742806","modified":1653560653884},{"_id":"public/2021/07/17/echarts/index.html","hash":"f3bbcc0c1c26bce7fdd90d5fcd8b154eae0dd0ef","modified":1653560653884},{"_id":"public/2021/07/14/d3/index.html","hash":"a0590571ae12ae8428850ab9d6d246f0e1d68e86","modified":1653560653884},{"_id":"public/index.html","hash":"89b216276b012c6c034355f763d1b44fd0d306b1","modified":1653560653884},{"_id":"public/links/index.html","hash":"dfe17fd643ca96a3edcf31d6fff729abc57ce887","modified":1653560653884},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1653560653884},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1653560653884},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1653560653884},{"_id":"public/css/gitalk.css","hash":"2234d7496740d11b5b53aaaef9155dcb2c6f3f73","modified":1653560653884},{"_id":"public/css/highlight.css","hash":"54b718c687ce8460e10d501c1eb53a8098942c1e","modified":1653560653884},{"_id":"public/css/highlight-dark.css","hash":"5ab9082a6fd29f7f8ffad02a606967bb841a2ab4","modified":1653560653884},{"_id":"public/js/color-schema.js","hash":"7af74b80ed6ad2ec5679128878b0348a45837a96","modified":1653560653884},{"_id":"public/js/boot.js","hash":"4288142bbc88feaab612041501128dcc742736d5","modified":1653560653884},{"_id":"public/js/events.js","hash":"c97f83cf37b1bb0761a33d9d78e10ae3b5a72c60","modified":1653560653884},{"_id":"public/js/img-lazyload.js","hash":"ac2ff1b8443cba055fa8f51e206392c19f627322","modified":1653560653884},{"_id":"public/js/leancloud.js","hash":"a102abbdd0102f0ff6524c870359c1af2a7b6c9c","modified":1653560653884},{"_id":"public/js/utils.js","hash":"a663a634bf0f32ec29490d8d69f9337a46ad565c","modified":1653560653884},{"_id":"public/js/local-search.js","hash":"93c0e4266bde2af8aad7ecf2550c4354fb756375","modified":1653560653884},{"_id":"public/js/plugins.js","hash":"02fbe3be6741a1506b4838a63562614e9de7cd0a","modified":1653560653884},{"_id":"public/css/main.css","hash":"9c75eb04ef33afcabbaf044fa5d90227e35429d7","modified":1653560653884},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1653560653884}],"Category":[{"name":"h5与ue4","_id":"cl3mvbinl000418uq2j3v10zq"},{"name":"前端可视化库","_id":"cl3mvbinq000c18uq3jhqetgq"},{"name":"自动化部署","_id":"cl3mvbins000h18uq1e3dehpo"},{"name":"浏览器相关知识","_id":"cl3mvbins000l18uqcxwf3407"},{"name":"前端框架","_id":"cl3mvbinz001218uq1rws5h48"}],"Data":[],"Page":[{"title":"404","date":"2018-09-30T09:25:30.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2018-09-30 17:25:30\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---\n","updated":"2021-10-11T10:22:08.096Z","path":"404/index.html","comments":1,"_id":"cl3mvbinc000018uqcu2vaog8","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"categories","date":"2021-10-11T10:43:03.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-10-11 18:43:03\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2021-10-11T15:44:14.888Z","path":"categories/index.html","comments":1,"_id":"cl3mvbini000218uqg4cd5heh","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"联系小的","date":"2021-10-11T10:20:51.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: 联系小的\ndate: 2021-10-11 18:20:51\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2021-10-11T15:45:03.582Z","path":"contact/index.html","comments":1,"_id":"cl3mvbinn000618uq2xnr5zu5","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"有关于我","date":"2021-10-11T10:17:45.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 有关于我\ndate: 2021-10-11 18:17:45\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2021-10-11T10:20:11.008Z","path":"about/index.html","comments":1,"_id":"cl3mvbinp000818uqfnowfry9","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"🏷️标签","date":"2021-10-11T10:20:39.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 🏷️标签\ndate: 2021-10-11 18:20:39\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2021-10-11T15:45:31.503Z","path":"tags/index.html","comments":1,"_id":"cl3mvbinq000a18uq4j24g302","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"h5与ue4通讯","keywords":"h5与ue4通讯 js与h5交互 web与h5通讯","_content":"## 一、技术方案：\n\nUE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信\n\n注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作\n\n## 二、前端技术栈\n\nvue3+quasar+axios+vue-router\n\n注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1\n\n## 三、核心流程\n\n<!--ue4传数据给h5后续补充-->\n\n1. h5传数据给UE4\n\n   - 判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）\n\n    ```js\n     const ue = window.ue;\n     const isHasUE = typeof ue !== \"undefined\" && ue !== null ? true : false;\n     ```\n\n   - 调用UE中定义的挂载在ue对象中的对应方法\n\n    ```js\n     function MinimizeApp(trackdata) {\n       return function(callback) {\n         if (!isHasUE) {\n           console.log(\"ue initial faild! can't call function!~\");\n           return;\n         }\n          // 这里的webapi是和ue同事沟通统一的名称 \n         ue.webapi\n         \t// 这里的方法名要全部小写，需要和ue同事进行统一\n           .minimizeapp(JSON.stringify(trackdata))\n           .then(function(ret) {\n             // ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue\n             callback(ret);\n           })\n           .catch(function(error) {\n             console.log(error);\n           });\n       };\n     }\n     ```\n\n     \n\n## 四、问题及解决方案\n\n1. UE4加载web项目显示空白问题\n\n   - 问题产生原因：UE4中的Chromium内核不支持ES module\n\n   - UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：\n\n    ```\n     CEF 3.3071.1611.g4a19305\n     Chromium    59.0.3071.15\n     OS  Windows\n     WebKit  537.36 (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)\n     JavaScript  5.9.211.4\n     Flash   \n     User Agent  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15 Safari/537.36\n     Command Line    \"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe\" --browser-subprocess-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe\" --no-sandbox --product-version=\"Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15\" --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources\" --locales-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales\" --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling\n     Module Path D:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll\n     Cache Path  D:/***/Saved/webcache\n     ```\n\n   - 通过查询该浏览器版本支持的对应功能（查询网站：[查询浏览器支持的语法、API等](http://html5test.com/))发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。\n\n   - ![cef3-htm5test](/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png)\n\n   - 解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着**如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。**使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换\n\n    ```vue\n     transpileDependencies: ['quasar' ]\n     ```\n\n2. h5给ue4传输数组数据或对象失败问题\n\n   - 问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作\n   - 解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()","source":"_posts/h5与ue4通讯.md","raw":"---\ntitle: h5与ue4通讯\ntag: h5与ue4\nkeywords: h5与ue4通讯 js与h5交互 web与h5通讯\ncategories: h5与ue4\n---\n## 一、技术方案：\n\nUE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信\n\n注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作\n\n## 二、前端技术栈\n\nvue3+quasar+axios+vue-router\n\n注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1\n\n## 三、核心流程\n\n<!--ue4传数据给h5后续补充-->\n\n1. h5传数据给UE4\n\n   - 判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）\n\n    ```js\n     const ue = window.ue;\n     const isHasUE = typeof ue !== \"undefined\" && ue !== null ? true : false;\n     ```\n\n   - 调用UE中定义的挂载在ue对象中的对应方法\n\n    ```js\n     function MinimizeApp(trackdata) {\n       return function(callback) {\n         if (!isHasUE) {\n           console.log(\"ue initial faild! can't call function!~\");\n           return;\n         }\n          // 这里的webapi是和ue同事沟通统一的名称 \n         ue.webapi\n         \t// 这里的方法名要全部小写，需要和ue同事进行统一\n           .minimizeapp(JSON.stringify(trackdata))\n           .then(function(ret) {\n             // ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue\n             callback(ret);\n           })\n           .catch(function(error) {\n             console.log(error);\n           });\n       };\n     }\n     ```\n\n     \n\n## 四、问题及解决方案\n\n1. UE4加载web项目显示空白问题\n\n   - 问题产生原因：UE4中的Chromium内核不支持ES module\n\n   - UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：\n\n    ```\n     CEF 3.3071.1611.g4a19305\n     Chromium    59.0.3071.15\n     OS  Windows\n     WebKit  537.36 (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)\n     JavaScript  5.9.211.4\n     Flash   \n     User Agent  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15 Safari/537.36\n     Command Line    \"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe\" --browser-subprocess-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe\" --no-sandbox --product-version=\"Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15\" --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources\" --locales-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales\" --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling\n     Module Path D:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll\n     Cache Path  D:/***/Saved/webcache\n     ```\n\n   - 通过查询该浏览器版本支持的对应功能（查询网站：[查询浏览器支持的语法、API等](http://html5test.com/))发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。\n\n   - ![cef3-htm5test](/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png)\n\n   - 解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着**如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。**使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换\n\n    ```vue\n     transpileDependencies: ['quasar' ]\n     ```\n\n2. h5给ue4传输数组数据或对象失败问题\n\n   - 问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作\n   - 解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()","slug":"h5与ue4通讯","published":1,"date":"2021-10-18T06:42:32.034Z","updated":"2021-10-18T09:38:17.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbine000118uqfi719xqn","content":"<h2 id=\"一、技术方案：\"><a href=\"#一、技术方案：\" class=\"headerlink\" title=\"一、技术方案：\"></a>一、技术方案：</h2><p>UE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信</p>\n<p>注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作</p>\n<h2 id=\"二、前端技术栈\"><a href=\"#二、前端技术栈\" class=\"headerlink\" title=\"二、前端技术栈\"></a>二、前端技术栈</h2><p>vue3+quasar+axios+vue-router</p>\n<p>注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1</p>\n<h2 id=\"三、核心流程\"><a href=\"#三、核心流程\" class=\"headerlink\" title=\"三、核心流程\"></a>三、核心流程</h2><!--ue4传数据给h5后续补充-->\n\n<ol>\n<li><p>h5传数据给UE4</p>\n<ul>\n<li>判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ue = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">ue</span>;<br><span class=\"hljs-keyword\">const</span> isHasUE = <span class=\"hljs-keyword\">typeof</span> ue !== <span class=\"hljs-string\">&quot;undefined&quot;</span> &amp;&amp; ue !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>调用UE中定义的挂载在ue对象中的对应方法</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MinimizeApp</span>(<span class=\"hljs-params\">trackdata</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!isHasUE) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ue initial faild! can&#x27;t call function!~&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>     <span class=\"hljs-comment\">// 这里的webapi是和ue同事沟通统一的名称 </span><br>    ue.<span class=\"hljs-property\">webapi</span><br>    \t<span class=\"hljs-comment\">// 这里的方法名要全部小写，需要和ue同事进行统一</span><br>      .<span class=\"hljs-title function_\">minimizeapp</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(trackdata))<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>) &#123;<br>        <span class=\"hljs-comment\">// ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue</span><br>        <span class=\"hljs-title function_\">callback</span>(ret);<br>      &#125;)<br>      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>      &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"四、问题及解决方案\"><a href=\"#四、问题及解决方案\" class=\"headerlink\" title=\"四、问题及解决方案\"></a>四、问题及解决方案</h2><ol>\n<li><p>UE4加载web项目显示空白问题</p>\n<ul>\n<li><p>问题产生原因：UE4中的Chromium内核不支持ES module</p>\n</li>\n<li><p>UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：</p>\n</li>\n</ul>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">CEF</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">1611</span>.g4a19305<br><span class=\"hljs-attribute\">Chromium</span>    <span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span><br><span class=\"hljs-attribute\">OS</span>  Windows<br><span class=\"hljs-attribute\">WebKit</span>  <span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)<br><span class=\"hljs-attribute\">JavaScript</span>  <span class=\"hljs-number\">5.9.211.4</span><br><span class=\"hljs-attribute\">Flash</span>   <br><span class=\"hljs-attribute\">User</span> Agent  Mozilla/<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">0</span> (Windows NT <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">0</span>; Win64; x64) AppleWebKit/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (KHTML, like Gecko) Digital/++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>-CL-<span class=\"hljs-number\">15973114</span> UnrealEngine/<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>.<span class=\"hljs-number\">2</span>-<span class=\"hljs-number\">15973114</span>+++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span> Chrome/<span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span> Safari/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span><br><span class=\"hljs-attribute\">Command</span> Line    <span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe&quot;</span> --browser-subprocess-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe&quot;</span> --no-sandbox --product-version=<span class=\"hljs-string\">&quot;Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15&quot;</span> --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources&quot;</span> --locales-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales&quot;</span> --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling<br><span class=\"hljs-attribute\">Module</span> Path D:\\Program Files\\Epic Games\\UE_4.<span class=\"hljs-number\">26</span>\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll<br><span class=\"hljs-attribute\">Cache</span> Path  D:/***/Saved/webcache<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>通过查询该浏览器版本支持的对应功能（查询网站：<a href=\"http://html5test.com/\">查询浏览器支持的语法、API等</a>)发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。</p>\n</li>\n<li><p><img src=\"/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png\" alt=\"cef3-htm5test\"></p>\n</li>\n<li><p>解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着<strong>如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。</strong>使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换</p>\n</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">transpileDependencies: [&#x27;quasar&#x27; ]<br></code></pre></td></tr></table></figure></li>\n<li><p>h5给ue4传输数组数据或对象失败问题</p>\n<ul>\n<li>问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作</li>\n<li>解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":2718,"excerpt":"","more":"<h2 id=\"一、技术方案：\"><a href=\"#一、技术方案：\" class=\"headerlink\" title=\"一、技术方案：\"></a>一、技术方案：</h2><p>UE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信</p>\n<p>注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作</p>\n<h2 id=\"二、前端技术栈\"><a href=\"#二、前端技术栈\" class=\"headerlink\" title=\"二、前端技术栈\"></a>二、前端技术栈</h2><p>vue3+quasar+axios+vue-router</p>\n<p>注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1</p>\n<h2 id=\"三、核心流程\"><a href=\"#三、核心流程\" class=\"headerlink\" title=\"三、核心流程\"></a>三、核心流程</h2><!--ue4传数据给h5后续补充-->\n\n<ol>\n<li><p>h5传数据给UE4</p>\n<ul>\n<li>判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ue = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">ue</span>;<br><span class=\"hljs-keyword\">const</span> isHasUE = <span class=\"hljs-keyword\">typeof</span> ue !== <span class=\"hljs-string\">&quot;undefined&quot;</span> &amp;&amp; ue !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>调用UE中定义的挂载在ue对象中的对应方法</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MinimizeApp</span>(<span class=\"hljs-params\">trackdata</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!isHasUE) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ue initial faild! can&#x27;t call function!~&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>     <span class=\"hljs-comment\">// 这里的webapi是和ue同事沟通统一的名称 </span><br>    ue.<span class=\"hljs-property\">webapi</span><br>    \t<span class=\"hljs-comment\">// 这里的方法名要全部小写，需要和ue同事进行统一</span><br>      .<span class=\"hljs-title function_\">minimizeapp</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(trackdata))<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>) &#123;<br>        <span class=\"hljs-comment\">// ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue</span><br>        <span class=\"hljs-title function_\">callback</span>(ret);<br>      &#125;)<br>      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>      &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"四、问题及解决方案\"><a href=\"#四、问题及解决方案\" class=\"headerlink\" title=\"四、问题及解决方案\"></a>四、问题及解决方案</h2><ol>\n<li><p>UE4加载web项目显示空白问题</p>\n<ul>\n<li><p>问题产生原因：UE4中的Chromium内核不支持ES module</p>\n</li>\n<li><p>UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：</p>\n</li>\n</ul>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">CEF</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">1611</span>.g4a19305<br><span class=\"hljs-attribute\">Chromium</span>    <span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span><br><span class=\"hljs-attribute\">OS</span>  Windows<br><span class=\"hljs-attribute\">WebKit</span>  <span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)<br><span class=\"hljs-attribute\">JavaScript</span>  <span class=\"hljs-number\">5.9.211.4</span><br><span class=\"hljs-attribute\">Flash</span>   <br><span class=\"hljs-attribute\">User</span> Agent  Mozilla/<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">0</span> (Windows NT <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">0</span>; Win64; x64) AppleWebKit/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (KHTML, like Gecko) Digital/++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>-CL-<span class=\"hljs-number\">15973114</span> UnrealEngine/<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>.<span class=\"hljs-number\">2</span>-<span class=\"hljs-number\">15973114</span>+++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span> Chrome/<span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span> Safari/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span><br><span class=\"hljs-attribute\">Command</span> Line    <span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe&quot;</span> --browser-subprocess-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe&quot;</span> --no-sandbox --product-version=<span class=\"hljs-string\">&quot;Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15&quot;</span> --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources&quot;</span> --locales-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales&quot;</span> --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling<br><span class=\"hljs-attribute\">Module</span> Path D:\\Program Files\\Epic Games\\UE_4.<span class=\"hljs-number\">26</span>\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll<br><span class=\"hljs-attribute\">Cache</span> Path  D:/***/Saved/webcache<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>通过查询该浏览器版本支持的对应功能（查询网站：<a href=\"http://html5test.com/\">查询浏览器支持的语法、API等</a>)发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。</p>\n</li>\n<li><p><img src=\"/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png\" alt=\"cef3-htm5test\"></p>\n</li>\n<li><p>解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着<strong>如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。</strong>使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换</p>\n</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">transpileDependencies: [&#x27;quasar&#x27; ]<br></code></pre></td></tr></table></figure></li>\n<li><p>h5给ue4传输数组数据或对象失败问题</p>\n<ul>\n<li>问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作</li>\n<li>解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()</li>\n</ul>\n</li>\n</ol>\n"},{"title":"echarts学习笔记","keywords":"echarts","_content":"### 一、柱状图（type为bar）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.xAxis和yAxis\n\ntype为category时，需要指定data\n\ntype为value时，data在series中指定\n\n#### 3.常见效果\n\n- 标记：最大值、最小值、平均值\n\n  ```javascript\n  markPoint：{\n    data: [\n      {\n        type: 'max'，\n        name: '最大值'\n      },\n      {\n        type: 'min',\n        name: '最小值'\n      }\n    ]\n  },\n    markLine: {\n      data: [\n        {\n          type: 'average'，\n          name: '平均值'\n        }\n      ]\n    }\n  ```\n\n\n- 显示：\n\n  label：数值显示\n\n  barWidth： 柱宽度\n\n  横向柱状图：xAxis和yAxis配置互换\n\n### 二、通用配置\n\n- title标题\n  - 文字样式：textStyle\n  - 标题边框：borderWidth、borderColor、borderRadius\n  - 标题位置：left、top、right、bottom\n- tooltip提示框组件\n  - 触发类型：trigger\n    - item\n    - axis\n  - 触发时机：triggerOn\n    - mouseover\n    - click\n  - 格式化：formatter\n    - 字符串模板\n    - 回调函数（参数：arg）\n- toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）\n  - feature（显示工具栏按钮）\n    - savaAsImage（导出图片）\n    - dataView（数据视图）\n    - dataZoom（数据区域缩放）\n    - restore（重置）\n    - magicType（动态类型切换）：如magicType： { type: ['bar', 'line']}\n- legend图例（用于筛选系列，需要和series配合使用）\n  - legend中的data是一个数组\n  - legend中的data的值需要和series数组中某组数据的name值一致\n\n### 三、折线图（type为line）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.常用效果\n\n- 标记：最大值、最小值、平均值、标注区间\n  - markPoint\n  - markLine\n  - markArea\n- 线条控制：平滑、风格\n  - smooth、lineStyle \n- 填充风格\n  - areaStyle\n- 紧挨y轴边缘（设置在xAxis）\n  - boundaryGap\n- 缩放：脱离0值比例\n  - scale：true\n- 堆叠图\n  - stack：all\n  - 可以和areaStyle配合使用\n\n### 四、散点图（type为scatter）\n\n#### 1.数据格式\n\n二维数组\n\n#### 2.基本的散点图\n\n- x轴和y轴type都是value\n- x轴和y轴的数据，是一个二维数组\n- type为scatter\n\n#### 3.常用效果\n\n- 气泡图效果\n  - 散点大小不同：symbolSize\n  - 散点的颜色不同：itemStyle.color\n- 涟漪动画效果\n  - type: effectScatter\n  - showEffectOn: 'emphasis' 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）\n  - rippleEffect: { scale: 10} 散点涟漪效果的范围\n\n### 五、直角坐标系的常用配置\n\n直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）\n\n- grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）\n  - 显示gird\n    - show\n  - grid的边框\n    - borderWidth、borderColor\n  - grid的位置和大小\n    - left\n    - top\n    - right\n    - bottom\n- axis坐标轴（分为x轴和y轴）\n  - 坐标轴类型type\n    - value：数值周，自动会从目标数据中读取数据\n    - category：类目轴，该类型必须通过data设置类目数据\n  - 显示位置position\n    - xAxis：可取值为top或bottom\n    - yAxis：可取值为left或right\n- 区域缩放dataZoom\n  - dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器\n  - 类型type\n    - slider：滑块控制缩放\n    - inside：内置，依靠鼠标滚轮或者双指缩放\n  - 指明产生作用的轴\n    - xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可\n    - yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可\n  - 指明初始状态的缩放情况\n    - start：数据窗口范围的起始百分比\n    - end：数据窗口范围的结束百分比\n\n### 六、饼图（type为pie）\n\n#### 1.数据格式\n\njson数据：data: [{name: '京东'，value: '9000'}]\n\n#### 2.基本的饼图\n\n- 数据是json数据格式\n- type为pie\n- 无须配置xAxis和yAxis\n\n#### 3.饼图常见效果\n\n- 显示数值\n  - lable.formatter\n- 圆环\n  - 设置两个半径 radius：['50%', '70%'] 分别是内半径和外半径\n- 南丁格尔图\n  - roseType：'radius'\n- 选中效果\n  - 选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）\n  - 选中偏移量 selectOffset：30\n\n### 七、地图（type：map）\n\n#### 1.矢量地图的实现步骤\n\n- Echarts最基本的代码结构\n  - 引入js文件\n  - 带宽高的DOM容器\n  - init初始化对象\n  - setOption设置option\n- 准备中国的矢量地图json文件（http://datav.aliyun.com/tools/atlas/index.html#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5）\n- 使用ajax获取json\n  - $.get('json/map/china.json', function(chinaJson){})\n- 往echarts全局对象注册地图的json数据\n  - echarts.registerMap('chinaMap', chinaJson)\n- 在geo下设置\n  - type:'map'\n  - map:'chinaMap'\n\n#### 2.常用配置\n\n- 缩放拖动\n  - roam：true\n- 名称显示\n  - label\n- 初始缩放比例\n  - zoom：2（2倍）\n- 地图中心点\n  - center\n\n#### 3.常见效果\n\n- 不同城市颜色不同（如空气质量）\n\n  1. 显示基本的中国地图\n\n  2. 城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ''}]的格式，其中name属性必须和省份名一致）\n\n  3. 将series下的数据与geo关联起来\n\n     设置type: 'map'，geoIndex:0\n\n  4. 结合visualMap配合使用\n\n     visualMap: {min: 0, max: 40, range: { color: ['white', 'red']}}\n\n- 地图和散点图结合\n\n  1. 给series下配置散点图对象\n\n  2. 准备好散点数据，设置给新对象的data（二维数组，地图坐标）\n\n  3. 配置新对象的type为effectScatter\n\n  4. 让散点图使用地图坐标系统\n\n     coordinateSystem: 'geo'\n\n  5. 让涟漪的效果更加明显\n\n     rippleEffect：{ scale：10 }\n\n### 八、雷达图（type：radar）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 定义各个维度的最大值（在radar属性下）\n  - indicator：[{name: '易用性', max: 100]}]\n- 准备具体产品的数据\n  - 在series下设置data：[{name: '华为手机', value: [80, 80, 90, 95, 85]}\n- 设置图表类型\n  - 在series下设置type：radar\n\n#### 2.常用配置\n\n- 显示数值:\n  - label\n- 区域面积（阴影）\n  - areaStyle\n- 绘制类型\n  - shape: 'circle' 默认值 polygon\n\n### 九、仪表盘（type：guage）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 准备数据，设置给series下的data\n  - data: [{value: 97}]\n- 图标类型\n  - 在series下设置type：guage\n\n#### 2.常用效果\n\n- 数值范围\n  - max\n  - min\n- 多个指针\n  - 增加series下data数组中的元素\n- 多个指针颜色差异\n  - itemStyle\n\n### 十、主题\n\n#### 1.内置主题\n\n- echarts中默认内置了两套主题：light、dark\n\n- 在初始化对象方法中init中可以指明\n\n  var chart = echarts.init(dom, 'light')\n\n  var chart = echarts.init(dom, 'dark')\n\n#### 2.自定义主题\n\n- 1.在官网主题编辑器中编辑主题\n- 2.下载主题js文件\n- 3.引入主题js文件\n- 4.在init方法中使用主题\n\n### 十一、调色盘\n\n#### 1.它是一组颜色，图形、系列会自动从其中选择颜色\n\n- 主题调色盘（主题js文件中全局注册的color）\n\n- 全局调色盘\n\n  options：{\n\n  ​\tcolor： ['red', 'green', 'blue']\n\n  }\n\n- 局部调色盘\n\n  series: [{\n\n  ​\ttype: 'bar',\n\n  ​\tcolor: ['red', 'green', 'blue']\n\n  }]\n\n#### 2.调色盘的作用遵循就近原则\n\n#### 3.颜色渐变\n\n- 线性渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'linear',\n        x: 0, // 在图元中的初始x位置\n        y: 0, // 在图元中的初始y位置\n        x2: 0,\n        y2: 1, // 1代表到底部，0.5在中间\n          colorStops: [{\n            offset: 0, color: 'red' // 0%处的颜色 \n          },{\n            offset: 1, color: 'blue' // 100%处的颜色\n          }]\n    }\n  }\n  ```\n\n- 径向渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'radial',\n        x: 0.5, \n        y: 0.5,\n        r: 0.5, // 扩散的半径\n          colorStops: [{\n            offset: 0, color: 'red'\n          }, {\n            offset: 1, color: 'blue'\n          }]\n    }\n  }\n  ```\n\n### 十二、样式\n\n- 直接样式\n  - itemStyle、textStyle、lineStyle、areaStyle、label\n- 高亮样式\n  - 在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label\n- 优先级高，会覆盖主题中、调色盘的效果\n\n### 十三、自适应\n\n当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化\n\n- 1.监听窗口大小变化事件\n\n- 2.在事件处理函数中调用echarts实例对象的resize方法即可\n\n  window.onresize = myChart.resize\n\n### 十四、加载动画\n\necharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可\n\n- 显示加载动画\n\n  mCharts.showLoading()\n\n- 隐藏加载动画\n\n  mCharts.hideLoading()\n\n### 十五、增量动画\n\n- 增量动画的实现方式\n  - mCharts.setOption\n    - 所有数据的更新都通过setOption实现\n    - 不用考虑数据到底产生了哪些变化\n    - echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化\n    - 新旧option的关系并不是相互覆盖的关系，而是相互整合的关系\n    - 我们在设置新的option的时候，只需要考虑到变化的部分就可以\n\n### 十六、动画配置项\n\n- 开启动画\n\n  - animation：true\n\n- 动画时长\n\n  - animationDuration：5000\n\n  ```javascript\n    animationDuration： function（arg） {\n      // 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组\n      return arg * 10\n    }\n    ```\n\n- 缓动动画\n\n  - animationEasing: 'bounceOut'\n\n- 动画阈值\n\n  - animationThreshold： 8\n  - 单中形式的元素数量大于这个阈值会关闭动画\n\n### 十七、全局Echarts对象常用方法\n\n- init方法\n\n  - 初始化Echarts实例对象\n  - 使用主题（第二个参数）\n\n- registerTheme方法\n\n  - 注册主题\n  - 只有注册过的主题，才能在init方法中使用该主题\n\n- registerMap方法\n\n  - 注册地图数据\n\n    ```javascript\n      $.get('json/map/china.json', function(ChinaJson) {\n        echarts.registerMap('china', chinaJson)\n      })\n      ```\n\n  - geo组件使用地图数据\n\n    ```javascript\n      var option = {\n        geo: {\n          type: 'map',\n          map: 'china'\n        }\n      }\n      ```\n\n- connect方法\n\n  - 一个页面中可以有多个独立的图表\n  - 每一个图表对应一个Echarts实例对象\n  - connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组\n    - 保存图片的自动拼接（saveAsImage）\n    - 刷新按钮\n    - 重置按钮\n    - 提示框联动、图例选择、数据范围修改等等\n\n### 十八、echartsInstance实例常用方法\n\n- setOption方法\n\n  - 设置或修改图表实例的配置项以及数据\n  - 多次调用setOption方法\n    - 合并新旧配置\n    - 增量动画\n\n- resize方法\n\n  - 重新计算和绘制图表\n  - 一般和window对象的resize事件结合使用\n    - window.onresize = mEcharts.resize\n\n- on\\off方法\n\n  - 绑定或者解绑事件处理函数\n  - 鼠标事件\n    - 常见事件：click、dbclick、mousedown、mousemove、mouseup等\n  - Echarts事件\n    - 常见事件：legendselectchanged、datazoom、pieselectchanged、ma'pselectchanged\n\n- dispatchAction\n\n  - 触发某些行为\n\n  - 使用代码模拟用户的行为\n\n  ```javascript\n    mCharts.dispatchAction({\n      type: 'hightlight', // 事件类型\n      seriesIndex: 0, // 图表索引(系列)\n      dataIndex: 1 // 图表中哪一项高亮\n    })\n    ```\n\n- clear\n\n  - 清空当前实例，会移除实例中所有的组件和图表\n  - 清空之后可以再次setOption\n\n- dispose方法\n\n  - 销毁实例\n  - 销毁后实例无法再被使用\n\n### 十九、websocket的基本使用\n\n- 后端\n\n  - 安装包\n\n    - npm i ws\n\n  - 创建对象\n\n    ```javascript\n      const webSocket = require('ws')\n      const wss = new WebSocket.server({\n        port: '8080'\n      })\n      ```\n\n  - 监听事件\n\n    - 连接事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n        })\n        ```\n\n    - 接受数据事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n          client.on('message', msg => {\n            console.log('客户端发送数据过来了')\n          })\n        })\n        ```\n\n    - 发送数据\n\n      - client.send('hello socket from back-end')\n\n- 前端\n\n  - 创建对象\n\n    ```javascript\n      const ws = new WebSocket('ws://localhost:8080')\n      ```\n\n  - 监听事件\n\n    - 连接成功事件\n      - ws.onopen = () => {}\n    - 接受数据事件\n      - ws.onmessage = msg => {}\n    - 关闭连接事件\n      - ws.onclose = () => {}\n\n  - 发送数据\n\n    - ws.send","source":"_posts/echarts.md","raw":"---\ntitle: echarts学习笔记\ntag: echarts\nkeywords: echarts\ncategories: 前端可视化库\n---\n### 一、柱状图（type为bar）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.xAxis和yAxis\n\ntype为category时，需要指定data\n\ntype为value时，data在series中指定\n\n#### 3.常见效果\n\n- 标记：最大值、最小值、平均值\n\n  ```javascript\n  markPoint：{\n    data: [\n      {\n        type: 'max'，\n        name: '最大值'\n      },\n      {\n        type: 'min',\n        name: '最小值'\n      }\n    ]\n  },\n    markLine: {\n      data: [\n        {\n          type: 'average'，\n          name: '平均值'\n        }\n      ]\n    }\n  ```\n\n\n- 显示：\n\n  label：数值显示\n\n  barWidth： 柱宽度\n\n  横向柱状图：xAxis和yAxis配置互换\n\n### 二、通用配置\n\n- title标题\n  - 文字样式：textStyle\n  - 标题边框：borderWidth、borderColor、borderRadius\n  - 标题位置：left、top、right、bottom\n- tooltip提示框组件\n  - 触发类型：trigger\n    - item\n    - axis\n  - 触发时机：triggerOn\n    - mouseover\n    - click\n  - 格式化：formatter\n    - 字符串模板\n    - 回调函数（参数：arg）\n- toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）\n  - feature（显示工具栏按钮）\n    - savaAsImage（导出图片）\n    - dataView（数据视图）\n    - dataZoom（数据区域缩放）\n    - restore（重置）\n    - magicType（动态类型切换）：如magicType： { type: ['bar', 'line']}\n- legend图例（用于筛选系列，需要和series配合使用）\n  - legend中的data是一个数组\n  - legend中的data的值需要和series数组中某组数据的name值一致\n\n### 三、折线图（type为line）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.常用效果\n\n- 标记：最大值、最小值、平均值、标注区间\n  - markPoint\n  - markLine\n  - markArea\n- 线条控制：平滑、风格\n  - smooth、lineStyle \n- 填充风格\n  - areaStyle\n- 紧挨y轴边缘（设置在xAxis）\n  - boundaryGap\n- 缩放：脱离0值比例\n  - scale：true\n- 堆叠图\n  - stack：all\n  - 可以和areaStyle配合使用\n\n### 四、散点图（type为scatter）\n\n#### 1.数据格式\n\n二维数组\n\n#### 2.基本的散点图\n\n- x轴和y轴type都是value\n- x轴和y轴的数据，是一个二维数组\n- type为scatter\n\n#### 3.常用效果\n\n- 气泡图效果\n  - 散点大小不同：symbolSize\n  - 散点的颜色不同：itemStyle.color\n- 涟漪动画效果\n  - type: effectScatter\n  - showEffectOn: 'emphasis' 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）\n  - rippleEffect: { scale: 10} 散点涟漪效果的范围\n\n### 五、直角坐标系的常用配置\n\n直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）\n\n- grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）\n  - 显示gird\n    - show\n  - grid的边框\n    - borderWidth、borderColor\n  - grid的位置和大小\n    - left\n    - top\n    - right\n    - bottom\n- axis坐标轴（分为x轴和y轴）\n  - 坐标轴类型type\n    - value：数值周，自动会从目标数据中读取数据\n    - category：类目轴，该类型必须通过data设置类目数据\n  - 显示位置position\n    - xAxis：可取值为top或bottom\n    - yAxis：可取值为left或right\n- 区域缩放dataZoom\n  - dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器\n  - 类型type\n    - slider：滑块控制缩放\n    - inside：内置，依靠鼠标滚轮或者双指缩放\n  - 指明产生作用的轴\n    - xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可\n    - yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可\n  - 指明初始状态的缩放情况\n    - start：数据窗口范围的起始百分比\n    - end：数据窗口范围的结束百分比\n\n### 六、饼图（type为pie）\n\n#### 1.数据格式\n\njson数据：data: [{name: '京东'，value: '9000'}]\n\n#### 2.基本的饼图\n\n- 数据是json数据格式\n- type为pie\n- 无须配置xAxis和yAxis\n\n#### 3.饼图常见效果\n\n- 显示数值\n  - lable.formatter\n- 圆环\n  - 设置两个半径 radius：['50%', '70%'] 分别是内半径和外半径\n- 南丁格尔图\n  - roseType：'radius'\n- 选中效果\n  - 选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）\n  - 选中偏移量 selectOffset：30\n\n### 七、地图（type：map）\n\n#### 1.矢量地图的实现步骤\n\n- Echarts最基本的代码结构\n  - 引入js文件\n  - 带宽高的DOM容器\n  - init初始化对象\n  - setOption设置option\n- 准备中国的矢量地图json文件（http://datav.aliyun.com/tools/atlas/index.html#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5）\n- 使用ajax获取json\n  - $.get('json/map/china.json', function(chinaJson){})\n- 往echarts全局对象注册地图的json数据\n  - echarts.registerMap('chinaMap', chinaJson)\n- 在geo下设置\n  - type:'map'\n  - map:'chinaMap'\n\n#### 2.常用配置\n\n- 缩放拖动\n  - roam：true\n- 名称显示\n  - label\n- 初始缩放比例\n  - zoom：2（2倍）\n- 地图中心点\n  - center\n\n#### 3.常见效果\n\n- 不同城市颜色不同（如空气质量）\n\n  1. 显示基本的中国地图\n\n  2. 城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ''}]的格式，其中name属性必须和省份名一致）\n\n  3. 将series下的数据与geo关联起来\n\n     设置type: 'map'，geoIndex:0\n\n  4. 结合visualMap配合使用\n\n     visualMap: {min: 0, max: 40, range: { color: ['white', 'red']}}\n\n- 地图和散点图结合\n\n  1. 给series下配置散点图对象\n\n  2. 准备好散点数据，设置给新对象的data（二维数组，地图坐标）\n\n  3. 配置新对象的type为effectScatter\n\n  4. 让散点图使用地图坐标系统\n\n     coordinateSystem: 'geo'\n\n  5. 让涟漪的效果更加明显\n\n     rippleEffect：{ scale：10 }\n\n### 八、雷达图（type：radar）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 定义各个维度的最大值（在radar属性下）\n  - indicator：[{name: '易用性', max: 100]}]\n- 准备具体产品的数据\n  - 在series下设置data：[{name: '华为手机', value: [80, 80, 90, 95, 85]}\n- 设置图表类型\n  - 在series下设置type：radar\n\n#### 2.常用配置\n\n- 显示数值:\n  - label\n- 区域面积（阴影）\n  - areaStyle\n- 绘制类型\n  - shape: 'circle' 默认值 polygon\n\n### 九、仪表盘（type：guage）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 准备数据，设置给series下的data\n  - data: [{value: 97}]\n- 图标类型\n  - 在series下设置type：guage\n\n#### 2.常用效果\n\n- 数值范围\n  - max\n  - min\n- 多个指针\n  - 增加series下data数组中的元素\n- 多个指针颜色差异\n  - itemStyle\n\n### 十、主题\n\n#### 1.内置主题\n\n- echarts中默认内置了两套主题：light、dark\n\n- 在初始化对象方法中init中可以指明\n\n  var chart = echarts.init(dom, 'light')\n\n  var chart = echarts.init(dom, 'dark')\n\n#### 2.自定义主题\n\n- 1.在官网主题编辑器中编辑主题\n- 2.下载主题js文件\n- 3.引入主题js文件\n- 4.在init方法中使用主题\n\n### 十一、调色盘\n\n#### 1.它是一组颜色，图形、系列会自动从其中选择颜色\n\n- 主题调色盘（主题js文件中全局注册的color）\n\n- 全局调色盘\n\n  options：{\n\n  ​\tcolor： ['red', 'green', 'blue']\n\n  }\n\n- 局部调色盘\n\n  series: [{\n\n  ​\ttype: 'bar',\n\n  ​\tcolor: ['red', 'green', 'blue']\n\n  }]\n\n#### 2.调色盘的作用遵循就近原则\n\n#### 3.颜色渐变\n\n- 线性渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'linear',\n        x: 0, // 在图元中的初始x位置\n        y: 0, // 在图元中的初始y位置\n        x2: 0,\n        y2: 1, // 1代表到底部，0.5在中间\n          colorStops: [{\n            offset: 0, color: 'red' // 0%处的颜色 \n          },{\n            offset: 1, color: 'blue' // 100%处的颜色\n          }]\n    }\n  }\n  ```\n\n- 径向渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'radial',\n        x: 0.5, \n        y: 0.5,\n        r: 0.5, // 扩散的半径\n          colorStops: [{\n            offset: 0, color: 'red'\n          }, {\n            offset: 1, color: 'blue'\n          }]\n    }\n  }\n  ```\n\n### 十二、样式\n\n- 直接样式\n  - itemStyle、textStyle、lineStyle、areaStyle、label\n- 高亮样式\n  - 在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label\n- 优先级高，会覆盖主题中、调色盘的效果\n\n### 十三、自适应\n\n当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化\n\n- 1.监听窗口大小变化事件\n\n- 2.在事件处理函数中调用echarts实例对象的resize方法即可\n\n  window.onresize = myChart.resize\n\n### 十四、加载动画\n\necharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可\n\n- 显示加载动画\n\n  mCharts.showLoading()\n\n- 隐藏加载动画\n\n  mCharts.hideLoading()\n\n### 十五、增量动画\n\n- 增量动画的实现方式\n  - mCharts.setOption\n    - 所有数据的更新都通过setOption实现\n    - 不用考虑数据到底产生了哪些变化\n    - echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化\n    - 新旧option的关系并不是相互覆盖的关系，而是相互整合的关系\n    - 我们在设置新的option的时候，只需要考虑到变化的部分就可以\n\n### 十六、动画配置项\n\n- 开启动画\n\n  - animation：true\n\n- 动画时长\n\n  - animationDuration：5000\n\n  ```javascript\n    animationDuration： function（arg） {\n      // 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组\n      return arg * 10\n    }\n    ```\n\n- 缓动动画\n\n  - animationEasing: 'bounceOut'\n\n- 动画阈值\n\n  - animationThreshold： 8\n  - 单中形式的元素数量大于这个阈值会关闭动画\n\n### 十七、全局Echarts对象常用方法\n\n- init方法\n\n  - 初始化Echarts实例对象\n  - 使用主题（第二个参数）\n\n- registerTheme方法\n\n  - 注册主题\n  - 只有注册过的主题，才能在init方法中使用该主题\n\n- registerMap方法\n\n  - 注册地图数据\n\n    ```javascript\n      $.get('json/map/china.json', function(ChinaJson) {\n        echarts.registerMap('china', chinaJson)\n      })\n      ```\n\n  - geo组件使用地图数据\n\n    ```javascript\n      var option = {\n        geo: {\n          type: 'map',\n          map: 'china'\n        }\n      }\n      ```\n\n- connect方法\n\n  - 一个页面中可以有多个独立的图表\n  - 每一个图表对应一个Echarts实例对象\n  - connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组\n    - 保存图片的自动拼接（saveAsImage）\n    - 刷新按钮\n    - 重置按钮\n    - 提示框联动、图例选择、数据范围修改等等\n\n### 十八、echartsInstance实例常用方法\n\n- setOption方法\n\n  - 设置或修改图表实例的配置项以及数据\n  - 多次调用setOption方法\n    - 合并新旧配置\n    - 增量动画\n\n- resize方法\n\n  - 重新计算和绘制图表\n  - 一般和window对象的resize事件结合使用\n    - window.onresize = mEcharts.resize\n\n- on\\off方法\n\n  - 绑定或者解绑事件处理函数\n  - 鼠标事件\n    - 常见事件：click、dbclick、mousedown、mousemove、mouseup等\n  - Echarts事件\n    - 常见事件：legendselectchanged、datazoom、pieselectchanged、ma'pselectchanged\n\n- dispatchAction\n\n  - 触发某些行为\n\n  - 使用代码模拟用户的行为\n\n  ```javascript\n    mCharts.dispatchAction({\n      type: 'hightlight', // 事件类型\n      seriesIndex: 0, // 图表索引(系列)\n      dataIndex: 1 // 图表中哪一项高亮\n    })\n    ```\n\n- clear\n\n  - 清空当前实例，会移除实例中所有的组件和图表\n  - 清空之后可以再次setOption\n\n- dispose方法\n\n  - 销毁实例\n  - 销毁后实例无法再被使用\n\n### 十九、websocket的基本使用\n\n- 后端\n\n  - 安装包\n\n    - npm i ws\n\n  - 创建对象\n\n    ```javascript\n      const webSocket = require('ws')\n      const wss = new WebSocket.server({\n        port: '8080'\n      })\n      ```\n\n  - 监听事件\n\n    - 连接事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n        })\n        ```\n\n    - 接受数据事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n          client.on('message', msg => {\n            console.log('客户端发送数据过来了')\n          })\n        })\n        ```\n\n    - 发送数据\n\n      - client.send('hello socket from back-end')\n\n- 前端\n\n  - 创建对象\n\n    ```javascript\n      const ws = new WebSocket('ws://localhost:8080')\n      ```\n\n  - 监听事件\n\n    - 连接成功事件\n      - ws.onopen = () => {}\n    - 接受数据事件\n      - ws.onmessage = msg => {}\n    - 关闭连接事件\n      - ws.onclose = () => {}\n\n  - 发送数据\n\n    - ws.send","slug":"echarts","published":1,"date":"2021-07-17T08:49:18.000Z","updated":"2021-10-14T01:24:36.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinj000318uqhn6r4zy2","content":"<h3 id=\"一、柱状图（type为bar）\"><a href=\"#一、柱状图（type为bar）\" class=\"headerlink\" title=\"一、柱状图（type为bar）\"></a>一、柱状图（type为bar）</h3><h4 id=\"1-数据格式\"><a href=\"#1-数据格式\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-xAxis和yAxis\"><a href=\"#2-xAxis和yAxis\" class=\"headerlink\" title=\"2.xAxis和yAxis\"></a>2.xAxis和yAxis</h4><p>type为category时，需要指定data</p>\n<p>type为value时，data在series中指定</p>\n<h4 id=\"3-常见效果\"><a href=\"#3-常见效果\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>标记：最大值、最小值、平均值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">markPoint：&#123;<br>  <span class=\"hljs-attr\">data</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;max&#x27;</span>，<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最大值&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;min&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最小值&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br>  <span class=\"hljs-attr\">markLine</span>: &#123;<br>    <span class=\"hljs-attr\">data</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;average&#x27;</span>，<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;平均值&#x27;</span><br>      &#125;<br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>显示：</p>\n<p>label：数值显示</p>\n<p>barWidth： 柱宽度</p>\n<p>横向柱状图：xAxis和yAxis配置互换</p>\n</li>\n</ul>\n<h3 id=\"二、通用配置\"><a href=\"#二、通用配置\" class=\"headerlink\" title=\"二、通用配置\"></a>二、通用配置</h3><ul>\n<li>title标题<ul>\n<li>文字样式：textStyle</li>\n<li>标题边框：borderWidth、borderColor、borderRadius</li>\n<li>标题位置：left、top、right、bottom</li>\n</ul>\n</li>\n<li>tooltip提示框组件<ul>\n<li>触发类型：trigger<ul>\n<li>item</li>\n<li>axis</li>\n</ul>\n</li>\n<li>触发时机：triggerOn<ul>\n<li>mouseover</li>\n<li>click</li>\n</ul>\n</li>\n<li>格式化：formatter<ul>\n<li>字符串模板</li>\n<li>回调函数（参数：arg）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）<ul>\n<li>feature（显示工具栏按钮）<ul>\n<li>savaAsImage（导出图片）</li>\n<li>dataView（数据视图）</li>\n<li>dataZoom（数据区域缩放）</li>\n<li>restore（重置）</li>\n<li>magicType（动态类型切换）：如magicType： { type: [‘bar’, ‘line’]}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>legend图例（用于筛选系列，需要和series配合使用）<ul>\n<li>legend中的data是一个数组</li>\n<li>legend中的data的值需要和series数组中某组数据的name值一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、折线图（type为line）\"><a href=\"#三、折线图（type为line）\" class=\"headerlink\" title=\"三、折线图（type为line）\"></a>三、折线图（type为line）</h3><h4 id=\"1-数据格式-1\"><a href=\"#1-数据格式-1\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-常用效果\"><a href=\"#2-常用效果\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>标记：最大值、最小值、平均值、标注区间<ul>\n<li>markPoint</li>\n<li>markLine</li>\n<li>markArea</li>\n</ul>\n</li>\n<li>线条控制：平滑、风格<ul>\n<li>smooth、lineStyle </li>\n</ul>\n</li>\n<li>填充风格<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>紧挨y轴边缘（设置在xAxis）<ul>\n<li>boundaryGap</li>\n</ul>\n</li>\n<li>缩放：脱离0值比例<ul>\n<li>scale：true</li>\n</ul>\n</li>\n<li>堆叠图<ul>\n<li>stack：all</li>\n<li>可以和areaStyle配合使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、散点图（type为scatter）\"><a href=\"#四、散点图（type为scatter）\" class=\"headerlink\" title=\"四、散点图（type为scatter）\"></a>四、散点图（type为scatter）</h3><h4 id=\"1-数据格式-2\"><a href=\"#1-数据格式-2\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>二维数组</p>\n<h4 id=\"2-基本的散点图\"><a href=\"#2-基本的散点图\" class=\"headerlink\" title=\"2.基本的散点图\"></a>2.基本的散点图</h4><ul>\n<li>x轴和y轴type都是value</li>\n<li>x轴和y轴的数据，是一个二维数组</li>\n<li>type为scatter</li>\n</ul>\n<h4 id=\"3-常用效果\"><a href=\"#3-常用效果\" class=\"headerlink\" title=\"3.常用效果\"></a>3.常用效果</h4><ul>\n<li>气泡图效果<ul>\n<li>散点大小不同：symbolSize</li>\n<li>散点的颜色不同：itemStyle.color</li>\n</ul>\n</li>\n<li>涟漪动画效果<ul>\n<li>type: effectScatter</li>\n<li>showEffectOn: ‘emphasis’ 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）</li>\n<li>rippleEffect: { scale: 10} 散点涟漪效果的范围</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、直角坐标系的常用配置\"><a href=\"#五、直角坐标系的常用配置\" class=\"headerlink\" title=\"五、直角坐标系的常用配置\"></a>五、直角坐标系的常用配置</h3><p>直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）</p>\n<ul>\n<li>grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）<ul>\n<li>显示gird<ul>\n<li>show</li>\n</ul>\n</li>\n<li>grid的边框<ul>\n<li>borderWidth、borderColor</li>\n</ul>\n</li>\n<li>grid的位置和大小<ul>\n<li>left</li>\n<li>top</li>\n<li>right</li>\n<li>bottom</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>axis坐标轴（分为x轴和y轴）<ul>\n<li>坐标轴类型type<ul>\n<li>value：数值周，自动会从目标数据中读取数据</li>\n<li>category：类目轴，该类型必须通过data设置类目数据</li>\n</ul>\n</li>\n<li>显示位置position<ul>\n<li>xAxis：可取值为top或bottom</li>\n<li>yAxis：可取值为left或right</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>区域缩放dataZoom<ul>\n<li>dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器</li>\n<li>类型type<ul>\n<li>slider：滑块控制缩放</li>\n<li>inside：内置，依靠鼠标滚轮或者双指缩放</li>\n</ul>\n</li>\n<li>指明产生作用的轴<ul>\n<li>xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可</li>\n<li>yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可</li>\n</ul>\n</li>\n<li>指明初始状态的缩放情况<ul>\n<li>start：数据窗口范围的起始百分比</li>\n<li>end：数据窗口范围的结束百分比</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"六、饼图（type为pie）\"><a href=\"#六、饼图（type为pie）\" class=\"headerlink\" title=\"六、饼图（type为pie）\"></a>六、饼图（type为pie）</h3><h4 id=\"1-数据格式-3\"><a href=\"#1-数据格式-3\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>json数据：data: [{name: ‘京东’，value: ‘9000’}]</p>\n<h4 id=\"2-基本的饼图\"><a href=\"#2-基本的饼图\" class=\"headerlink\" title=\"2.基本的饼图\"></a>2.基本的饼图</h4><ul>\n<li>数据是json数据格式</li>\n<li>type为pie</li>\n<li>无须配置xAxis和yAxis</li>\n</ul>\n<h4 id=\"3-饼图常见效果\"><a href=\"#3-饼图常见效果\" class=\"headerlink\" title=\"3.饼图常见效果\"></a>3.饼图常见效果</h4><ul>\n<li>显示数值<ul>\n<li>lable.formatter</li>\n</ul>\n</li>\n<li>圆环<ul>\n<li>设置两个半径 radius：[‘50%’, ‘70%’] 分别是内半径和外半径</li>\n</ul>\n</li>\n<li>南丁格尔图<ul>\n<li>roseType：’radius’</li>\n</ul>\n</li>\n<li>选中效果<ul>\n<li>选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）</li>\n<li>选中偏移量 selectOffset：30</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、地图（type：map）\"><a href=\"#七、地图（type：map）\" class=\"headerlink\" title=\"七、地图（type：map）\"></a>七、地图（type：map）</h3><h4 id=\"1-矢量地图的实现步骤\"><a href=\"#1-矢量地图的实现步骤\" class=\"headerlink\" title=\"1.矢量地图的实现步骤\"></a>1.矢量地图的实现步骤</h4><ul>\n<li>Echarts最基本的代码结构<ul>\n<li>引入js文件</li>\n<li>带宽高的DOM容器</li>\n<li>init初始化对象</li>\n<li>setOption设置option</li>\n</ul>\n</li>\n<li>准备中国的矢量地图json文件（<a href=\"http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5%EF%BC%89\">http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5）</a></li>\n<li>使用ajax获取json<ul>\n<li>$.get(‘json/map/china.json’, function(chinaJson){})</li>\n</ul>\n</li>\n<li>往echarts全局对象注册地图的json数据<ul>\n<li>echarts.registerMap(‘chinaMap’, chinaJson)</li>\n</ul>\n</li>\n<li>在geo下设置<ul>\n<li>type:’map’</li>\n<li>map:’chinaMap’</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置\"><a href=\"#2-常用配置\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>缩放拖动<ul>\n<li>roam：true</li>\n</ul>\n</li>\n<li>名称显示<ul>\n<li>label</li>\n</ul>\n</li>\n<li>初始缩放比例<ul>\n<li>zoom：2（2倍）</li>\n</ul>\n</li>\n<li>地图中心点<ul>\n<li>center</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-常见效果-1\"><a href=\"#3-常见效果-1\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>不同城市颜色不同（如空气质量）</p>\n<ol>\n<li><p>显示基本的中国地图</p>\n</li>\n<li><p>城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ‘’}]的格式，其中name属性必须和省份名一致）</p>\n</li>\n<li><p>将series下的数据与geo关联起来</p>\n<p>设置type: ‘map’，geoIndex:0</p>\n</li>\n<li><p>结合visualMap配合使用</p>\n<p>visualMap: {min: 0, max: 40, range: { color: [‘white’, ‘red’]}}</p>\n</li>\n</ol>\n</li>\n<li><p>地图和散点图结合</p>\n<ol>\n<li><p>给series下配置散点图对象</p>\n</li>\n<li><p>准备好散点数据，设置给新对象的data（二维数组，地图坐标）</p>\n</li>\n<li><p>配置新对象的type为effectScatter</p>\n</li>\n<li><p>让散点图使用地图坐标系统</p>\n<p>coordinateSystem: ‘geo’</p>\n</li>\n<li><p>让涟漪的效果更加明显</p>\n<p>rippleEffect：{ scale：10 }</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"八、雷达图（type：radar）\"><a href=\"#八、雷达图（type：radar）\" class=\"headerlink\" title=\"八、雷达图（type：radar）\"></a>八、雷达图（type：radar）</h3><h4 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>定义各个维度的最大值（在radar属性下）<ul>\n<li>indicator：[{name: ‘易用性’, max: 100]}]</li>\n</ul>\n</li>\n<li>准备具体产品的数据<ul>\n<li>在series下设置data：[{name: ‘华为手机’, value: [80, 80, 90, 95, 85]}</li>\n</ul>\n</li>\n<li>设置图表类型<ul>\n<li>在series下设置type：radar</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置-1\"><a href=\"#2-常用配置-1\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>显示数值:<ul>\n<li>label</li>\n</ul>\n</li>\n<li>区域面积（阴影）<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>绘制类型<ul>\n<li>shape: ‘circle’ 默认值 polygon</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"九、仪表盘（type：guage）\"><a href=\"#九、仪表盘（type：guage）\" class=\"headerlink\" title=\"九、仪表盘（type：guage）\"></a>九、仪表盘（type：guage）</h3><h4 id=\"1-实现步骤-1\"><a href=\"#1-实现步骤-1\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>准备数据，设置给series下的data<ul>\n<li>data: [{value: 97}]</li>\n</ul>\n</li>\n<li>图标类型<ul>\n<li>在series下设置type：guage</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用效果-1\"><a href=\"#2-常用效果-1\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>数值范围<ul>\n<li>max</li>\n<li>min</li>\n</ul>\n</li>\n<li>多个指针<ul>\n<li>增加series下data数组中的元素</li>\n</ul>\n</li>\n<li>多个指针颜色差异<ul>\n<li>itemStyle</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十、主题\"><a href=\"#十、主题\" class=\"headerlink\" title=\"十、主题\"></a>十、主题</h3><h4 id=\"1-内置主题\"><a href=\"#1-内置主题\" class=\"headerlink\" title=\"1.内置主题\"></a>1.内置主题</h4><ul>\n<li><p>echarts中默认内置了两套主题：light、dark</p>\n</li>\n<li><p>在初始化对象方法中init中可以指明</p>\n<p>var chart = echarts.init(dom, ‘light’)</p>\n<p>var chart = echarts.init(dom, ‘dark’)</p>\n</li>\n</ul>\n<h4 id=\"2-自定义主题\"><a href=\"#2-自定义主题\" class=\"headerlink\" title=\"2.自定义主题\"></a>2.自定义主题</h4><ul>\n<li>1.在官网主题编辑器中编辑主题</li>\n<li>2.下载主题js文件</li>\n<li>3.引入主题js文件</li>\n<li>4.在init方法中使用主题</li>\n</ul>\n<h3 id=\"十一、调色盘\"><a href=\"#十一、调色盘\" class=\"headerlink\" title=\"十一、调色盘\"></a>十一、调色盘</h3><h4 id=\"1-它是一组颜色，图形、系列会自动从其中选择颜色\"><a href=\"#1-它是一组颜色，图形、系列会自动从其中选择颜色\" class=\"headerlink\" title=\"1.它是一组颜色，图形、系列会自动从其中选择颜色\"></a>1.它是一组颜色，图形、系列会自动从其中选择颜色</h4><ul>\n<li><p>主题调色盘（主题js文件中全局注册的color）</p>\n</li>\n<li><p>全局调色盘</p>\n<p>options：{</p>\n<p>​    color： [‘red’, ‘green’, ‘blue’]</p>\n<p>}</p>\n</li>\n<li><p>局部调色盘</p>\n<p>series: [{</p>\n<p>​    type: ‘bar’,</p>\n<p>​    color: [‘red’, ‘green’, ‘blue’]</p>\n<p>}]</p>\n</li>\n</ul>\n<h4 id=\"2-调色盘的作用遵循就近原则\"><a href=\"#2-调色盘的作用遵循就近原则\" class=\"headerlink\" title=\"2.调色盘的作用遵循就近原则\"></a>2.调色盘的作用遵循就近原则</h4><h4 id=\"3-颜色渐变\"><a href=\"#3-颜色渐变\" class=\"headerlink\" title=\"3.颜色渐变\"></a>3.颜色渐变</h4><ul>\n<li><p>线性渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;linear&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始x位置</span><br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始y位置</span><br>      <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 1代表到底部，0.5在中间</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> <span class=\"hljs-comment\">// 0%处的颜色 </span><br>        &#125;,&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span> <span class=\"hljs-comment\">// 100%处的颜色</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>径向渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;radial&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.5</span>, <br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.5</span>,<br>      <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-comment\">// 扩散的半径</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span><br>        &#125;, &#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"十二、样式\"><a href=\"#十二、样式\" class=\"headerlink\" title=\"十二、样式\"></a>十二、样式</h3><ul>\n<li>直接样式<ul>\n<li>itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>高亮样式<ul>\n<li>在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>优先级高，会覆盖主题中、调色盘的效果</li>\n</ul>\n<h3 id=\"十三、自适应\"><a href=\"#十三、自适应\" class=\"headerlink\" title=\"十三、自适应\"></a>十三、自适应</h3><p>当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化</p>\n<ul>\n<li><p>1.监听窗口大小变化事件</p>\n</li>\n<li><p>2.在事件处理函数中调用echarts实例对象的resize方法即可</p>\n<p>window.onresize = myChart.resize</p>\n</li>\n</ul>\n<h3 id=\"十四、加载动画\"><a href=\"#十四、加载动画\" class=\"headerlink\" title=\"十四、加载动画\"></a>十四、加载动画</h3><p>echarts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可</p>\n<ul>\n<li><p>显示加载动画</p>\n<p>mCharts.showLoading()</p>\n</li>\n<li><p>隐藏加载动画</p>\n<p>mCharts.hideLoading()</p>\n</li>\n</ul>\n<h3 id=\"十五、增量动画\"><a href=\"#十五、增量动画\" class=\"headerlink\" title=\"十五、增量动画\"></a>十五、增量动画</h3><ul>\n<li>增量动画的实现方式<ul>\n<li>mCharts.setOption<ul>\n<li>所有数据的更新都通过setOption实现</li>\n<li>不用考虑数据到底产生了哪些变化</li>\n<li>echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化</li>\n<li>新旧option的关系并不是相互覆盖的关系，而是相互整合的关系</li>\n<li>我们在设置新的option的时候，只需要考虑到变化的部分就可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十六、动画配置项\"><a href=\"#十六、动画配置项\" class=\"headerlink\" title=\"十六、动画配置项\"></a>十六、动画配置项</h3><ul>\n<li><p>开启动画</p>\n<ul>\n<li>animation：true</li>\n</ul>\n</li>\n<li><p>动画时长</p>\n<ul>\n<li>animationDuration：5000</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">animationDuration： <span class=\"hljs-keyword\">function</span>（arg） &#123;<br>  <span class=\"hljs-comment\">// 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组</span><br>  <span class=\"hljs-keyword\">return</span> arg * <span class=\"hljs-number\">10</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>缓动动画</p>\n<ul>\n<li>animationEasing: ‘bounceOut’</li>\n</ul>\n</li>\n<li><p>动画阈值</p>\n<ul>\n<li>animationThreshold： 8</li>\n<li>单中形式的元素数量大于这个阈值会关闭动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十七、全局Echarts对象常用方法\"><a href=\"#十七、全局Echarts对象常用方法\" class=\"headerlink\" title=\"十七、全局Echarts对象常用方法\"></a>十七、全局Echarts对象常用方法</h3><ul>\n<li><p>init方法</p>\n<ul>\n<li>初始化Echarts实例对象</li>\n<li>使用主题（第二个参数）</li>\n</ul>\n</li>\n<li><p>registerTheme方法</p>\n<ul>\n<li>注册主题</li>\n<li>只有注册过的主题，才能在init方法中使用该主题</li>\n</ul>\n</li>\n<li><p>registerMap方法</p>\n<ul>\n<li><p>注册地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;json/map/china.json&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ChinaJson</span>) &#123;<br>  echarts.<span class=\"hljs-title function_\">registerMap</span>(<span class=\"hljs-string\">&#x27;china&#x27;</span>, chinaJson)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>geo组件使用地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> option = &#123;<br>  <span class=\"hljs-attr\">geo</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;map&#x27;</span>,<br>    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-string\">&#x27;china&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>connect方法</p>\n<ul>\n<li>一个页面中可以有多个独立的图表</li>\n<li>每一个图表对应一个Echarts实例对象</li>\n<li>connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组<ul>\n<li>保存图片的自动拼接（saveAsImage）</li>\n<li>刷新按钮</li>\n<li>重置按钮</li>\n<li>提示框联动、图例选择、数据范围修改等等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十八、echartsInstance实例常用方法\"><a href=\"#十八、echartsInstance实例常用方法\" class=\"headerlink\" title=\"十八、echartsInstance实例常用方法\"></a>十八、echartsInstance实例常用方法</h3><ul>\n<li><p>setOption方法</p>\n<ul>\n<li>设置或修改图表实例的配置项以及数据</li>\n<li>多次调用setOption方法<ul>\n<li>合并新旧配置</li>\n<li>增量动画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>resize方法</p>\n<ul>\n<li>重新计算和绘制图表</li>\n<li>一般和window对象的resize事件结合使用<ul>\n<li>window.onresize = mEcharts.resize</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>on\\off方法</p>\n<ul>\n<li>绑定或者解绑事件处理函数</li>\n<li>鼠标事件<ul>\n<li>常见事件：click、dbclick、mousedown、mousemove、mouseup等</li>\n</ul>\n</li>\n<li>Echarts事件<ul>\n<li>常见事件：legendselectchanged、datazoom、pieselectchanged、ma’pselectchanged</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>dispatchAction</p>\n<ul>\n<li><p>触发某些行为</p>\n</li>\n<li><p>使用代码模拟用户的行为</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">mCharts.<span class=\"hljs-title function_\">dispatchAction</span>(&#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;hightlight&#x27;</span>, <span class=\"hljs-comment\">// 事件类型</span><br>  <span class=\"hljs-attr\">seriesIndex</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 图表索引(系列)</span><br>  <span class=\"hljs-attr\">dataIndex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 图表中哪一项高亮</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>clear</p>\n<ul>\n<li>清空当前实例，会移除实例中所有的组件和图表</li>\n<li>清空之后可以再次setOption</li>\n</ul>\n</li>\n<li><p>dispose方法</p>\n<ul>\n<li>销毁实例</li>\n<li>销毁后实例无法再被使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十九、websocket的基本使用\"><a href=\"#十九、websocket的基本使用\" class=\"headerlink\" title=\"十九、websocket的基本使用\"></a>十九、websocket的基本使用</h3><ul>\n<li><p>后端</p>\n<ul>\n<li><p>安装包</p>\n<ul>\n<li>npm i ws</li>\n</ul>\n</li>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> webSocket = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ws&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>.<span class=\"hljs-title function_\">server</span>(&#123;<br>  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;8080&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li><p>连接事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>接受数据事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>  client.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">msg</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;客户端发送数据过来了&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>发送数据</p>\n<ul>\n<li>client.send(‘hello socket from back-end’)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端</p>\n<ul>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8080&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li>连接成功事件<ul>\n<li>ws.onopen = () =&gt; {}</li>\n</ul>\n</li>\n<li>接受数据事件<ul>\n<li>ws.onmessage = msg =&gt; {}</li>\n</ul>\n</li>\n<li>关闭连接事件<ul>\n<li>ws.onclose = () =&gt; {}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送数据</p>\n<ul>\n<li>ws.send</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":6380,"excerpt":"","more":"<h3 id=\"一、柱状图（type为bar）\"><a href=\"#一、柱状图（type为bar）\" class=\"headerlink\" title=\"一、柱状图（type为bar）\"></a>一、柱状图（type为bar）</h3><h4 id=\"1-数据格式\"><a href=\"#1-数据格式\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-xAxis和yAxis\"><a href=\"#2-xAxis和yAxis\" class=\"headerlink\" title=\"2.xAxis和yAxis\"></a>2.xAxis和yAxis</h4><p>type为category时，需要指定data</p>\n<p>type为value时，data在series中指定</p>\n<h4 id=\"3-常见效果\"><a href=\"#3-常见效果\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>标记：最大值、最小值、平均值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">markPoint：&#123;<br>  <span class=\"hljs-attr\">data</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;max&#x27;</span>，<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最大值&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;min&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最小值&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br>  <span class=\"hljs-attr\">markLine</span>: &#123;<br>    <span class=\"hljs-attr\">data</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;average&#x27;</span>，<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;平均值&#x27;</span><br>      &#125;<br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>显示：</p>\n<p>label：数值显示</p>\n<p>barWidth： 柱宽度</p>\n<p>横向柱状图：xAxis和yAxis配置互换</p>\n</li>\n</ul>\n<h3 id=\"二、通用配置\"><a href=\"#二、通用配置\" class=\"headerlink\" title=\"二、通用配置\"></a>二、通用配置</h3><ul>\n<li>title标题<ul>\n<li>文字样式：textStyle</li>\n<li>标题边框：borderWidth、borderColor、borderRadius</li>\n<li>标题位置：left、top、right、bottom</li>\n</ul>\n</li>\n<li>tooltip提示框组件<ul>\n<li>触发类型：trigger<ul>\n<li>item</li>\n<li>axis</li>\n</ul>\n</li>\n<li>触发时机：triggerOn<ul>\n<li>mouseover</li>\n<li>click</li>\n</ul>\n</li>\n<li>格式化：formatter<ul>\n<li>字符串模板</li>\n<li>回调函数（参数：arg）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）<ul>\n<li>feature（显示工具栏按钮）<ul>\n<li>savaAsImage（导出图片）</li>\n<li>dataView（数据视图）</li>\n<li>dataZoom（数据区域缩放）</li>\n<li>restore（重置）</li>\n<li>magicType（动态类型切换）：如magicType： { type: [‘bar’, ‘line’]}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>legend图例（用于筛选系列，需要和series配合使用）<ul>\n<li>legend中的data是一个数组</li>\n<li>legend中的data的值需要和series数组中某组数据的name值一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、折线图（type为line）\"><a href=\"#三、折线图（type为line）\" class=\"headerlink\" title=\"三、折线图（type为line）\"></a>三、折线图（type为line）</h3><h4 id=\"1-数据格式-1\"><a href=\"#1-数据格式-1\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-常用效果\"><a href=\"#2-常用效果\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>标记：最大值、最小值、平均值、标注区间<ul>\n<li>markPoint</li>\n<li>markLine</li>\n<li>markArea</li>\n</ul>\n</li>\n<li>线条控制：平滑、风格<ul>\n<li>smooth、lineStyle </li>\n</ul>\n</li>\n<li>填充风格<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>紧挨y轴边缘（设置在xAxis）<ul>\n<li>boundaryGap</li>\n</ul>\n</li>\n<li>缩放：脱离0值比例<ul>\n<li>scale：true</li>\n</ul>\n</li>\n<li>堆叠图<ul>\n<li>stack：all</li>\n<li>可以和areaStyle配合使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、散点图（type为scatter）\"><a href=\"#四、散点图（type为scatter）\" class=\"headerlink\" title=\"四、散点图（type为scatter）\"></a>四、散点图（type为scatter）</h3><h4 id=\"1-数据格式-2\"><a href=\"#1-数据格式-2\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>二维数组</p>\n<h4 id=\"2-基本的散点图\"><a href=\"#2-基本的散点图\" class=\"headerlink\" title=\"2.基本的散点图\"></a>2.基本的散点图</h4><ul>\n<li>x轴和y轴type都是value</li>\n<li>x轴和y轴的数据，是一个二维数组</li>\n<li>type为scatter</li>\n</ul>\n<h4 id=\"3-常用效果\"><a href=\"#3-常用效果\" class=\"headerlink\" title=\"3.常用效果\"></a>3.常用效果</h4><ul>\n<li>气泡图效果<ul>\n<li>散点大小不同：symbolSize</li>\n<li>散点的颜色不同：itemStyle.color</li>\n</ul>\n</li>\n<li>涟漪动画效果<ul>\n<li>type: effectScatter</li>\n<li>showEffectOn: ‘emphasis’ 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）</li>\n<li>rippleEffect: { scale: 10} 散点涟漪效果的范围</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、直角坐标系的常用配置\"><a href=\"#五、直角坐标系的常用配置\" class=\"headerlink\" title=\"五、直角坐标系的常用配置\"></a>五、直角坐标系的常用配置</h3><p>直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）</p>\n<ul>\n<li>grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）<ul>\n<li>显示gird<ul>\n<li>show</li>\n</ul>\n</li>\n<li>grid的边框<ul>\n<li>borderWidth、borderColor</li>\n</ul>\n</li>\n<li>grid的位置和大小<ul>\n<li>left</li>\n<li>top</li>\n<li>right</li>\n<li>bottom</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>axis坐标轴（分为x轴和y轴）<ul>\n<li>坐标轴类型type<ul>\n<li>value：数值周，自动会从目标数据中读取数据</li>\n<li>category：类目轴，该类型必须通过data设置类目数据</li>\n</ul>\n</li>\n<li>显示位置position<ul>\n<li>xAxis：可取值为top或bottom</li>\n<li>yAxis：可取值为left或right</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>区域缩放dataZoom<ul>\n<li>dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器</li>\n<li>类型type<ul>\n<li>slider：滑块控制缩放</li>\n<li>inside：内置，依靠鼠标滚轮或者双指缩放</li>\n</ul>\n</li>\n<li>指明产生作用的轴<ul>\n<li>xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可</li>\n<li>yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可</li>\n</ul>\n</li>\n<li>指明初始状态的缩放情况<ul>\n<li>start：数据窗口范围的起始百分比</li>\n<li>end：数据窗口范围的结束百分比</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"六、饼图（type为pie）\"><a href=\"#六、饼图（type为pie）\" class=\"headerlink\" title=\"六、饼图（type为pie）\"></a>六、饼图（type为pie）</h3><h4 id=\"1-数据格式-3\"><a href=\"#1-数据格式-3\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>json数据：data: [{name: ‘京东’，value: ‘9000’}]</p>\n<h4 id=\"2-基本的饼图\"><a href=\"#2-基本的饼图\" class=\"headerlink\" title=\"2.基本的饼图\"></a>2.基本的饼图</h4><ul>\n<li>数据是json数据格式</li>\n<li>type为pie</li>\n<li>无须配置xAxis和yAxis</li>\n</ul>\n<h4 id=\"3-饼图常见效果\"><a href=\"#3-饼图常见效果\" class=\"headerlink\" title=\"3.饼图常见效果\"></a>3.饼图常见效果</h4><ul>\n<li>显示数值<ul>\n<li>lable.formatter</li>\n</ul>\n</li>\n<li>圆环<ul>\n<li>设置两个半径 radius：[‘50%’, ‘70%’] 分别是内半径和外半径</li>\n</ul>\n</li>\n<li>南丁格尔图<ul>\n<li>roseType：’radius’</li>\n</ul>\n</li>\n<li>选中效果<ul>\n<li>选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）</li>\n<li>选中偏移量 selectOffset：30</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、地图（type：map）\"><a href=\"#七、地图（type：map）\" class=\"headerlink\" title=\"七、地图（type：map）\"></a>七、地图（type：map）</h3><h4 id=\"1-矢量地图的实现步骤\"><a href=\"#1-矢量地图的实现步骤\" class=\"headerlink\" title=\"1.矢量地图的实现步骤\"></a>1.矢量地图的实现步骤</h4><ul>\n<li>Echarts最基本的代码结构<ul>\n<li>引入js文件</li>\n<li>带宽高的DOM容器</li>\n<li>init初始化对象</li>\n<li>setOption设置option</li>\n</ul>\n</li>\n<li>准备中国的矢量地图json文件（<a href=\"http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5%EF%BC%89\">http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5）</a></li>\n<li>使用ajax获取json<ul>\n<li>$.get(‘json/map/china.json’, function(chinaJson){})</li>\n</ul>\n</li>\n<li>往echarts全局对象注册地图的json数据<ul>\n<li>echarts.registerMap(‘chinaMap’, chinaJson)</li>\n</ul>\n</li>\n<li>在geo下设置<ul>\n<li>type:’map’</li>\n<li>map:’chinaMap’</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置\"><a href=\"#2-常用配置\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>缩放拖动<ul>\n<li>roam：true</li>\n</ul>\n</li>\n<li>名称显示<ul>\n<li>label</li>\n</ul>\n</li>\n<li>初始缩放比例<ul>\n<li>zoom：2（2倍）</li>\n</ul>\n</li>\n<li>地图中心点<ul>\n<li>center</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-常见效果-1\"><a href=\"#3-常见效果-1\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>不同城市颜色不同（如空气质量）</p>\n<ol>\n<li><p>显示基本的中国地图</p>\n</li>\n<li><p>城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ‘’}]的格式，其中name属性必须和省份名一致）</p>\n</li>\n<li><p>将series下的数据与geo关联起来</p>\n<p>设置type: ‘map’，geoIndex:0</p>\n</li>\n<li><p>结合visualMap配合使用</p>\n<p>visualMap: {min: 0, max: 40, range: { color: [‘white’, ‘red’]}}</p>\n</li>\n</ol>\n</li>\n<li><p>地图和散点图结合</p>\n<ol>\n<li><p>给series下配置散点图对象</p>\n</li>\n<li><p>准备好散点数据，设置给新对象的data（二维数组，地图坐标）</p>\n</li>\n<li><p>配置新对象的type为effectScatter</p>\n</li>\n<li><p>让散点图使用地图坐标系统</p>\n<p>coordinateSystem: ‘geo’</p>\n</li>\n<li><p>让涟漪的效果更加明显</p>\n<p>rippleEffect：{ scale：10 }</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"八、雷达图（type：radar）\"><a href=\"#八、雷达图（type：radar）\" class=\"headerlink\" title=\"八、雷达图（type：radar）\"></a>八、雷达图（type：radar）</h3><h4 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>定义各个维度的最大值（在radar属性下）<ul>\n<li>indicator：[{name: ‘易用性’, max: 100]}]</li>\n</ul>\n</li>\n<li>准备具体产品的数据<ul>\n<li>在series下设置data：[{name: ‘华为手机’, value: [80, 80, 90, 95, 85]}</li>\n</ul>\n</li>\n<li>设置图表类型<ul>\n<li>在series下设置type：radar</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置-1\"><a href=\"#2-常用配置-1\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>显示数值:<ul>\n<li>label</li>\n</ul>\n</li>\n<li>区域面积（阴影）<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>绘制类型<ul>\n<li>shape: ‘circle’ 默认值 polygon</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"九、仪表盘（type：guage）\"><a href=\"#九、仪表盘（type：guage）\" class=\"headerlink\" title=\"九、仪表盘（type：guage）\"></a>九、仪表盘（type：guage）</h3><h4 id=\"1-实现步骤-1\"><a href=\"#1-实现步骤-1\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>准备数据，设置给series下的data<ul>\n<li>data: [{value: 97}]</li>\n</ul>\n</li>\n<li>图标类型<ul>\n<li>在series下设置type：guage</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用效果-1\"><a href=\"#2-常用效果-1\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>数值范围<ul>\n<li>max</li>\n<li>min</li>\n</ul>\n</li>\n<li>多个指针<ul>\n<li>增加series下data数组中的元素</li>\n</ul>\n</li>\n<li>多个指针颜色差异<ul>\n<li>itemStyle</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十、主题\"><a href=\"#十、主题\" class=\"headerlink\" title=\"十、主题\"></a>十、主题</h3><h4 id=\"1-内置主题\"><a href=\"#1-内置主题\" class=\"headerlink\" title=\"1.内置主题\"></a>1.内置主题</h4><ul>\n<li><p>echarts中默认内置了两套主题：light、dark</p>\n</li>\n<li><p>在初始化对象方法中init中可以指明</p>\n<p>var chart = echarts.init(dom, ‘light’)</p>\n<p>var chart = echarts.init(dom, ‘dark’)</p>\n</li>\n</ul>\n<h4 id=\"2-自定义主题\"><a href=\"#2-自定义主题\" class=\"headerlink\" title=\"2.自定义主题\"></a>2.自定义主题</h4><ul>\n<li>1.在官网主题编辑器中编辑主题</li>\n<li>2.下载主题js文件</li>\n<li>3.引入主题js文件</li>\n<li>4.在init方法中使用主题</li>\n</ul>\n<h3 id=\"十一、调色盘\"><a href=\"#十一、调色盘\" class=\"headerlink\" title=\"十一、调色盘\"></a>十一、调色盘</h3><h4 id=\"1-它是一组颜色，图形、系列会自动从其中选择颜色\"><a href=\"#1-它是一组颜色，图形、系列会自动从其中选择颜色\" class=\"headerlink\" title=\"1.它是一组颜色，图形、系列会自动从其中选择颜色\"></a>1.它是一组颜色，图形、系列会自动从其中选择颜色</h4><ul>\n<li><p>主题调色盘（主题js文件中全局注册的color）</p>\n</li>\n<li><p>全局调色盘</p>\n<p>options：{</p>\n<p>​    color： [‘red’, ‘green’, ‘blue’]</p>\n<p>}</p>\n</li>\n<li><p>局部调色盘</p>\n<p>series: [{</p>\n<p>​    type: ‘bar’,</p>\n<p>​    color: [‘red’, ‘green’, ‘blue’]</p>\n<p>}]</p>\n</li>\n</ul>\n<h4 id=\"2-调色盘的作用遵循就近原则\"><a href=\"#2-调色盘的作用遵循就近原则\" class=\"headerlink\" title=\"2.调色盘的作用遵循就近原则\"></a>2.调色盘的作用遵循就近原则</h4><h4 id=\"3-颜色渐变\"><a href=\"#3-颜色渐变\" class=\"headerlink\" title=\"3.颜色渐变\"></a>3.颜色渐变</h4><ul>\n<li><p>线性渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;linear&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始x位置</span><br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始y位置</span><br>      <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 1代表到底部，0.5在中间</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> <span class=\"hljs-comment\">// 0%处的颜色 </span><br>        &#125;,&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span> <span class=\"hljs-comment\">// 100%处的颜色</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>径向渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;radial&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.5</span>, <br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.5</span>,<br>      <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-comment\">// 扩散的半径</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span><br>        &#125;, &#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"十二、样式\"><a href=\"#十二、样式\" class=\"headerlink\" title=\"十二、样式\"></a>十二、样式</h3><ul>\n<li>直接样式<ul>\n<li>itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>高亮样式<ul>\n<li>在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>优先级高，会覆盖主题中、调色盘的效果</li>\n</ul>\n<h3 id=\"十三、自适应\"><a href=\"#十三、自适应\" class=\"headerlink\" title=\"十三、自适应\"></a>十三、自适应</h3><p>当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化</p>\n<ul>\n<li><p>1.监听窗口大小变化事件</p>\n</li>\n<li><p>2.在事件处理函数中调用echarts实例对象的resize方法即可</p>\n<p>window.onresize = myChart.resize</p>\n</li>\n</ul>\n<h3 id=\"十四、加载动画\"><a href=\"#十四、加载动画\" class=\"headerlink\" title=\"十四、加载动画\"></a>十四、加载动画</h3><p>echarts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可</p>\n<ul>\n<li><p>显示加载动画</p>\n<p>mCharts.showLoading()</p>\n</li>\n<li><p>隐藏加载动画</p>\n<p>mCharts.hideLoading()</p>\n</li>\n</ul>\n<h3 id=\"十五、增量动画\"><a href=\"#十五、增量动画\" class=\"headerlink\" title=\"十五、增量动画\"></a>十五、增量动画</h3><ul>\n<li>增量动画的实现方式<ul>\n<li>mCharts.setOption<ul>\n<li>所有数据的更新都通过setOption实现</li>\n<li>不用考虑数据到底产生了哪些变化</li>\n<li>echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化</li>\n<li>新旧option的关系并不是相互覆盖的关系，而是相互整合的关系</li>\n<li>我们在设置新的option的时候，只需要考虑到变化的部分就可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十六、动画配置项\"><a href=\"#十六、动画配置项\" class=\"headerlink\" title=\"十六、动画配置项\"></a>十六、动画配置项</h3><ul>\n<li><p>开启动画</p>\n<ul>\n<li>animation：true</li>\n</ul>\n</li>\n<li><p>动画时长</p>\n<ul>\n<li>animationDuration：5000</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">animationDuration： <span class=\"hljs-keyword\">function</span>（arg） &#123;<br>  <span class=\"hljs-comment\">// 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组</span><br>  <span class=\"hljs-keyword\">return</span> arg * <span class=\"hljs-number\">10</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>缓动动画</p>\n<ul>\n<li>animationEasing: ‘bounceOut’</li>\n</ul>\n</li>\n<li><p>动画阈值</p>\n<ul>\n<li>animationThreshold： 8</li>\n<li>单中形式的元素数量大于这个阈值会关闭动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十七、全局Echarts对象常用方法\"><a href=\"#十七、全局Echarts对象常用方法\" class=\"headerlink\" title=\"十七、全局Echarts对象常用方法\"></a>十七、全局Echarts对象常用方法</h3><ul>\n<li><p>init方法</p>\n<ul>\n<li>初始化Echarts实例对象</li>\n<li>使用主题（第二个参数）</li>\n</ul>\n</li>\n<li><p>registerTheme方法</p>\n<ul>\n<li>注册主题</li>\n<li>只有注册过的主题，才能在init方法中使用该主题</li>\n</ul>\n</li>\n<li><p>registerMap方法</p>\n<ul>\n<li><p>注册地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;json/map/china.json&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ChinaJson</span>) &#123;<br>  echarts.<span class=\"hljs-title function_\">registerMap</span>(<span class=\"hljs-string\">&#x27;china&#x27;</span>, chinaJson)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>geo组件使用地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> option = &#123;<br>  <span class=\"hljs-attr\">geo</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;map&#x27;</span>,<br>    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-string\">&#x27;china&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>connect方法</p>\n<ul>\n<li>一个页面中可以有多个独立的图表</li>\n<li>每一个图表对应一个Echarts实例对象</li>\n<li>connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组<ul>\n<li>保存图片的自动拼接（saveAsImage）</li>\n<li>刷新按钮</li>\n<li>重置按钮</li>\n<li>提示框联动、图例选择、数据范围修改等等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十八、echartsInstance实例常用方法\"><a href=\"#十八、echartsInstance实例常用方法\" class=\"headerlink\" title=\"十八、echartsInstance实例常用方法\"></a>十八、echartsInstance实例常用方法</h3><ul>\n<li><p>setOption方法</p>\n<ul>\n<li>设置或修改图表实例的配置项以及数据</li>\n<li>多次调用setOption方法<ul>\n<li>合并新旧配置</li>\n<li>增量动画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>resize方法</p>\n<ul>\n<li>重新计算和绘制图表</li>\n<li>一般和window对象的resize事件结合使用<ul>\n<li>window.onresize = mEcharts.resize</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>on\\off方法</p>\n<ul>\n<li>绑定或者解绑事件处理函数</li>\n<li>鼠标事件<ul>\n<li>常见事件：click、dbclick、mousedown、mousemove、mouseup等</li>\n</ul>\n</li>\n<li>Echarts事件<ul>\n<li>常见事件：legendselectchanged、datazoom、pieselectchanged、ma’pselectchanged</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>dispatchAction</p>\n<ul>\n<li><p>触发某些行为</p>\n</li>\n<li><p>使用代码模拟用户的行为</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">mCharts.<span class=\"hljs-title function_\">dispatchAction</span>(&#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;hightlight&#x27;</span>, <span class=\"hljs-comment\">// 事件类型</span><br>  <span class=\"hljs-attr\">seriesIndex</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 图表索引(系列)</span><br>  <span class=\"hljs-attr\">dataIndex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 图表中哪一项高亮</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>clear</p>\n<ul>\n<li>清空当前实例，会移除实例中所有的组件和图表</li>\n<li>清空之后可以再次setOption</li>\n</ul>\n</li>\n<li><p>dispose方法</p>\n<ul>\n<li>销毁实例</li>\n<li>销毁后实例无法再被使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十九、websocket的基本使用\"><a href=\"#十九、websocket的基本使用\" class=\"headerlink\" title=\"十九、websocket的基本使用\"></a>十九、websocket的基本使用</h3><ul>\n<li><p>后端</p>\n<ul>\n<li><p>安装包</p>\n<ul>\n<li>npm i ws</li>\n</ul>\n</li>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> webSocket = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ws&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>.<span class=\"hljs-title function_\">server</span>(&#123;<br>  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;8080&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li><p>连接事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>接受数据事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>  client.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">msg</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;客户端发送数据过来了&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>发送数据</p>\n<ul>\n<li>client.send(‘hello socket from back-end’)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端</p>\n<ul>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8080&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li>连接成功事件<ul>\n<li>ws.onopen = () =&gt; {}</li>\n</ul>\n</li>\n<li>接受数据事件<ul>\n<li>ws.onmessage = msg =&gt; {}</li>\n</ul>\n</li>\n<li>关闭连接事件<ul>\n<li>ws.onclose = () =&gt; {}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送数据</p>\n<ul>\n<li>ws.send</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"搭建jenkins服务器环境","keywords":"jenkins","_content":"\n## 一. 购买云服务器\n\n这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买\n\n## 二. 搭建服务器环境\n\n### 2.1. jenkins自动化部署\n\n#### 2.1.1. 安装Java环境\n\nJenkins本身是依赖Java的，所以我们需要先安装Java环境：\n\n* 这里我安装了Java1.8的环境\n\n```shell\ndnf search java-1.8\ndnf install java-1.8.0-openjdk.x86_64\n```\n\n\n\n#### 2.1.2. 安装Jenkins\n\n因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：\n\n* wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；\n* rpm：全称为**The RPM Package Manage**，是Linux下一个软件包管理器；\n\n```shell\nwget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo\n\n# 导入GPG密钥以确保您的软件合法\nrpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n# 或者\nrpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n```\n\n编辑一下文件/etc/yum.repos.d/jenkins.repo\n\n* 可以通过vim编辑\n\n```\n[jenkins]\n\nname=Jenkins-stable\n\nbaseurl=http://pkg.jenkins.io/redhat\n\ngpgcheck=1\n```\n\n安装Jenkins\n\n```shell\ndnf install jenkins # --nogpgcheck(可以不加)\n```\n\n启动Jenkins的服务：\n\n```shell\nsystemctl start jenkins\nsystemctl status jenkins\nsystemctl enable jenkins\n```\n\nJenkins默认使用8080端口提供服务，所以需要加入到安全组中：\n\n![image-20201204173117359](https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg)\n\n\n\n\n\n#### 2.1.3. Jenkins用户\n\n我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 `jenkins`，可能会没有访问权限，所以我们需要修改一下它的用户：\n\n修改文件的路径：`/etc/sysconfig/jenkins`\n\n![image-20210825162827962](https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg)\n\n之后需要重启一下Jenkins：\n\n```shell\nsystemctl restart jenkins\n```\n\n\n\n#### 2.1.4. Jenkins配置\n\n打开浏览器，输入：http://8.134.60.235:8080/\n\n* 注意：你输入自己的IP地址\n\n获取输入管理员密码：\n\n* 在下面的地址中 `cat /var/lib/jenkins/secrets/initialAdminPassword`\n\n![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)\n\n可以安装推荐的插件：\n\n![安装推荐的插件](https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg)\n\n\n\n#### 2.1.5. Jenkins任务\n\n**新建任务：**\n\n![新建任务](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg)\n\n![image-20201204185613061](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg)\n\n**配置项目和保留策略：**\n\n![image-20210825160744119](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg)\n\n**源码管理：**\n\n![image-20210825160818122](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg)\n\n**构建触发器：**\n\n这里的触发器规则是这样的：\n\n* 定时字符串从左往右分别是：分 时 日 月 周\n\n```js\n#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建\nH/30 * * * *\n\n#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建\nH H/2 * * *\n\n#每天凌晨两点定时构建\nH 2 * * *\n\n#每月15号执行构建\nH H 15 * *\n\n#工作日，上午9点整执行\nH 9 * * 1-5\n\n#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次\nH/30 8-20/4 * * 1,3,5\n```\n\n\n\n![触发器](https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg)\n\n**构建环境：**\n\n注意：我们需要搭建Node的环境\n\n* 第一步：配置Node的环境；\n* 第二步：安装Node的插件；\n\n![image-20201204190055096](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg)\n\n第一步：配置Node的环境\n\n![node环境](https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg)\n\n第二步：安装Node的插件\n\n* 这里因为我已经安装过了，所以没有搜索到；\n\n![image-20201204185949452](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg)\n\n\n\n构建执行的任务：\n\n* 查看Node的版本等是否有问题；\n* 执行 `npm install` 安装项目的依赖；\n* 移除原来mall_cms文件的所有内容；\n* 将打包的dist文件夹内容移动到mall_cms文件夹；\n\n```shell\npwd\nnode -v\nnpm -v\n\nnpm install \nnpm run build\n\npwd\n\necho '构建成功'\n\nls\n\n# 删除/root/mall_cms文件夹里所有的内容\nrm -rf /root/mall_cms/* \n\ncp -rf ./dist/* /root/mall_cms/\n```\n\n\n\n![执行构建任务](https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg)\n\n\n\n### 2.2. nginx安装和配置\n\n#### 2.2.1. 安装nginx\n\n后续我们部署会使用nginx，所以需要先安装一下nginx：\n\n```shell\ndnf install nginx\n```\n\n启动nginx：\n\n```shell\nsystemctl start nginx\nsystemctl status nginx\nsystemctl enable nginx\n```\n\n\n\n#### 2.2.2. 配置nginx\n\n我们这里主要配置nginx的用户和默认访问目录：\n\n配置用户：\n\n![image-20210825163329209](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg)\n\n\n\n通过Linux命令创建文件夹和文件：\n\n```shell\nmkdir /root/mall_cms\ncd /root/mall_cms\ntouch index.html\n\nvi index.html\n```\n\n\n\n配置访问目录：\n\n![image-20210825163406566](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg)\n\n\n\n","source":"_posts/搭建jenkins.md","raw":"---\ntitle:  搭建jenkins服务器环境\ntag: jenkins\nkeywords: jenkins\ncategories: 自动化部署\n---\n\n## 一. 购买云服务器\n\n这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买\n\n## 二. 搭建服务器环境\n\n### 2.1. jenkins自动化部署\n\n#### 2.1.1. 安装Java环境\n\nJenkins本身是依赖Java的，所以我们需要先安装Java环境：\n\n* 这里我安装了Java1.8的环境\n\n```shell\ndnf search java-1.8\ndnf install java-1.8.0-openjdk.x86_64\n```\n\n\n\n#### 2.1.2. 安装Jenkins\n\n因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：\n\n* wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；\n* rpm：全称为**The RPM Package Manage**，是Linux下一个软件包管理器；\n\n```shell\nwget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo\n\n# 导入GPG密钥以确保您的软件合法\nrpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n# 或者\nrpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n```\n\n编辑一下文件/etc/yum.repos.d/jenkins.repo\n\n* 可以通过vim编辑\n\n```\n[jenkins]\n\nname=Jenkins-stable\n\nbaseurl=http://pkg.jenkins.io/redhat\n\ngpgcheck=1\n```\n\n安装Jenkins\n\n```shell\ndnf install jenkins # --nogpgcheck(可以不加)\n```\n\n启动Jenkins的服务：\n\n```shell\nsystemctl start jenkins\nsystemctl status jenkins\nsystemctl enable jenkins\n```\n\nJenkins默认使用8080端口提供服务，所以需要加入到安全组中：\n\n![image-20201204173117359](https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg)\n\n\n\n\n\n#### 2.1.3. Jenkins用户\n\n我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 `jenkins`，可能会没有访问权限，所以我们需要修改一下它的用户：\n\n修改文件的路径：`/etc/sysconfig/jenkins`\n\n![image-20210825162827962](https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg)\n\n之后需要重启一下Jenkins：\n\n```shell\nsystemctl restart jenkins\n```\n\n\n\n#### 2.1.4. Jenkins配置\n\n打开浏览器，输入：http://8.134.60.235:8080/\n\n* 注意：你输入自己的IP地址\n\n获取输入管理员密码：\n\n* 在下面的地址中 `cat /var/lib/jenkins/secrets/initialAdminPassword`\n\n![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)\n\n可以安装推荐的插件：\n\n![安装推荐的插件](https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg)\n\n\n\n#### 2.1.5. Jenkins任务\n\n**新建任务：**\n\n![新建任务](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg)\n\n![image-20201204185613061](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg)\n\n**配置项目和保留策略：**\n\n![image-20210825160744119](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg)\n\n**源码管理：**\n\n![image-20210825160818122](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg)\n\n**构建触发器：**\n\n这里的触发器规则是这样的：\n\n* 定时字符串从左往右分别是：分 时 日 月 周\n\n```js\n#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建\nH/30 * * * *\n\n#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建\nH H/2 * * *\n\n#每天凌晨两点定时构建\nH 2 * * *\n\n#每月15号执行构建\nH H 15 * *\n\n#工作日，上午9点整执行\nH 9 * * 1-5\n\n#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次\nH/30 8-20/4 * * 1,3,5\n```\n\n\n\n![触发器](https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg)\n\n**构建环境：**\n\n注意：我们需要搭建Node的环境\n\n* 第一步：配置Node的环境；\n* 第二步：安装Node的插件；\n\n![image-20201204190055096](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg)\n\n第一步：配置Node的环境\n\n![node环境](https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg)\n\n第二步：安装Node的插件\n\n* 这里因为我已经安装过了，所以没有搜索到；\n\n![image-20201204185949452](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg)\n\n\n\n构建执行的任务：\n\n* 查看Node的版本等是否有问题；\n* 执行 `npm install` 安装项目的依赖；\n* 移除原来mall_cms文件的所有内容；\n* 将打包的dist文件夹内容移动到mall_cms文件夹；\n\n```shell\npwd\nnode -v\nnpm -v\n\nnpm install \nnpm run build\n\npwd\n\necho '构建成功'\n\nls\n\n# 删除/root/mall_cms文件夹里所有的内容\nrm -rf /root/mall_cms/* \n\ncp -rf ./dist/* /root/mall_cms/\n```\n\n\n\n![执行构建任务](https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg)\n\n\n\n### 2.2. nginx安装和配置\n\n#### 2.2.1. 安装nginx\n\n后续我们部署会使用nginx，所以需要先安装一下nginx：\n\n```shell\ndnf install nginx\n```\n\n启动nginx：\n\n```shell\nsystemctl start nginx\nsystemctl status nginx\nsystemctl enable nginx\n```\n\n\n\n#### 2.2.2. 配置nginx\n\n我们这里主要配置nginx的用户和默认访问目录：\n\n配置用户：\n\n![image-20210825163329209](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg)\n\n\n\n通过Linux命令创建文件夹和文件：\n\n```shell\nmkdir /root/mall_cms\ncd /root/mall_cms\ntouch index.html\n\nvi index.html\n```\n\n\n\n配置访问目录：\n\n![image-20210825163406566](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg)\n\n\n\n","slug":"搭建jenkins","published":1,"date":"2022-02-10T07:11:10.000Z","updated":"2022-02-10T07:21:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbino000718uq18dm6vcl","content":"<h2 id=\"一-购买云服务器\"><a href=\"#一-购买云服务器\" class=\"headerlink\" title=\"一. 购买云服务器\"></a>一. 购买云服务器</h2><p>这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买</p>\n<h2 id=\"二-搭建服务器环境\"><a href=\"#二-搭建服务器环境\" class=\"headerlink\" title=\"二. 搭建服务器环境\"></a>二. 搭建服务器环境</h2><h3 id=\"2-1-jenkins自动化部署\"><a href=\"#2-1-jenkins自动化部署\" class=\"headerlink\" title=\"2.1. jenkins自动化部署\"></a>2.1. jenkins自动化部署</h3><h4 id=\"2-1-1-安装Java环境\"><a href=\"#2-1-1-安装Java环境\" class=\"headerlink\" title=\"2.1.1. 安装Java环境\"></a>2.1.1. 安装Java环境</h4><p>Jenkins本身是依赖Java的，所以我们需要先安装Java环境：</p>\n<ul>\n<li>这里我安装了Java1.8的环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf search java-1.8<br>dnf install java-1.8.0-openjdk.x86_64<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-2-安装Jenkins\"><a href=\"#2-1-2-安装Jenkins\" class=\"headerlink\" title=\"2.1.2. 安装Jenkins\"></a>2.1.2. 安装Jenkins</h4><p>因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：</p>\n<ul>\n<li>wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；</li>\n<li>rpm：全称为<strong>The RPM Package Manage</strong>，是Linux下一个软件包管理器；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">导入GPG密钥以确保您的软件合法</span><br>rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者</span><br>rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key<br></code></pre></td></tr></table></figure>\n\n<p>编辑一下文件/etc/yum.repos.d/jenkins.repo</p>\n<ul>\n<li>可以通过vim编辑</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[jenkins]</span><br><br><span class=\"hljs-attr\">name</span>=Jenkins-stable<br><br><span class=\"hljs-attr\">baseurl</span>=http://pkg.jenkins.io/redhat<br><br><span class=\"hljs-attr\">gpgcheck</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>安装Jenkins</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install jenkins # --nogpgcheck(可以不加)<br></code></pre></td></tr></table></figure>\n\n<p>启动Jenkins的服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start jenkins<br>systemctl status jenkins<br>systemctl enable jenkins<br></code></pre></td></tr></table></figure>\n\n<p>Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg\" alt=\"image-20201204173117359\"></p>\n<h4 id=\"2-1-3-Jenkins用户\"><a href=\"#2-1-3-Jenkins用户\" class=\"headerlink\" title=\"2.1.3. Jenkins用户\"></a>2.1.3. Jenkins用户</h4><p>我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 <code>jenkins</code>，可能会没有访问权限，所以我们需要修改一下它的用户：</p>\n<p>修改文件的路径：<code>/etc/sysconfig/jenkins</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg\" alt=\"image-20210825162827962\"></p>\n<p>之后需要重启一下Jenkins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl restart jenkins<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-4-Jenkins配置\"><a href=\"#2-1-4-Jenkins配置\" class=\"headerlink\" title=\"2.1.4. Jenkins配置\"></a>2.1.4. Jenkins配置</h4><p>打开浏览器，输入：<a href=\"http://8.134.60.235:8080/\">http://8.134.60.235:8080/</a></p>\n<ul>\n<li>注意：你输入自己的IP地址</li>\n</ul>\n<p>获取输入管理员密码：</p>\n<ul>\n<li>在下面的地址中 <code>cat /var/lib/jenkins/secrets/initialAdminPassword</code></li>\n</ul>\n<p>![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)</p>\n<p>可以安装推荐的插件：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg\" alt=\"安装推荐的插件\"></p>\n<h4 id=\"2-1-5-Jenkins任务\"><a href=\"#2-1-5-Jenkins任务\" class=\"headerlink\" title=\"2.1.5. Jenkins任务\"></a>2.1.5. Jenkins任务</h4><p><strong>新建任务：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg\" alt=\"新建任务\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg\" alt=\"image-20201204185613061\"></p>\n<p><strong>配置项目和保留策略：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg\" alt=\"image-20210825160744119\"></p>\n<p><strong>源码管理：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg\" alt=\"image-20210825160818122\"></p>\n<p><strong>构建触发器：</strong></p>\n<p>这里的触发器规则是这样的：</p>\n<ul>\n<li>定时字符串从左往右分别是：分 时 日 月 周</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">#每半小时构建一次<span class=\"hljs-variable constant_\">OR</span>每半小时检查一次远程代码分支，有更新则构建<br>H/<span class=\"hljs-number\">30</span> * * * *<br><br>#每两小时构建一次<span class=\"hljs-variable constant_\">OR</span>每两小时检查一次远程代码分支，有更新则构建<br>H H/<span class=\"hljs-number\">2</span> * * *<br><br>#每天凌晨两点定时构建<br>H <span class=\"hljs-number\">2</span> * * *<br><br>#每月<span class=\"hljs-number\">15</span>号执行构建<br>H H <span class=\"hljs-number\">15</span> * *<br><br>#工作日，上午<span class=\"hljs-number\">9</span>点整执行<br>H <span class=\"hljs-number\">9</span> * * <span class=\"hljs-number\">1</span>-<span class=\"hljs-number\">5</span><br><br>#每周<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>，从<span class=\"hljs-number\">8</span>:<span class=\"hljs-number\">30</span>开始，截止<span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">30</span>，每<span class=\"hljs-number\">4</span>小时<span class=\"hljs-number\">30</span>分构建一次<br>H/<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">8</span>-<span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">4</span> * * <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg\" alt=\"触发器\"></p>\n<p><strong>构建环境：</strong></p>\n<p>注意：我们需要搭建Node的环境</p>\n<ul>\n<li>第一步：配置Node的环境；</li>\n<li>第二步：安装Node的插件；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg\" alt=\"image-20201204190055096\"></p>\n<p>第一步：配置Node的环境</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg\" alt=\"node环境\"></p>\n<p>第二步：安装Node的插件</p>\n<ul>\n<li>这里因为我已经安装过了，所以没有搜索到；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg\" alt=\"image-20201204185949452\"></p>\n<p>构建执行的任务：</p>\n<ul>\n<li>查看Node的版本等是否有问题；</li>\n<li>执行 <code>npm install</code> 安装项目的依赖；</li>\n<li>移除原来mall_cms文件的所有内容；</li>\n<li>将打包的dist文件夹内容移动到mall_cms文件夹；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pwd<br>node -v<br>npm -v<br><br>npm install <br>npm run build<br><br>pwd<br><br>echo &#x27;构建成功&#x27;<br><br>ls<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除/root/mall_cms文件夹里所有的内容</span><br>rm -rf /root/mall_cms/* <br><br>cp -rf ./dist/* /root/mall_cms/<br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg\" alt=\"执行构建任务\"></p>\n<h3 id=\"2-2-nginx安装和配置\"><a href=\"#2-2-nginx安装和配置\" class=\"headerlink\" title=\"2.2. nginx安装和配置\"></a>2.2. nginx安装和配置</h3><h4 id=\"2-2-1-安装nginx\"><a href=\"#2-2-1-安装nginx\" class=\"headerlink\" title=\"2.2.1. 安装nginx\"></a>2.2.1. 安装nginx</h4><p>后续我们部署会使用nginx，所以需要先安装一下nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install nginx<br></code></pre></td></tr></table></figure>\n\n<p>启动nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start nginx<br>systemctl status nginx<br>systemctl enable nginx<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-2-配置nginx\"><a href=\"#2-2-2-配置nginx\" class=\"headerlink\" title=\"2.2.2. 配置nginx\"></a>2.2.2. 配置nginx</h4><p>我们这里主要配置nginx的用户和默认访问目录：</p>\n<p>配置用户：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg\" alt=\"image-20210825163329209\"></p>\n<p>通过Linux命令创建文件夹和文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir /root/mall_cms<br>cd /root/mall_cms<br>touch index.html<br><br>vi index.html<br></code></pre></td></tr></table></figure>\n\n\n\n<p>配置访问目录：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg\" alt=\"image-20210825163406566\"></p>\n","site":{"data":{}},"wordcount":2193,"excerpt":"","more":"<h2 id=\"一-购买云服务器\"><a href=\"#一-购买云服务器\" class=\"headerlink\" title=\"一. 购买云服务器\"></a>一. 购买云服务器</h2><p>这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买</p>\n<h2 id=\"二-搭建服务器环境\"><a href=\"#二-搭建服务器环境\" class=\"headerlink\" title=\"二. 搭建服务器环境\"></a>二. 搭建服务器环境</h2><h3 id=\"2-1-jenkins自动化部署\"><a href=\"#2-1-jenkins自动化部署\" class=\"headerlink\" title=\"2.1. jenkins自动化部署\"></a>2.1. jenkins自动化部署</h3><h4 id=\"2-1-1-安装Java环境\"><a href=\"#2-1-1-安装Java环境\" class=\"headerlink\" title=\"2.1.1. 安装Java环境\"></a>2.1.1. 安装Java环境</h4><p>Jenkins本身是依赖Java的，所以我们需要先安装Java环境：</p>\n<ul>\n<li>这里我安装了Java1.8的环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf search java-1.8<br>dnf install java-1.8.0-openjdk.x86_64<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-2-安装Jenkins\"><a href=\"#2-1-2-安装Jenkins\" class=\"headerlink\" title=\"2.1.2. 安装Jenkins\"></a>2.1.2. 安装Jenkins</h4><p>因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：</p>\n<ul>\n<li>wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；</li>\n<li>rpm：全称为<strong>The RPM Package Manage</strong>，是Linux下一个软件包管理器；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">导入GPG密钥以确保您的软件合法</span><br>rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者</span><br>rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key<br></code></pre></td></tr></table></figure>\n\n<p>编辑一下文件/etc/yum.repos.d/jenkins.repo</p>\n<ul>\n<li>可以通过vim编辑</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[jenkins]</span><br><br><span class=\"hljs-attr\">name</span>=Jenkins-stable<br><br><span class=\"hljs-attr\">baseurl</span>=http://pkg.jenkins.io/redhat<br><br><span class=\"hljs-attr\">gpgcheck</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>安装Jenkins</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install jenkins # --nogpgcheck(可以不加)<br></code></pre></td></tr></table></figure>\n\n<p>启动Jenkins的服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start jenkins<br>systemctl status jenkins<br>systemctl enable jenkins<br></code></pre></td></tr></table></figure>\n\n<p>Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg\" alt=\"image-20201204173117359\"></p>\n<h4 id=\"2-1-3-Jenkins用户\"><a href=\"#2-1-3-Jenkins用户\" class=\"headerlink\" title=\"2.1.3. Jenkins用户\"></a>2.1.3. Jenkins用户</h4><p>我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 <code>jenkins</code>，可能会没有访问权限，所以我们需要修改一下它的用户：</p>\n<p>修改文件的路径：<code>/etc/sysconfig/jenkins</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg\" alt=\"image-20210825162827962\"></p>\n<p>之后需要重启一下Jenkins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl restart jenkins<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-4-Jenkins配置\"><a href=\"#2-1-4-Jenkins配置\" class=\"headerlink\" title=\"2.1.4. Jenkins配置\"></a>2.1.4. Jenkins配置</h4><p>打开浏览器，输入：<a href=\"http://8.134.60.235:8080/\">http://8.134.60.235:8080/</a></p>\n<ul>\n<li>注意：你输入自己的IP地址</li>\n</ul>\n<p>获取输入管理员密码：</p>\n<ul>\n<li>在下面的地址中 <code>cat /var/lib/jenkins/secrets/initialAdminPassword</code></li>\n</ul>\n<p>![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)</p>\n<p>可以安装推荐的插件：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg\" alt=\"安装推荐的插件\"></p>\n<h4 id=\"2-1-5-Jenkins任务\"><a href=\"#2-1-5-Jenkins任务\" class=\"headerlink\" title=\"2.1.5. Jenkins任务\"></a>2.1.5. Jenkins任务</h4><p><strong>新建任务：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg\" alt=\"新建任务\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg\" alt=\"image-20201204185613061\"></p>\n<p><strong>配置项目和保留策略：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg\" alt=\"image-20210825160744119\"></p>\n<p><strong>源码管理：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg\" alt=\"image-20210825160818122\"></p>\n<p><strong>构建触发器：</strong></p>\n<p>这里的触发器规则是这样的：</p>\n<ul>\n<li>定时字符串从左往右分别是：分 时 日 月 周</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">#每半小时构建一次<span class=\"hljs-variable constant_\">OR</span>每半小时检查一次远程代码分支，有更新则构建<br>H/<span class=\"hljs-number\">30</span> * * * *<br><br>#每两小时构建一次<span class=\"hljs-variable constant_\">OR</span>每两小时检查一次远程代码分支，有更新则构建<br>H H/<span class=\"hljs-number\">2</span> * * *<br><br>#每天凌晨两点定时构建<br>H <span class=\"hljs-number\">2</span> * * *<br><br>#每月<span class=\"hljs-number\">15</span>号执行构建<br>H H <span class=\"hljs-number\">15</span> * *<br><br>#工作日，上午<span class=\"hljs-number\">9</span>点整执行<br>H <span class=\"hljs-number\">9</span> * * <span class=\"hljs-number\">1</span>-<span class=\"hljs-number\">5</span><br><br>#每周<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>，从<span class=\"hljs-number\">8</span>:<span class=\"hljs-number\">30</span>开始，截止<span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">30</span>，每<span class=\"hljs-number\">4</span>小时<span class=\"hljs-number\">30</span>分构建一次<br>H/<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">8</span>-<span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">4</span> * * <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg\" alt=\"触发器\"></p>\n<p><strong>构建环境：</strong></p>\n<p>注意：我们需要搭建Node的环境</p>\n<ul>\n<li>第一步：配置Node的环境；</li>\n<li>第二步：安装Node的插件；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg\" alt=\"image-20201204190055096\"></p>\n<p>第一步：配置Node的环境</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg\" alt=\"node环境\"></p>\n<p>第二步：安装Node的插件</p>\n<ul>\n<li>这里因为我已经安装过了，所以没有搜索到；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg\" alt=\"image-20201204185949452\"></p>\n<p>构建执行的任务：</p>\n<ul>\n<li>查看Node的版本等是否有问题；</li>\n<li>执行 <code>npm install</code> 安装项目的依赖；</li>\n<li>移除原来mall_cms文件的所有内容；</li>\n<li>将打包的dist文件夹内容移动到mall_cms文件夹；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pwd<br>node -v<br>npm -v<br><br>npm install <br>npm run build<br><br>pwd<br><br>echo &#x27;构建成功&#x27;<br><br>ls<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除/root/mall_cms文件夹里所有的内容</span><br>rm -rf /root/mall_cms/* <br><br>cp -rf ./dist/* /root/mall_cms/<br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg\" alt=\"执行构建任务\"></p>\n<h3 id=\"2-2-nginx安装和配置\"><a href=\"#2-2-nginx安装和配置\" class=\"headerlink\" title=\"2.2. nginx安装和配置\"></a>2.2. nginx安装和配置</h3><h4 id=\"2-2-1-安装nginx\"><a href=\"#2-2-1-安装nginx\" class=\"headerlink\" title=\"2.2.1. 安装nginx\"></a>2.2.1. 安装nginx</h4><p>后续我们部署会使用nginx，所以需要先安装一下nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install nginx<br></code></pre></td></tr></table></figure>\n\n<p>启动nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start nginx<br>systemctl status nginx<br>systemctl enable nginx<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-2-配置nginx\"><a href=\"#2-2-2-配置nginx\" class=\"headerlink\" title=\"2.2.2. 配置nginx\"></a>2.2.2. 配置nginx</h4><p>我们这里主要配置nginx的用户和默认访问目录：</p>\n<p>配置用户：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg\" alt=\"image-20210825163329209\"></p>\n<p>通过Linux命令创建文件夹和文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir /root/mall_cms<br>cd /root/mall_cms<br>touch index.html<br><br>vi index.html<br></code></pre></td></tr></table></figure>\n\n\n\n<p>配置访问目录：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg\" alt=\"image-20210825163406566\"></p>\n"},{"title":"浏览器页面的渲染过程","keywords":"浏览器渲染","_content":"# 浏览器页面的渲染过程\n\n### 1.输入网址\n\n当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL\n\n- 如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址\n- 如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL\n\n当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作\n\n### 2.解析URL\n\nURL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求\n\n### 3.检查浏览器缓存\n\n接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程\n\n优化：1.开启浏览器缓存；2.第三方库公共模块抽取\n\n### 4.DNS解析\n\n在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址\n\n优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）\n\n### 5.TCP/IP报文\n\n三次握手\n\n### 6.http请求\n\n连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息\n\n### 7.服务器解析请求并返回http报文\n\n服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了\n\n### 8.浏览器渲染页面\n\n- DOM树（DOM）\n  - 字节（Bytes） -> 字符（Characters） > 令牌（token） -> 节点（Nodes）-> 文档对象模型（DOM）\n- CSS对象模型（CSSOM）\n- 布局树Layout Tree\n  - DOM树与CSSOM树合并后形成渲染树（RenderTree）\n  - 渲染树只包含渲染网页所需的节点\n  - 布局计算每个对象的精确位置和大小\n  - 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上\n- 渲染\n  1. 获取DOM后分割为多个图层\n  2. 对每个图层的节点计算样式结果（Recalculate style --样式重计算）\n  3. 为每个节点生成图形和位置（Layout --重排，回流）\n  4. 将每个节点绘制填充到图层位图中（Paint --重绘）\n  5. 图层作为纹理上传至GPU\n  6. 组合多个图层到页面上生成最终屏幕图像（Composite Layers-- 图层重组）\n- 回流和重绘\n  - 重绘\n    - 当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘\n  - 回流\n    - 当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流\n  - 回流必将引起重绘，而重绘不一定会引起回流\n- 优化：\n  1. 静态资源使用CDN，缩短静态资源请求时间\n  2. 将css放在文件头部，JavaScript文件放在底部\n  3. 图片优化\n     1. 图片压缩\n     2. 图片懒加载\n     3. 使用svg响应式图片\n     4. 使用webp格式的图片\n  4. 压缩文件\n     1. JavaScript：UglifyPlugin\n     2. CSS ：MiniCssExtractPlugin\n     3. HTML：HtmlWebpackPlugin\n  5. 减少重绘重排\n  6. 代码分割（如路由懒加载）\n  7. Tree Shaking\n     - Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除\n  8. 使用服务端渲染\n\n### 9.断开连接\n\n四次分手","source":"_posts/浏览器页面的渲染过程.md","raw":"---\ntitle:  浏览器页面的渲染过程\ntag: 浏览器渲染\nkeywords: 浏览器渲染\ncategories: 浏览器相关知识\n---\n# 浏览器页面的渲染过程\n\n### 1.输入网址\n\n当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL\n\n- 如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址\n- 如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL\n\n当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作\n\n### 2.解析URL\n\nURL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求\n\n### 3.检查浏览器缓存\n\n接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程\n\n优化：1.开启浏览器缓存；2.第三方库公共模块抽取\n\n### 4.DNS解析\n\n在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址\n\n优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）\n\n### 5.TCP/IP报文\n\n三次握手\n\n### 6.http请求\n\n连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息\n\n### 7.服务器解析请求并返回http报文\n\n服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了\n\n### 8.浏览器渲染页面\n\n- DOM树（DOM）\n  - 字节（Bytes） -> 字符（Characters） > 令牌（token） -> 节点（Nodes）-> 文档对象模型（DOM）\n- CSS对象模型（CSSOM）\n- 布局树Layout Tree\n  - DOM树与CSSOM树合并后形成渲染树（RenderTree）\n  - 渲染树只包含渲染网页所需的节点\n  - 布局计算每个对象的精确位置和大小\n  - 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上\n- 渲染\n  1. 获取DOM后分割为多个图层\n  2. 对每个图层的节点计算样式结果（Recalculate style --样式重计算）\n  3. 为每个节点生成图形和位置（Layout --重排，回流）\n  4. 将每个节点绘制填充到图层位图中（Paint --重绘）\n  5. 图层作为纹理上传至GPU\n  6. 组合多个图层到页面上生成最终屏幕图像（Composite Layers-- 图层重组）\n- 回流和重绘\n  - 重绘\n    - 当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘\n  - 回流\n    - 当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流\n  - 回流必将引起重绘，而重绘不一定会引起回流\n- 优化：\n  1. 静态资源使用CDN，缩短静态资源请求时间\n  2. 将css放在文件头部，JavaScript文件放在底部\n  3. 图片优化\n     1. 图片压缩\n     2. 图片懒加载\n     3. 使用svg响应式图片\n     4. 使用webp格式的图片\n  4. 压缩文件\n     1. JavaScript：UglifyPlugin\n     2. CSS ：MiniCssExtractPlugin\n     3. HTML：HtmlWebpackPlugin\n  5. 减少重绘重排\n  6. 代码分割（如路由懒加载）\n  7. Tree Shaking\n     - Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除\n  8. 使用服务端渲染\n\n### 9.断开连接\n\n四次分手","slug":"浏览器页面的渲染过程","published":1,"date":"2022-02-21T16:43:21.702Z","updated":"2022-02-21T16:47:00.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinp000918uq2nd1fjpf","content":"<h1 id=\"浏览器页面的渲染过程\"><a href=\"#浏览器页面的渲染过程\" class=\"headerlink\" title=\"浏览器页面的渲染过程\"></a>浏览器页面的渲染过程</h1><h3 id=\"1-输入网址\"><a href=\"#1-输入网址\" class=\"headerlink\" title=\"1.输入网址\"></a>1.输入网址</h3><p>当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址</li>\n<li>如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL</li>\n</ul>\n<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作</p>\n<h3 id=\"2-解析URL\"><a href=\"#2-解析URL\" class=\"headerlink\" title=\"2.解析URL\"></a>2.解析URL</h3><p>URL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求</p>\n<h3 id=\"3-检查浏览器缓存\"><a href=\"#3-检查浏览器缓存\" class=\"headerlink\" title=\"3.检查浏览器缓存\"></a>3.检查浏览器缓存</h3><p>接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程</p>\n<p>优化：1.开启浏览器缓存；2.第三方库公共模块抽取</p>\n<h3 id=\"4-DNS解析\"><a href=\"#4-DNS解析\" class=\"headerlink\" title=\"4.DNS解析\"></a>4.DNS解析</h3><p>在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址</p>\n<p>优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）</p>\n<h3 id=\"5-TCP-IP报文\"><a href=\"#5-TCP-IP报文\" class=\"headerlink\" title=\"5.TCP/IP报文\"></a>5.TCP/IP报文</h3><p>三次握手</p>\n<h3 id=\"6-http请求\"><a href=\"#6-http请求\" class=\"headerlink\" title=\"6.http请求\"></a>6.http请求</h3><p>连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息</p>\n<h3 id=\"7-服务器解析请求并返回http报文\"><a href=\"#7-服务器解析请求并返回http报文\" class=\"headerlink\" title=\"7.服务器解析请求并返回http报文\"></a>7.服务器解析请求并返回http报文</h3><p>服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了</p>\n<h3 id=\"8-浏览器渲染页面\"><a href=\"#8-浏览器渲染页面\" class=\"headerlink\" title=\"8.浏览器渲染页面\"></a>8.浏览器渲染页面</h3><ul>\n<li>DOM树（DOM）<ul>\n<li>字节（Bytes） -&gt; 字符（Characters） &gt; 令牌（token） -&gt; 节点（Nodes）-&gt; 文档对象模型（DOM）</li>\n</ul>\n</li>\n<li>CSS对象模型（CSSOM）</li>\n<li>布局树Layout Tree<ul>\n<li>DOM树与CSSOM树合并后形成渲染树（RenderTree）</li>\n<li>渲染树只包含渲染网页所需的节点</li>\n<li>布局计算每个对象的精确位置和大小</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上</li>\n</ul>\n</li>\n<li>渲染<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style –样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout –重排，回流）</li>\n<li>将每个节点绘制填充到图层位图中（Paint –重绘）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>组合多个图层到页面上生成最终屏幕图像（Composite Layers– 图层重组）</li>\n</ol>\n</li>\n<li>回流和重绘<ul>\n<li>重绘<ul>\n<li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘</li>\n</ul>\n</li>\n<li>回流<ul>\n<li>当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流</li>\n</ul>\n</li>\n<li>回流必将引起重绘，而重绘不一定会引起回流</li>\n</ul>\n</li>\n<li>优化：<ol>\n<li>静态资源使用CDN，缩短静态资源请求时间</li>\n<li>将css放在文件头部，JavaScript文件放在底部</li>\n<li>图片优化<ol>\n<li>图片压缩</li>\n<li>图片懒加载</li>\n<li>使用svg响应式图片</li>\n<li>使用webp格式的图片</li>\n</ol>\n</li>\n<li>压缩文件<ol>\n<li>JavaScript：UglifyPlugin</li>\n<li>CSS ：MiniCssExtractPlugin</li>\n<li>HTML：HtmlWebpackPlugin</li>\n</ol>\n</li>\n<li>减少重绘重排</li>\n<li>代码分割（如路由懒加载）</li>\n<li>Tree Shaking<ul>\n<li>Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除</li>\n</ul>\n</li>\n<li>使用服务端渲染</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"9-断开连接\"><a href=\"#9-断开连接\" class=\"headerlink\" title=\"9.断开连接\"></a>9.断开连接</h3><p>四次分手</p>\n","site":{"data":{}},"wordcount":1530,"excerpt":"","more":"<h1 id=\"浏览器页面的渲染过程\"><a href=\"#浏览器页面的渲染过程\" class=\"headerlink\" title=\"浏览器页面的渲染过程\"></a>浏览器页面的渲染过程</h1><h3 id=\"1-输入网址\"><a href=\"#1-输入网址\" class=\"headerlink\" title=\"1.输入网址\"></a>1.输入网址</h3><p>当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址</li>\n<li>如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL</li>\n</ul>\n<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作</p>\n<h3 id=\"2-解析URL\"><a href=\"#2-解析URL\" class=\"headerlink\" title=\"2.解析URL\"></a>2.解析URL</h3><p>URL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求</p>\n<h3 id=\"3-检查浏览器缓存\"><a href=\"#3-检查浏览器缓存\" class=\"headerlink\" title=\"3.检查浏览器缓存\"></a>3.检查浏览器缓存</h3><p>接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程</p>\n<p>优化：1.开启浏览器缓存；2.第三方库公共模块抽取</p>\n<h3 id=\"4-DNS解析\"><a href=\"#4-DNS解析\" class=\"headerlink\" title=\"4.DNS解析\"></a>4.DNS解析</h3><p>在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址</p>\n<p>优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）</p>\n<h3 id=\"5-TCP-IP报文\"><a href=\"#5-TCP-IP报文\" class=\"headerlink\" title=\"5.TCP/IP报文\"></a>5.TCP/IP报文</h3><p>三次握手</p>\n<h3 id=\"6-http请求\"><a href=\"#6-http请求\" class=\"headerlink\" title=\"6.http请求\"></a>6.http请求</h3><p>连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息</p>\n<h3 id=\"7-服务器解析请求并返回http报文\"><a href=\"#7-服务器解析请求并返回http报文\" class=\"headerlink\" title=\"7.服务器解析请求并返回http报文\"></a>7.服务器解析请求并返回http报文</h3><p>服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了</p>\n<h3 id=\"8-浏览器渲染页面\"><a href=\"#8-浏览器渲染页面\" class=\"headerlink\" title=\"8.浏览器渲染页面\"></a>8.浏览器渲染页面</h3><ul>\n<li>DOM树（DOM）<ul>\n<li>字节（Bytes） -&gt; 字符（Characters） &gt; 令牌（token） -&gt; 节点（Nodes）-&gt; 文档对象模型（DOM）</li>\n</ul>\n</li>\n<li>CSS对象模型（CSSOM）</li>\n<li>布局树Layout Tree<ul>\n<li>DOM树与CSSOM树合并后形成渲染树（RenderTree）</li>\n<li>渲染树只包含渲染网页所需的节点</li>\n<li>布局计算每个对象的精确位置和大小</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上</li>\n</ul>\n</li>\n<li>渲染<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style –样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout –重排，回流）</li>\n<li>将每个节点绘制填充到图层位图中（Paint –重绘）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>组合多个图层到页面上生成最终屏幕图像（Composite Layers– 图层重组）</li>\n</ol>\n</li>\n<li>回流和重绘<ul>\n<li>重绘<ul>\n<li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘</li>\n</ul>\n</li>\n<li>回流<ul>\n<li>当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流</li>\n</ul>\n</li>\n<li>回流必将引起重绘，而重绘不一定会引起回流</li>\n</ul>\n</li>\n<li>优化：<ol>\n<li>静态资源使用CDN，缩短静态资源请求时间</li>\n<li>将css放在文件头部，JavaScript文件放在底部</li>\n<li>图片优化<ol>\n<li>图片压缩</li>\n<li>图片懒加载</li>\n<li>使用svg响应式图片</li>\n<li>使用webp格式的图片</li>\n</ol>\n</li>\n<li>压缩文件<ol>\n<li>JavaScript：UglifyPlugin</li>\n<li>CSS ：MiniCssExtractPlugin</li>\n<li>HTML：HtmlWebpackPlugin</li>\n</ol>\n</li>\n<li>减少重绘重排</li>\n<li>代码分割（如路由懒加载）</li>\n<li>Tree Shaking<ul>\n<li>Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除</li>\n</ul>\n</li>\n<li>使用服务端渲染</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"9-断开连接\"><a href=\"#9-断开连接\" class=\"headerlink\" title=\"9.断开连接\"></a>9.断开连接</h3><p>四次分手</p>\n"},{"title":"d3相关笔记","keywords":"d3","_content":"### 一.使用d3查询svg\n\nd3.select()、d3.selectAll()\n\n### 二.使用d3设置svg中的属性\n\nd3.attr()\n\n常见的属性：\n\n- id、class\n- x，y，cx，cy（cx、cy是圆的xy坐标）\n- fill（颜色填充color）、stroke（边框border）\n- height、width、r（圆的半径）\n- transform（translate、rotate、scale）\n\n### 三.使用d3添加、删除svg元素\n\nelement.append()、element.remove()\n\n### 四.d3的比例尺\n\n#### 1.d3.scaleLinear()：线性比例尺\n\ndomain:：连续型 range：连续型\n\n```javascript\nconst xScale = d3.scaleLinear()\n.domain([min_d, max_d]) // 连续型\n.range(min, max) // 连续型\n\nconst yScale = d3.scaleLinear()\n.domain([0, d3.max(data, item => item.value)])\n.range([0, innerWidth])\n```\n\nd3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值\n\n#### 2.d3.scaleBand()：序数比例尺\n\ndomain：离散型 range：连续性\n\n可以理解为用domain将range分割\n\n```javascript\nconst scale_b = d3.scaleBand()\n.domian([1,2,3,4]) // 离散型\n.range([0, 100]) // 连续型\n```\n\n#### 3.d3.scaleOrdinal()：序数比例尺\n\ndomain：离散型 range：离散型\n\n可以简单理解为map映射\n\n```javascript\nconst scaleO = d3.scaleOrdinal()\n.domain(['a','b','c']) // 离散型\n.range([10, 20, 30]) // 离散型\n```\n\n生成颜色比例尺\n\n```javascript\nconst color = d3.scaleOrdinal().domain(naiveKeys).range(d3.schemeSet2)\n```\n\n\n\n#### 4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\n\ndomain：连续型 range：离散型\n\n可以理解为scaleBand的逆变换\n\n```javascript\nconst scaleQ = d3.scaleQuantize()\n.domain([0, 10]) // 连续型\n.range(['a', 'b', 'c']) // 离散型\n```\n\n#### 5.d3.scaleTime()：时间比例尺\n\ndomain：连续型，是时间 range：连续，是刻度\n\n类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴\n\n```javascript\nconst scaleT = d3.scaleTime()\n.domain([new Date(2020, 01, 01), new Date(2021, 01, 01)]) // 连续型\n.range([0, 100]) // 连续型\n```\n\n#### 6.颜色比例尺\n\nd3提供了一些颜色比例尺，10就是10种颜色\n\n①Categorical系列——离散型颜色\nd3.schemeCategory10 // 10就是10种颜色\n\n![category10](/css/images/d3/category10.png)\n\nd3.schemeAccent\n\n![Accent](/css/images/d3/Accent.png)\n\n```javascript\n// 定义一个序数颜色比例尺\nconst color = d3.scaleLinear(d3.schemeCategory10)\n```\n\n②Diverging——连续型颜色（渐变颜色）\n\n方式一：d3.**interpolateBrBG**(*t*)——t => [0, 1]\n\n### 五.Data Join\n\n#### 1.本质上是将数据与图元进行绑定\n\nd3.selectAll(.class类名).data(data)\n\n#### 2.d3绑定数据的三个状态\n\nenter:\n\n- 有数据没有图元\n\n- d3会自动搞清楚哪些数据是新增的\n\n- 根据新增的数据生成对应的图元\n\n- 生成图元的占位，占位的内容需要通过append添加\n\n ```javascript\n  const p = d3.selectAll('.class').data(data).enter().append('rect').attr(...)\n  ```\nupdate:\n\n- 有图元有数据\n\n- update作为实际可视化任务最常用的状态，经常被单独封装为一个函数\n\n- updateSelection.merge(enterSelection).attr().attr()\n\n  - 将两个selection合并到一起操作\n  - enterSelection需要至少append()图元\n\n ```javascript\n  d3.selectAll(.class).data(data).update().transition().durantion(3000).attr('width', d => xScale(d.value))\n  ```\nexit\n\n- 有图元没数据\n\n- d3会自动搞清楚哪些图元是不绑定数据的\n\n ```\n  const p = d3.selectAll('.class').data(data).exit().remove()\n  ```\n\n#### 3.读取数据\n\nd3.csv('path/tp/data.csv').then(res => {})\n\n### 六.path\n\n#### 1.path元素的形状是通过属性d来定义的\n\n#### 2.d3 Path生成器\n\n- d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5) ----用于折线图\n- d3.geoPath().projection() ----用于地图\n- d3.area() ----用于主题河流\n- d3.arc().innerRadius().outerRadius() ----用于饼图\n- d3.lineRadial().angle().radius() ----极坐标系版本的d3.line()\n\n#### 3.d3.line()\n\nconst line = d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5)\n\n使用line:\n\nd3.select('path').datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据\n\n.attr('d', line) // 给path配置line\n\n### 七.interaction\n\n#### 1.地图数据的表达: Topojson & Geojson\n\n#### 2.json数据的读取\n\n```javascript\nd3.json('path/to/data.json').then( data => {… … …} ) \n```\n\n#### 3.topojson转geojson\n\n借助topojson.js库\n\n```javascript\ngeojson = topojson.feature(data, data.objects.countries)\n```\n\n#### 4.地图数据的可视化\n\n```javascript\nconst projection = d3.geoNaturalEarth1();\nconst pathGenerator = d3.geoPath().projection(projection)\n// geo适应宽高\nprojection.fitSize([innerWidth, innerHeight], geojson);\n// path使用geo\ng.selectAll(path).data(geojson.features).join()\n\t.attr('d',pathGenerator  )\n```\n\n#### 5.事件\n\n事件的设置对应于D3中的.on(‘eventName’, callBack) \n\n```javascript\nd3.selectAll('path').on('click', function () {\n  d3.select(this).attr()\n})\n```\n\n图元.on(事件类型, 触发动作) \n\n#### 6.d3-tip\n\ntooltip库，自动在‘合适’的位置显示对话框\n\n### 八.stack(堆叠)\n\n#### 1.d3.stack()\n\n本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）\n\n#### 2.语法\n\n```javascript\nconst stackData = d3.stack()\n\t.keys(naiveKeys) // 需要堆叠哪些字段的数据\n\t.order(d3.stackOrderNone) // 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序\n\t(naiveData)\n```\n\n### 九.tree\n\n#### 1.层级数据预处理d3.hierarchy\n\n- d3.hierarchy\n\n\n- 保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: \n- height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）\n\n\n- •d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中\n\n ```javascript\n  const root = d3.hierarchy(data)\n  ```\n\n#### 2.层级数据预处理d3.tree()\n\n- d3.tree().size([innerHeight, innerWidth])\n\n- 返回一个函数\n\n- 接受参数为d3.hierarchy\n\n- 函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）\n\n ```javascript\n  root = d3.tree().size([innerHeight, innerWidth])(root)\n  ```\n\n#### 3.root.links()和 d3.linkHorizontal()\n\n- root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用\n\n- d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来\n\n ```javascript\n  g.selectAll(\"path\")\n  \t.data(root.links())\n  \t.join(\"path\")\n  \t.attr(\"fill\", \"none\")\n  \t.attr(\"stroke\", \"black\")\n  \t.attr(\"stroke-width\", 1.5)\n  \t.attr(\"d\", d3.linkHorizontal().x(d => d.y).y(d => d.x));\n  ```\n\n#### 4.root.descendants()\n\n- root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组\n\n ```javascript\n  g.selectAll('text')\n  \t.data(root.descendants())\n  \t.join('text')\n  \t.text(d => d.data.name)\n  \t.attr('x', d => d.children ? d.y - 8 : d.y + 8)\n  \t.attr('y', d => d.x + 5)\n  \t.attr('font-size', '0.8em')\n  \t.attr('text-anchor', d => d.children ? 'end' : 'start')\n  ```\n\n  ​","source":"_posts/d3.md","raw":"---\ntitle: d3相关笔记\ntag: d3js\nkeywords: d3\ncategories: 前端可视化库\n---\n### 一.使用d3查询svg\n\nd3.select()、d3.selectAll()\n\n### 二.使用d3设置svg中的属性\n\nd3.attr()\n\n常见的属性：\n\n- id、class\n- x，y，cx，cy（cx、cy是圆的xy坐标）\n- fill（颜色填充color）、stroke（边框border）\n- height、width、r（圆的半径）\n- transform（translate、rotate、scale）\n\n### 三.使用d3添加、删除svg元素\n\nelement.append()、element.remove()\n\n### 四.d3的比例尺\n\n#### 1.d3.scaleLinear()：线性比例尺\n\ndomain:：连续型 range：连续型\n\n```javascript\nconst xScale = d3.scaleLinear()\n.domain([min_d, max_d]) // 连续型\n.range(min, max) // 连续型\n\nconst yScale = d3.scaleLinear()\n.domain([0, d3.max(data, item => item.value)])\n.range([0, innerWidth])\n```\n\nd3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值\n\n#### 2.d3.scaleBand()：序数比例尺\n\ndomain：离散型 range：连续性\n\n可以理解为用domain将range分割\n\n```javascript\nconst scale_b = d3.scaleBand()\n.domian([1,2,3,4]) // 离散型\n.range([0, 100]) // 连续型\n```\n\n#### 3.d3.scaleOrdinal()：序数比例尺\n\ndomain：离散型 range：离散型\n\n可以简单理解为map映射\n\n```javascript\nconst scaleO = d3.scaleOrdinal()\n.domain(['a','b','c']) // 离散型\n.range([10, 20, 30]) // 离散型\n```\n\n生成颜色比例尺\n\n```javascript\nconst color = d3.scaleOrdinal().domain(naiveKeys).range(d3.schemeSet2)\n```\n\n\n\n#### 4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\n\ndomain：连续型 range：离散型\n\n可以理解为scaleBand的逆变换\n\n```javascript\nconst scaleQ = d3.scaleQuantize()\n.domain([0, 10]) // 连续型\n.range(['a', 'b', 'c']) // 离散型\n```\n\n#### 5.d3.scaleTime()：时间比例尺\n\ndomain：连续型，是时间 range：连续，是刻度\n\n类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴\n\n```javascript\nconst scaleT = d3.scaleTime()\n.domain([new Date(2020, 01, 01), new Date(2021, 01, 01)]) // 连续型\n.range([0, 100]) // 连续型\n```\n\n#### 6.颜色比例尺\n\nd3提供了一些颜色比例尺，10就是10种颜色\n\n①Categorical系列——离散型颜色\nd3.schemeCategory10 // 10就是10种颜色\n\n![category10](/css/images/d3/category10.png)\n\nd3.schemeAccent\n\n![Accent](/css/images/d3/Accent.png)\n\n```javascript\n// 定义一个序数颜色比例尺\nconst color = d3.scaleLinear(d3.schemeCategory10)\n```\n\n②Diverging——连续型颜色（渐变颜色）\n\n方式一：d3.**interpolateBrBG**(*t*)——t => [0, 1]\n\n### 五.Data Join\n\n#### 1.本质上是将数据与图元进行绑定\n\nd3.selectAll(.class类名).data(data)\n\n#### 2.d3绑定数据的三个状态\n\nenter:\n\n- 有数据没有图元\n\n- d3会自动搞清楚哪些数据是新增的\n\n- 根据新增的数据生成对应的图元\n\n- 生成图元的占位，占位的内容需要通过append添加\n\n ```javascript\n  const p = d3.selectAll('.class').data(data).enter().append('rect').attr(...)\n  ```\nupdate:\n\n- 有图元有数据\n\n- update作为实际可视化任务最常用的状态，经常被单独封装为一个函数\n\n- updateSelection.merge(enterSelection).attr().attr()\n\n  - 将两个selection合并到一起操作\n  - enterSelection需要至少append()图元\n\n ```javascript\n  d3.selectAll(.class).data(data).update().transition().durantion(3000).attr('width', d => xScale(d.value))\n  ```\nexit\n\n- 有图元没数据\n\n- d3会自动搞清楚哪些图元是不绑定数据的\n\n ```\n  const p = d3.selectAll('.class').data(data).exit().remove()\n  ```\n\n#### 3.读取数据\n\nd3.csv('path/tp/data.csv').then(res => {})\n\n### 六.path\n\n#### 1.path元素的形状是通过属性d来定义的\n\n#### 2.d3 Path生成器\n\n- d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5) ----用于折线图\n- d3.geoPath().projection() ----用于地图\n- d3.area() ----用于主题河流\n- d3.arc().innerRadius().outerRadius() ----用于饼图\n- d3.lineRadial().angle().radius() ----极坐标系版本的d3.line()\n\n#### 3.d3.line()\n\nconst line = d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5)\n\n使用line:\n\nd3.select('path').datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据\n\n.attr('d', line) // 给path配置line\n\n### 七.interaction\n\n#### 1.地图数据的表达: Topojson & Geojson\n\n#### 2.json数据的读取\n\n```javascript\nd3.json('path/to/data.json').then( data => {… … …} ) \n```\n\n#### 3.topojson转geojson\n\n借助topojson.js库\n\n```javascript\ngeojson = topojson.feature(data, data.objects.countries)\n```\n\n#### 4.地图数据的可视化\n\n```javascript\nconst projection = d3.geoNaturalEarth1();\nconst pathGenerator = d3.geoPath().projection(projection)\n// geo适应宽高\nprojection.fitSize([innerWidth, innerHeight], geojson);\n// path使用geo\ng.selectAll(path).data(geojson.features).join()\n\t.attr('d',pathGenerator  )\n```\n\n#### 5.事件\n\n事件的设置对应于D3中的.on(‘eventName’, callBack) \n\n```javascript\nd3.selectAll('path').on('click', function () {\n  d3.select(this).attr()\n})\n```\n\n图元.on(事件类型, 触发动作) \n\n#### 6.d3-tip\n\ntooltip库，自动在‘合适’的位置显示对话框\n\n### 八.stack(堆叠)\n\n#### 1.d3.stack()\n\n本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）\n\n#### 2.语法\n\n```javascript\nconst stackData = d3.stack()\n\t.keys(naiveKeys) // 需要堆叠哪些字段的数据\n\t.order(d3.stackOrderNone) // 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序\n\t(naiveData)\n```\n\n### 九.tree\n\n#### 1.层级数据预处理d3.hierarchy\n\n- d3.hierarchy\n\n\n- 保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: \n- height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）\n\n\n- •d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中\n\n ```javascript\n  const root = d3.hierarchy(data)\n  ```\n\n#### 2.层级数据预处理d3.tree()\n\n- d3.tree().size([innerHeight, innerWidth])\n\n- 返回一个函数\n\n- 接受参数为d3.hierarchy\n\n- 函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）\n\n ```javascript\n  root = d3.tree().size([innerHeight, innerWidth])(root)\n  ```\n\n#### 3.root.links()和 d3.linkHorizontal()\n\n- root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用\n\n- d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来\n\n ```javascript\n  g.selectAll(\"path\")\n  \t.data(root.links())\n  \t.join(\"path\")\n  \t.attr(\"fill\", \"none\")\n  \t.attr(\"stroke\", \"black\")\n  \t.attr(\"stroke-width\", 1.5)\n  \t.attr(\"d\", d3.linkHorizontal().x(d => d.y).y(d => d.x));\n  ```\n\n#### 4.root.descendants()\n\n- root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组\n\n ```javascript\n  g.selectAll('text')\n  \t.data(root.descendants())\n  \t.join('text')\n  \t.text(d => d.data.name)\n  \t.attr('x', d => d.children ? d.y - 8 : d.y + 8)\n  \t.attr('y', d => d.x + 5)\n  \t.attr('font-size', '0.8em')\n  \t.attr('text-anchor', d => d.children ? 'end' : 'start')\n  ```\n\n  ​","slug":"d3","published":1,"date":"2021-07-14T06:42:56.000Z","updated":"2021-10-14T01:38:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinq000b18uqeztkeqzj","content":"<h3 id=\"一-使用d3查询svg\"><a href=\"#一-使用d3查询svg\" class=\"headerlink\" title=\"一.使用d3查询svg\"></a>一.使用d3查询svg</h3><p>d3.select()、d3.selectAll()</p>\n<h3 id=\"二-使用d3设置svg中的属性\"><a href=\"#二-使用d3设置svg中的属性\" class=\"headerlink\" title=\"二.使用d3设置svg中的属性\"></a>二.使用d3设置svg中的属性</h3><p>d3.attr()</p>\n<p>常见的属性：</p>\n<ul>\n<li>id、class</li>\n<li>x，y，cx，cy（cx、cy是圆的xy坐标）</li>\n<li>fill（颜色填充color）、stroke（边框border）</li>\n<li>height、width、r（圆的半径）</li>\n<li>transform（translate、rotate、scale）</li>\n</ul>\n<h3 id=\"三-使用d3添加、删除svg元素\"><a href=\"#三-使用d3添加、删除svg元素\" class=\"headerlink\" title=\"三.使用d3添加、删除svg元素\"></a>三.使用d3添加、删除svg元素</h3><p>element.append()、element.remove()</p>\n<h3 id=\"四-d3的比例尺\"><a href=\"#四-d3的比例尺\" class=\"headerlink\" title=\"四.d3的比例尺\"></a>四.d3的比例尺</h3><h4 id=\"1-d3-scaleLinear-：线性比例尺\"><a href=\"#1-d3-scaleLinear-：线性比例尺\" class=\"headerlink\" title=\"1.d3.scaleLinear()：线性比例尺\"></a>1.d3.scaleLinear()：线性比例尺</h4><p>domain:：连续型 range：连续型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> xScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([min_d, max_d]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>(min, max) <span class=\"hljs-comment\">// 连续型</span><br><br><span class=\"hljs-keyword\">const</span> yScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, d3.<span class=\"hljs-title function_\">max</span>(data, <span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-property\">value</span>)])<br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, innerWidth])<br></code></pre></td></tr></table></figure>\n\n<p>d3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值</p>\n<h4 id=\"2-d3-scaleBand-：序数比例尺\"><a href=\"#2-d3-scaleBand-：序数比例尺\" class=\"headerlink\" title=\"2.d3.scaleBand()：序数比例尺\"></a>2.d3.scaleBand()：序数比例尺</h4><p>domain：离散型 range：连续性</p>\n<p>可以理解为用domain将range分割</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scale_b = d3.<span class=\"hljs-title function_\">scaleBand</span>()<br>.<span class=\"hljs-title function_\">domian</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-d3-scaleOrdinal-：序数比例尺\"><a href=\"#3-d3-scaleOrdinal-：序数比例尺\" class=\"headerlink\" title=\"3.d3.scaleOrdinal()：序数比例尺\"></a>3.d3.scaleOrdinal()：序数比例尺</h4><p>domain：离散型 range：离散型</p>\n<p>可以简单理解为map映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleO = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<p>生成颜色比例尺</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>().<span class=\"hljs-title function_\">domain</span>(naiveKeys).<span class=\"hljs-title function_\">range</span>(d3.<span class=\"hljs-property\">schemeSet2</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\"><a href=\"#4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\" class=\"headerlink\" title=\"4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\"></a>4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)</h4><p>domain：连续型 range：离散型</p>\n<p>可以理解为scaleBand的逆变换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleQ = d3.<span class=\"hljs-title function_\">scaleQuantize</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-d3-scaleTime-：时间比例尺\"><a href=\"#5-d3-scaleTime-：时间比例尺\" class=\"headerlink\" title=\"5.d3.scaleTime()：时间比例尺\"></a>5.d3.scaleTime()：时间比例尺</h4><p>domain：连续型，是时间 range：连续，是刻度</p>\n<p>类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleT = d3.<span class=\"hljs-title function_\">scaleTime</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2020</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>)]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-颜色比例尺\"><a href=\"#6-颜色比例尺\" class=\"headerlink\" title=\"6.颜色比例尺\"></a>6.颜色比例尺</h4><p>d3提供了一些颜色比例尺，10就是10种颜色</p>\n<p>①Categorical系列——离散型颜色<br>d3.schemeCategory10 // 10就是10种颜色</p>\n<p><img src=\"/css/images/d3/category10.png\" alt=\"category10\"></p>\n<p>d3.schemeAccent</p>\n<p><img src=\"/css/images/d3/Accent.png\" alt=\"Accent\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义一个序数颜色比例尺</span><br><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleLinear</span>(d3.<span class=\"hljs-property\">schemeCategory10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>②Diverging——连续型颜色（渐变颜色）</p>\n<p>方式一：d3.<strong>interpolateBrBG</strong>(<em>t</em>)——t =&gt; [0, 1]</p>\n<h3 id=\"五-Data-Join\"><a href=\"#五-Data-Join\" class=\"headerlink\" title=\"五.Data Join\"></a>五.Data Join</h3><h4 id=\"1-本质上是将数据与图元进行绑定\"><a href=\"#1-本质上是将数据与图元进行绑定\" class=\"headerlink\" title=\"1.本质上是将数据与图元进行绑定\"></a>1.本质上是将数据与图元进行绑定</h4><p>d3.selectAll(.class类名).data(data)</p>\n<h4 id=\"2-d3绑定数据的三个状态\"><a href=\"#2-d3绑定数据的三个状态\" class=\"headerlink\" title=\"2.d3绑定数据的三个状态\"></a>2.d3绑定数据的三个状态</h4><p>enter:</p>\n<ul>\n<li><p>有数据没有图元</p>\n</li>\n<li><p>d3会自动搞清楚哪些数据是新增的</p>\n</li>\n<li><p>根据新增的数据生成对应的图元</p>\n</li>\n<li><p>生成图元的占位，占位的内容需要通过append添加</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">enter</span>().<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;rect&#x27;</span>).<span class=\"hljs-title function_\">attr</span>(...)<br></code></pre></td></tr></table></figure>\n<p>update:</p>\n<ul>\n<li><p>有图元有数据</p>\n</li>\n<li><p>update作为实际可视化任务最常用的状态，经常被单独封装为一个函数</p>\n</li>\n<li><p>updateSelection.merge(enterSelection).attr().attr()</p>\n<ul>\n<li>将两个selection合并到一起操作</li>\n<li>enterSelection需要至少append()图元</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(.<span class=\"hljs-property\">class</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">update</span>().<span class=\"hljs-title function_\">transition</span>().<span class=\"hljs-title function_\">durantion</span>(<span class=\"hljs-number\">3000</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;width&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> <span class=\"hljs-title function_\">xScale</span>(d.<span class=\"hljs-property\">value</span>))<br></code></pre></td></tr></table></figure>\n<p>exit</p>\n<ul>\n<li><p>有图元没数据</p>\n</li>\n<li><p>d3会自动搞清楚哪些图元是不绑定数据的</p>\n</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const p = d3.selectAll(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).data(data).<span class=\"hljs-keyword\">exit</span>().remove()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-读取数据\"><a href=\"#3-读取数据\" class=\"headerlink\" title=\"3.读取数据\"></a>3.读取数据</h4><p>d3.csv(‘path/tp/data.csv’).then(res =&gt; {})</p>\n<h3 id=\"六-path\"><a href=\"#六-path\" class=\"headerlink\" title=\"六.path\"></a>六.path</h3><h4 id=\"1-path元素的形状是通过属性d来定义的\"><a href=\"#1-path元素的形状是通过属性d来定义的\" class=\"headerlink\" title=\"1.path元素的形状是通过属性d来定义的\"></a>1.path元素的形状是通过属性d来定义的</h4><h4 id=\"2-d3-Path生成器\"><a href=\"#2-d3-Path生成器\" class=\"headerlink\" title=\"2.d3 Path生成器\"></a>2.d3 Path生成器</h4><ul>\n<li>d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5) —-用于折线图</li>\n<li>d3.geoPath().projection() —-用于地图</li>\n<li>d3.area() —-用于主题河流</li>\n<li>d3.arc().innerRadius().outerRadius() —-用于饼图</li>\n<li>d3.lineRadial().angle().radius() —-极坐标系版本的d3.line()</li>\n</ul>\n<h4 id=\"3-d3-line\"><a href=\"#3-d3-line\" class=\"headerlink\" title=\"3.d3.line()\"></a>3.d3.line()</h4><p>const line = d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5)</p>\n<p>使用line:</p>\n<p>d3.select(‘path’).datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据</p>\n<p>.attr(‘d’, line) // 给path配置line</p>\n<h3 id=\"七-interaction\"><a href=\"#七-interaction\" class=\"headerlink\" title=\"七.interaction\"></a>七.interaction</h3><h4 id=\"1-地图数据的表达-Topojson-amp-Geojson\"><a href=\"#1-地图数据的表达-Topojson-amp-Geojson\" class=\"headerlink\" title=\"1.地图数据的表达: Topojson &amp; Geojson\"></a>1.地图数据的表达: Topojson &amp; Geojson</h4><h4 id=\"2-json数据的读取\"><a href=\"#2-json数据的读取\" class=\"headerlink\" title=\"2.json数据的读取\"></a>2.json数据的读取</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">json</span>(<span class=\"hljs-string\">&#x27;path/to/data.json&#x27;</span>).<span class=\"hljs-title function_\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;… … …&#125; ) <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-topojson转geojson\"><a href=\"#3-topojson转geojson\" class=\"headerlink\" title=\"3.topojson转geojson\"></a>3.topojson转geojson</h4><p>借助topojson.js库</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">geojson = topojson.<span class=\"hljs-title function_\">feature</span>(data, data.<span class=\"hljs-property\">objects</span>.<span class=\"hljs-property\">countries</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-地图数据的可视化\"><a href=\"#4-地图数据的可视化\" class=\"headerlink\" title=\"4.地图数据的可视化\"></a>4.地图数据的可视化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> projection = d3.<span class=\"hljs-title function_\">geoNaturalEarth1</span>();<br><span class=\"hljs-keyword\">const</span> pathGenerator = d3.<span class=\"hljs-title function_\">geoPath</span>().<span class=\"hljs-title function_\">projection</span>(projection)<br><span class=\"hljs-comment\">// geo适应宽高</span><br>projection.<span class=\"hljs-title function_\">fitSize</span>([innerWidth, innerHeight], geojson);<br><span class=\"hljs-comment\">// path使用geo</span><br>g.<span class=\"hljs-title function_\">selectAll</span>(path).<span class=\"hljs-title function_\">data</span>(geojson.<span class=\"hljs-property\">features</span>).<span class=\"hljs-title function_\">join</span>()<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>,pathGenerator  )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-事件\"><a href=\"#5-事件\" class=\"headerlink\" title=\"5.事件\"></a>5.事件</h4><p>事件的设置对应于D3中的.on(‘eventName’, callBack) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  d3.<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>图元.on(事件类型, 触发动作) </p>\n<h4 id=\"6-d3-tip\"><a href=\"#6-d3-tip\" class=\"headerlink\" title=\"6.d3-tip\"></a>6.d3-tip</h4><p>tooltip库，自动在‘合适’的位置显示对话框</p>\n<h3 id=\"八-stack-堆叠\"><a href=\"#八-stack-堆叠\" class=\"headerlink\" title=\"八.stack(堆叠)\"></a>八.stack(堆叠)</h3><h4 id=\"1-d3-stack\"><a href=\"#1-d3-stack\" class=\"headerlink\" title=\"1.d3.stack()\"></a>1.d3.stack()</h4><p>本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）</p>\n<h4 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2.语法\"></a>2.语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> stackData = d3.<span class=\"hljs-title function_\">stack</span>()<br>\t.<span class=\"hljs-title function_\">keys</span>(naiveKeys) <span class=\"hljs-comment\">// 需要堆叠哪些字段的数据</span><br>\t.<span class=\"hljs-title function_\">order</span>(d3.<span class=\"hljs-property\">stackOrderNone</span>) <span class=\"hljs-comment\">// 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序</span><br>\t(naiveData)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"九-tree\"><a href=\"#九-tree\" class=\"headerlink\" title=\"九.tree\"></a>九.tree</h3><h4 id=\"1-层级数据预处理d3-hierarchy\"><a href=\"#1-层级数据预处理d3-hierarchy\" class=\"headerlink\" title=\"1.层级数据预处理d3.hierarchy\"></a>1.层级数据预处理d3.hierarchy</h4><ul>\n<li>d3.hierarchy</li>\n</ul>\n<ul>\n<li>保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: </li>\n<li>height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）</li>\n</ul>\n<ul>\n<li>•d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-层级数据预处理d3-tree\"><a href=\"#2-层级数据预处理d3-tree\" class=\"headerlink\" title=\"2.层级数据预处理d3.tree()\"></a>2.层级数据预处理d3.tree()</h4><ul>\n<li><p>d3.tree().size([innerHeight, innerWidth])</p>\n</li>\n<li><p>返回一个函数</p>\n</li>\n<li><p>接受参数为d3.hierarchy</p>\n</li>\n<li><p>函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">root = d3.<span class=\"hljs-title function_\">tree</span>().<span class=\"hljs-title function_\">size</span>([innerHeight, innerWidth])(root)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-root-links-和-d3-linkHorizontal\"><a href=\"#3-root-links-和-d3-linkHorizontal\" class=\"headerlink\" title=\"3.root.links()和 d3.linkHorizontal()\"></a>3.root.links()和 d3.linkHorizontal()</h4><ul>\n<li><p>root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用</p>\n</li>\n<li><p>d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">links</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;fill&quot;</span>, <span class=\"hljs-string\">&quot;none&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke&quot;</span>, <span class=\"hljs-string\">&quot;black&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke-width&quot;</span>, <span class=\"hljs-number\">1.5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;d&quot;</span>, d3.<span class=\"hljs-title function_\">linkHorizontal</span>().<span class=\"hljs-title function_\">x</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">y</span>).<span class=\"hljs-title function_\">y</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span>));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-root-descendants\"><a href=\"#4-root-descendants\" class=\"headerlink\" title=\"4.root.descendants()\"></a>4.root.descendants()</h4><ul>\n<li>root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">descendants</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">name</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? d.<span class=\"hljs-property\">y</span> - <span class=\"hljs-number\">8</span> : d.<span class=\"hljs-property\">y</span> + <span class=\"hljs-number\">8</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span> + <span class=\"hljs-number\">5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;font-size&#x27;</span>, <span class=\"hljs-string\">&#x27;0.8em&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;text-anchor&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? <span class=\"hljs-string\">&#x27;end&#x27;</span> : <span class=\"hljs-string\">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  ​</p>\n","site":{"data":{}},"wordcount":4783,"excerpt":"","more":"<h3 id=\"一-使用d3查询svg\"><a href=\"#一-使用d3查询svg\" class=\"headerlink\" title=\"一.使用d3查询svg\"></a>一.使用d3查询svg</h3><p>d3.select()、d3.selectAll()</p>\n<h3 id=\"二-使用d3设置svg中的属性\"><a href=\"#二-使用d3设置svg中的属性\" class=\"headerlink\" title=\"二.使用d3设置svg中的属性\"></a>二.使用d3设置svg中的属性</h3><p>d3.attr()</p>\n<p>常见的属性：</p>\n<ul>\n<li>id、class</li>\n<li>x，y，cx，cy（cx、cy是圆的xy坐标）</li>\n<li>fill（颜色填充color）、stroke（边框border）</li>\n<li>height、width、r（圆的半径）</li>\n<li>transform（translate、rotate、scale）</li>\n</ul>\n<h3 id=\"三-使用d3添加、删除svg元素\"><a href=\"#三-使用d3添加、删除svg元素\" class=\"headerlink\" title=\"三.使用d3添加、删除svg元素\"></a>三.使用d3添加、删除svg元素</h3><p>element.append()、element.remove()</p>\n<h3 id=\"四-d3的比例尺\"><a href=\"#四-d3的比例尺\" class=\"headerlink\" title=\"四.d3的比例尺\"></a>四.d3的比例尺</h3><h4 id=\"1-d3-scaleLinear-：线性比例尺\"><a href=\"#1-d3-scaleLinear-：线性比例尺\" class=\"headerlink\" title=\"1.d3.scaleLinear()：线性比例尺\"></a>1.d3.scaleLinear()：线性比例尺</h4><p>domain:：连续型 range：连续型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> xScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([min_d, max_d]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>(min, max) <span class=\"hljs-comment\">// 连续型</span><br><br><span class=\"hljs-keyword\">const</span> yScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, d3.<span class=\"hljs-title function_\">max</span>(data, <span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-property\">value</span>)])<br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, innerWidth])<br></code></pre></td></tr></table></figure>\n\n<p>d3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值</p>\n<h4 id=\"2-d3-scaleBand-：序数比例尺\"><a href=\"#2-d3-scaleBand-：序数比例尺\" class=\"headerlink\" title=\"2.d3.scaleBand()：序数比例尺\"></a>2.d3.scaleBand()：序数比例尺</h4><p>domain：离散型 range：连续性</p>\n<p>可以理解为用domain将range分割</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scale_b = d3.<span class=\"hljs-title function_\">scaleBand</span>()<br>.<span class=\"hljs-title function_\">domian</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-d3-scaleOrdinal-：序数比例尺\"><a href=\"#3-d3-scaleOrdinal-：序数比例尺\" class=\"headerlink\" title=\"3.d3.scaleOrdinal()：序数比例尺\"></a>3.d3.scaleOrdinal()：序数比例尺</h4><p>domain：离散型 range：离散型</p>\n<p>可以简单理解为map映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleO = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<p>生成颜色比例尺</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>().<span class=\"hljs-title function_\">domain</span>(naiveKeys).<span class=\"hljs-title function_\">range</span>(d3.<span class=\"hljs-property\">schemeSet2</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\"><a href=\"#4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\" class=\"headerlink\" title=\"4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\"></a>4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)</h4><p>domain：连续型 range：离散型</p>\n<p>可以理解为scaleBand的逆变换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleQ = d3.<span class=\"hljs-title function_\">scaleQuantize</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-d3-scaleTime-：时间比例尺\"><a href=\"#5-d3-scaleTime-：时间比例尺\" class=\"headerlink\" title=\"5.d3.scaleTime()：时间比例尺\"></a>5.d3.scaleTime()：时间比例尺</h4><p>domain：连续型，是时间 range：连续，是刻度</p>\n<p>类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleT = d3.<span class=\"hljs-title function_\">scaleTime</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2020</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>)]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-颜色比例尺\"><a href=\"#6-颜色比例尺\" class=\"headerlink\" title=\"6.颜色比例尺\"></a>6.颜色比例尺</h4><p>d3提供了一些颜色比例尺，10就是10种颜色</p>\n<p>①Categorical系列——离散型颜色<br>d3.schemeCategory10 // 10就是10种颜色</p>\n<p><img src=\"/css/images/d3/category10.png\" alt=\"category10\"></p>\n<p>d3.schemeAccent</p>\n<p><img src=\"/css/images/d3/Accent.png\" alt=\"Accent\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义一个序数颜色比例尺</span><br><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleLinear</span>(d3.<span class=\"hljs-property\">schemeCategory10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>②Diverging——连续型颜色（渐变颜色）</p>\n<p>方式一：d3.<strong>interpolateBrBG</strong>(<em>t</em>)——t =&gt; [0, 1]</p>\n<h3 id=\"五-Data-Join\"><a href=\"#五-Data-Join\" class=\"headerlink\" title=\"五.Data Join\"></a>五.Data Join</h3><h4 id=\"1-本质上是将数据与图元进行绑定\"><a href=\"#1-本质上是将数据与图元进行绑定\" class=\"headerlink\" title=\"1.本质上是将数据与图元进行绑定\"></a>1.本质上是将数据与图元进行绑定</h4><p>d3.selectAll(.class类名).data(data)</p>\n<h4 id=\"2-d3绑定数据的三个状态\"><a href=\"#2-d3绑定数据的三个状态\" class=\"headerlink\" title=\"2.d3绑定数据的三个状态\"></a>2.d3绑定数据的三个状态</h4><p>enter:</p>\n<ul>\n<li><p>有数据没有图元</p>\n</li>\n<li><p>d3会自动搞清楚哪些数据是新增的</p>\n</li>\n<li><p>根据新增的数据生成对应的图元</p>\n</li>\n<li><p>生成图元的占位，占位的内容需要通过append添加</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">enter</span>().<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;rect&#x27;</span>).<span class=\"hljs-title function_\">attr</span>(...)<br></code></pre></td></tr></table></figure>\n<p>update:</p>\n<ul>\n<li><p>有图元有数据</p>\n</li>\n<li><p>update作为实际可视化任务最常用的状态，经常被单独封装为一个函数</p>\n</li>\n<li><p>updateSelection.merge(enterSelection).attr().attr()</p>\n<ul>\n<li>将两个selection合并到一起操作</li>\n<li>enterSelection需要至少append()图元</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(.<span class=\"hljs-property\">class</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">update</span>().<span class=\"hljs-title function_\">transition</span>().<span class=\"hljs-title function_\">durantion</span>(<span class=\"hljs-number\">3000</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;width&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> <span class=\"hljs-title function_\">xScale</span>(d.<span class=\"hljs-property\">value</span>))<br></code></pre></td></tr></table></figure>\n<p>exit</p>\n<ul>\n<li><p>有图元没数据</p>\n</li>\n<li><p>d3会自动搞清楚哪些图元是不绑定数据的</p>\n</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const p = d3.selectAll(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).data(data).<span class=\"hljs-keyword\">exit</span>().remove()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-读取数据\"><a href=\"#3-读取数据\" class=\"headerlink\" title=\"3.读取数据\"></a>3.读取数据</h4><p>d3.csv(‘path/tp/data.csv’).then(res =&gt; {})</p>\n<h3 id=\"六-path\"><a href=\"#六-path\" class=\"headerlink\" title=\"六.path\"></a>六.path</h3><h4 id=\"1-path元素的形状是通过属性d来定义的\"><a href=\"#1-path元素的形状是通过属性d来定义的\" class=\"headerlink\" title=\"1.path元素的形状是通过属性d来定义的\"></a>1.path元素的形状是通过属性d来定义的</h4><h4 id=\"2-d3-Path生成器\"><a href=\"#2-d3-Path生成器\" class=\"headerlink\" title=\"2.d3 Path生成器\"></a>2.d3 Path生成器</h4><ul>\n<li>d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5) —-用于折线图</li>\n<li>d3.geoPath().projection() —-用于地图</li>\n<li>d3.area() —-用于主题河流</li>\n<li>d3.arc().innerRadius().outerRadius() —-用于饼图</li>\n<li>d3.lineRadial().angle().radius() —-极坐标系版本的d3.line()</li>\n</ul>\n<h4 id=\"3-d3-line\"><a href=\"#3-d3-line\" class=\"headerlink\" title=\"3.d3.line()\"></a>3.d3.line()</h4><p>const line = d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5)</p>\n<p>使用line:</p>\n<p>d3.select(‘path’).datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据</p>\n<p>.attr(‘d’, line) // 给path配置line</p>\n<h3 id=\"七-interaction\"><a href=\"#七-interaction\" class=\"headerlink\" title=\"七.interaction\"></a>七.interaction</h3><h4 id=\"1-地图数据的表达-Topojson-amp-Geojson\"><a href=\"#1-地图数据的表达-Topojson-amp-Geojson\" class=\"headerlink\" title=\"1.地图数据的表达: Topojson &amp; Geojson\"></a>1.地图数据的表达: Topojson &amp; Geojson</h4><h4 id=\"2-json数据的读取\"><a href=\"#2-json数据的读取\" class=\"headerlink\" title=\"2.json数据的读取\"></a>2.json数据的读取</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">json</span>(<span class=\"hljs-string\">&#x27;path/to/data.json&#x27;</span>).<span class=\"hljs-title function_\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;… … …&#125; ) <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-topojson转geojson\"><a href=\"#3-topojson转geojson\" class=\"headerlink\" title=\"3.topojson转geojson\"></a>3.topojson转geojson</h4><p>借助topojson.js库</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">geojson = topojson.<span class=\"hljs-title function_\">feature</span>(data, data.<span class=\"hljs-property\">objects</span>.<span class=\"hljs-property\">countries</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-地图数据的可视化\"><a href=\"#4-地图数据的可视化\" class=\"headerlink\" title=\"4.地图数据的可视化\"></a>4.地图数据的可视化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> projection = d3.<span class=\"hljs-title function_\">geoNaturalEarth1</span>();<br><span class=\"hljs-keyword\">const</span> pathGenerator = d3.<span class=\"hljs-title function_\">geoPath</span>().<span class=\"hljs-title function_\">projection</span>(projection)<br><span class=\"hljs-comment\">// geo适应宽高</span><br>projection.<span class=\"hljs-title function_\">fitSize</span>([innerWidth, innerHeight], geojson);<br><span class=\"hljs-comment\">// path使用geo</span><br>g.<span class=\"hljs-title function_\">selectAll</span>(path).<span class=\"hljs-title function_\">data</span>(geojson.<span class=\"hljs-property\">features</span>).<span class=\"hljs-title function_\">join</span>()<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>,pathGenerator  )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-事件\"><a href=\"#5-事件\" class=\"headerlink\" title=\"5.事件\"></a>5.事件</h4><p>事件的设置对应于D3中的.on(‘eventName’, callBack) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  d3.<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>图元.on(事件类型, 触发动作) </p>\n<h4 id=\"6-d3-tip\"><a href=\"#6-d3-tip\" class=\"headerlink\" title=\"6.d3-tip\"></a>6.d3-tip</h4><p>tooltip库，自动在‘合适’的位置显示对话框</p>\n<h3 id=\"八-stack-堆叠\"><a href=\"#八-stack-堆叠\" class=\"headerlink\" title=\"八.stack(堆叠)\"></a>八.stack(堆叠)</h3><h4 id=\"1-d3-stack\"><a href=\"#1-d3-stack\" class=\"headerlink\" title=\"1.d3.stack()\"></a>1.d3.stack()</h4><p>本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）</p>\n<h4 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2.语法\"></a>2.语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> stackData = d3.<span class=\"hljs-title function_\">stack</span>()<br>\t.<span class=\"hljs-title function_\">keys</span>(naiveKeys) <span class=\"hljs-comment\">// 需要堆叠哪些字段的数据</span><br>\t.<span class=\"hljs-title function_\">order</span>(d3.<span class=\"hljs-property\">stackOrderNone</span>) <span class=\"hljs-comment\">// 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序</span><br>\t(naiveData)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"九-tree\"><a href=\"#九-tree\" class=\"headerlink\" title=\"九.tree\"></a>九.tree</h3><h4 id=\"1-层级数据预处理d3-hierarchy\"><a href=\"#1-层级数据预处理d3-hierarchy\" class=\"headerlink\" title=\"1.层级数据预处理d3.hierarchy\"></a>1.层级数据预处理d3.hierarchy</h4><ul>\n<li>d3.hierarchy</li>\n</ul>\n<ul>\n<li>保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: </li>\n<li>height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）</li>\n</ul>\n<ul>\n<li>•d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-层级数据预处理d3-tree\"><a href=\"#2-层级数据预处理d3-tree\" class=\"headerlink\" title=\"2.层级数据预处理d3.tree()\"></a>2.层级数据预处理d3.tree()</h4><ul>\n<li><p>d3.tree().size([innerHeight, innerWidth])</p>\n</li>\n<li><p>返回一个函数</p>\n</li>\n<li><p>接受参数为d3.hierarchy</p>\n</li>\n<li><p>函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">root = d3.<span class=\"hljs-title function_\">tree</span>().<span class=\"hljs-title function_\">size</span>([innerHeight, innerWidth])(root)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-root-links-和-d3-linkHorizontal\"><a href=\"#3-root-links-和-d3-linkHorizontal\" class=\"headerlink\" title=\"3.root.links()和 d3.linkHorizontal()\"></a>3.root.links()和 d3.linkHorizontal()</h4><ul>\n<li><p>root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用</p>\n</li>\n<li><p>d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">links</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;fill&quot;</span>, <span class=\"hljs-string\">&quot;none&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke&quot;</span>, <span class=\"hljs-string\">&quot;black&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke-width&quot;</span>, <span class=\"hljs-number\">1.5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;d&quot;</span>, d3.<span class=\"hljs-title function_\">linkHorizontal</span>().<span class=\"hljs-title function_\">x</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">y</span>).<span class=\"hljs-title function_\">y</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span>));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-root-descendants\"><a href=\"#4-root-descendants\" class=\"headerlink\" title=\"4.root.descendants()\"></a>4.root.descendants()</h4><ul>\n<li>root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">descendants</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">name</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? d.<span class=\"hljs-property\">y</span> - <span class=\"hljs-number\">8</span> : d.<span class=\"hljs-property\">y</span> + <span class=\"hljs-number\">8</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span> + <span class=\"hljs-number\">5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;font-size&#x27;</span>, <span class=\"hljs-string\">&#x27;0.8em&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;text-anchor&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? <span class=\"hljs-string\">&#x27;end&#x27;</span> : <span class=\"hljs-string\">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  ​</p>\n"},{"title":"浏览器的进程和线程","keywords":"浏览器的进程和线程","_content":"# 浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\n\n> 引用自[链接](https://juejin.cn/post/7067725869598375967#heading-0)\n\n## 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。\n\n## 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\n```js\nA = 1+2\nB = 20/5\nC = 7*8\n复制代码\n```\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n- 任务 1 是计算 A=1+2；\n- 任务 2 是计算 B=20/5；\n- 任务 3 是计算 C=7*8；\n- 任务 4 是显示最后计算的结果。\n\n正常情况下程序可以使用**单线程**来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用**多线程**，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，**使用并行处理能大大提升性能。**\n\n## 线程 VS 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。那什么又是进程呢？\n\n**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。\n\n![进程中的单线程和多线程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看到，**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率**。总结来说，进程和线程之间的关系有以下 4 个特点。\n\n**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**\n\n我们可以模拟以下场景：\n\n```js\nA = 1+2\nB = 20/0\nC = 7*8\n复制代码\n```\n\n我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n**2. 线程之间共享进程中的数据。**\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n![线程之间共享进程中的数据](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。\n\n**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n**4. 进程之间的内容相互隔离。**\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了\n\n## 单进程浏览器时代\n\n顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：\n\n![单进程浏览器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器**不稳定、不流畅和不安全**的一个主要因素。\n\n**问题 1：不稳定**\n\n早期浏览器需要借助于**插件**来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，**渲染引擎模块**也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n**问题 2：不流畅**\n\n从上面的**单进程浏览器架构示意图**可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\n```js\nfunction freeze() { \n    while (1) { \n        console.log(\"freeze\"); \n    }\n}\nfreeze();\n```\n\n如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。\n\n除了上述**脚本**或者**插件**会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。\n\n**问题 3：不安全**\n\n不安全这里依然可以从插件和页面脚本两个方面来解释该问题。\n\n插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。\n\n## 多进程浏览器时代\n\n### **早期多进程架构**\n\n2008年Chrome发布时的进程架构：\n\n![早期多进程架构](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。\n\n**我们先看看如何解决不稳定的问题**。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。\n\n**接下来再来看看不流畅的问题是如何解决的**。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n**最后再来看看上面的不安全的问题是怎么解决的**。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n### 目前多进程架构\n\n最新的Chrome进程架构图：\n\n![目前多进程架构图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。\n\n**浏览器进程**只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。\n\n**渲染进程**（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。\n\n- **GUI渲染线程**负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。\n- **Javascript引擎线程**，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。\n  - **GUI渲染线程和Javascript引擎线程是互斥的**。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。\n- **定时触发器线程**，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。\n- **事件触发线程**，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n- **异步http请求线程**，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n\n**GPU进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n**网络进程**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n**插件进程**主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响","source":"_posts/浏览器进程和线程.md","raw":"---\ntitle:  浏览器的进程和线程\ntag: 浏览器的进程和线程\nkeywords: 浏览器的进程和线程\ncategories: 浏览器相关知识\n---\n# 浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\n\n> 引用自[链接](https://juejin.cn/post/7067725869598375967#heading-0)\n\n## 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。\n\n## 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\n```js\nA = 1+2\nB = 20/5\nC = 7*8\n复制代码\n```\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n- 任务 1 是计算 A=1+2；\n- 任务 2 是计算 B=20/5；\n- 任务 3 是计算 C=7*8；\n- 任务 4 是显示最后计算的结果。\n\n正常情况下程序可以使用**单线程**来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用**多线程**，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，**使用并行处理能大大提升性能。**\n\n## 线程 VS 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。那什么又是进程呢？\n\n**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。\n\n![进程中的单线程和多线程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看到，**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率**。总结来说，进程和线程之间的关系有以下 4 个特点。\n\n**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**\n\n我们可以模拟以下场景：\n\n```js\nA = 1+2\nB = 20/0\nC = 7*8\n复制代码\n```\n\n我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n**2. 线程之间共享进程中的数据。**\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n![线程之间共享进程中的数据](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。\n\n**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n**4. 进程之间的内容相互隔离。**\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了\n\n## 单进程浏览器时代\n\n顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：\n\n![单进程浏览器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器**不稳定、不流畅和不安全**的一个主要因素。\n\n**问题 1：不稳定**\n\n早期浏览器需要借助于**插件**来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，**渲染引擎模块**也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n**问题 2：不流畅**\n\n从上面的**单进程浏览器架构示意图**可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\n```js\nfunction freeze() { \n    while (1) { \n        console.log(\"freeze\"); \n    }\n}\nfreeze();\n```\n\n如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。\n\n除了上述**脚本**或者**插件**会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。\n\n**问题 3：不安全**\n\n不安全这里依然可以从插件和页面脚本两个方面来解释该问题。\n\n插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。\n\n## 多进程浏览器时代\n\n### **早期多进程架构**\n\n2008年Chrome发布时的进程架构：\n\n![早期多进程架构](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。\n\n**我们先看看如何解决不稳定的问题**。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。\n\n**接下来再来看看不流畅的问题是如何解决的**。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n**最后再来看看上面的不安全的问题是怎么解决的**。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n### 目前多进程架构\n\n最新的Chrome进程架构图：\n\n![目前多进程架构图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。\n\n**浏览器进程**只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。\n\n**渲染进程**（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。\n\n- **GUI渲染线程**负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。\n- **Javascript引擎线程**，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。\n  - **GUI渲染线程和Javascript引擎线程是互斥的**。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。\n- **定时触发器线程**，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。\n- **事件触发线程**，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n- **异步http请求线程**，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n\n**GPU进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n**网络进程**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n**插件进程**主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响","slug":"浏览器进程和线程","published":1,"date":"2022-03-23T12:29:43.861Z","updated":"2022-03-23T14:44:36.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinr000f18uq4hnv8sot","content":"<h1 id=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"><a href=\"#浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\" class=\"headerlink\" title=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"></a>浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）</h1><blockquote>\n<p>引用自<a href=\"https://juejin.cn/post/7067725869598375967#heading-0\">链接</a></p>\n</blockquote>\n<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h2 id=\"什么是并行处理\"><a href=\"#什么是并行处理\" class=\"headerlink\" title=\"什么是并行处理\"></a>什么是并行处理</h2><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">5</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果。</li>\n</ul>\n<p>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，<strong>使用并行处理能大大提升性能。</strong></p>\n<h2 id=\"线程-VS-进程\"><a href=\"#线程-VS-进程\" class=\"headerlink\" title=\"线程 VS 进程\"></a>线程 VS 进程</h2><p>多线程可以并行处理任务，但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong>。那什么又是进程呢？</p>\n<p><strong>一个进程就是一个程序的运行实例</strong>。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"进程中的单线程和多线程\"></p>\n<p>从图中可以看到，<strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong>。总结来说，进程和线程之间的关系有以下 4 个特点。</p>\n<p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>\n<p>我们可以模拟以下场景：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">0</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。</p>\n<p><strong>2. 线程之间共享进程中的数据。</strong></p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"线程之间共享进程中的数据\"></p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n<p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n<p><strong>4. 进程之间的内容相互隔离。</strong></p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了</p>\n<h2 id=\"单进程浏览器时代\"><a href=\"#单进程浏览器时代\" class=\"headerlink\" title=\"单进程浏览器时代\"></a>单进程浏览器时代</h2><p>顾名思义，<strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"单进程浏览器\"></p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p>\n<p><strong>问题 1：不稳定</strong></p>\n<p>早期浏览器需要借助于<strong>插件</strong>来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，<strong>渲染引擎模块</strong>也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<p><strong>问题 2：不流畅</strong></p>\n<p>从上面的<strong>单进程浏览器架构示意图</strong>可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">freeze</span>(<span class=\"hljs-params\"></span>) &#123; <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123; <br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;freeze&quot;</span>); <br>    &#125;<br>&#125;<br><span class=\"hljs-title function_\">freeze</span>();<br></code></pre></td></tr></table></figure>\n\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p>\n<p>除了上述<strong>脚本</strong>或者<strong>插件</strong>会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<p><strong>问题 3：不安全</strong></p>\n<p>不安全这里依然可以从插件和页面脚本两个方面来解释该问题。</p>\n<p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。</p>\n<h2 id=\"多进程浏览器时代\"><a href=\"#多进程浏览器时代\" class=\"headerlink\" title=\"多进程浏览器时代\"></a>多进程浏览器时代</h2><h3 id=\"早期多进程架构\"><a href=\"#早期多进程架构\" class=\"headerlink\" title=\"早期多进程架构\"></a><strong>早期多进程架构</strong></h3><p>2008年Chrome发布时的进程架构：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"早期多进程架构\"></p>\n<p>从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后再来看看上面的不安全的问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<h3 id=\"目前多进程架构\"><a href=\"#目前多进程架构\" class=\"headerlink\" title=\"目前多进程架构\"></a>目前多进程架构</h3><p>最新的Chrome进程架构图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"目前多进程架构图\"></p>\n<p>从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。</p>\n<p><strong>浏览器进程</strong>只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。</p>\n<p><strong>渲染进程</strong>（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。</p>\n<ul>\n<li><strong>GUI渲染线程</strong>负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。</li>\n<li><strong>Javascript引擎线程</strong>，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。<ul>\n<li><strong>GUI渲染线程和Javascript引擎线程是互斥的</strong>。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</li>\n</ul>\n</li>\n<li><strong>定时触发器线程</strong>，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。</li>\n<li><strong>事件触发线程</strong>，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。</li>\n<li><strong>异步http请求线程</strong>，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</li>\n</ul>\n<p><strong>GPU进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n<p><strong>网络进程</strong>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n<p><strong>插件进程</strong>主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p>\n","site":{"data":{}},"wordcount":4281,"excerpt":"","more":"<h1 id=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"><a href=\"#浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\" class=\"headerlink\" title=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"></a>浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）</h1><blockquote>\n<p>引用自<a href=\"https://juejin.cn/post/7067725869598375967#heading-0\">链接</a></p>\n</blockquote>\n<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h2 id=\"什么是并行处理\"><a href=\"#什么是并行处理\" class=\"headerlink\" title=\"什么是并行处理\"></a>什么是并行处理</h2><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">5</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果。</li>\n</ul>\n<p>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，<strong>使用并行处理能大大提升性能。</strong></p>\n<h2 id=\"线程-VS-进程\"><a href=\"#线程-VS-进程\" class=\"headerlink\" title=\"线程 VS 进程\"></a>线程 VS 进程</h2><p>多线程可以并行处理任务，但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong>。那什么又是进程呢？</p>\n<p><strong>一个进程就是一个程序的运行实例</strong>。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"进程中的单线程和多线程\"></p>\n<p>从图中可以看到，<strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong>。总结来说，进程和线程之间的关系有以下 4 个特点。</p>\n<p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>\n<p>我们可以模拟以下场景：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">0</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。</p>\n<p><strong>2. 线程之间共享进程中的数据。</strong></p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"线程之间共享进程中的数据\"></p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n<p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n<p><strong>4. 进程之间的内容相互隔离。</strong></p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了</p>\n<h2 id=\"单进程浏览器时代\"><a href=\"#单进程浏览器时代\" class=\"headerlink\" title=\"单进程浏览器时代\"></a>单进程浏览器时代</h2><p>顾名思义，<strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"单进程浏览器\"></p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p>\n<p><strong>问题 1：不稳定</strong></p>\n<p>早期浏览器需要借助于<strong>插件</strong>来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，<strong>渲染引擎模块</strong>也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<p><strong>问题 2：不流畅</strong></p>\n<p>从上面的<strong>单进程浏览器架构示意图</strong>可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">freeze</span>(<span class=\"hljs-params\"></span>) &#123; <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123; <br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;freeze&quot;</span>); <br>    &#125;<br>&#125;<br><span class=\"hljs-title function_\">freeze</span>();<br></code></pre></td></tr></table></figure>\n\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p>\n<p>除了上述<strong>脚本</strong>或者<strong>插件</strong>会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<p><strong>问题 3：不安全</strong></p>\n<p>不安全这里依然可以从插件和页面脚本两个方面来解释该问题。</p>\n<p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。</p>\n<h2 id=\"多进程浏览器时代\"><a href=\"#多进程浏览器时代\" class=\"headerlink\" title=\"多进程浏览器时代\"></a>多进程浏览器时代</h2><h3 id=\"早期多进程架构\"><a href=\"#早期多进程架构\" class=\"headerlink\" title=\"早期多进程架构\"></a><strong>早期多进程架构</strong></h3><p>2008年Chrome发布时的进程架构：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"早期多进程架构\"></p>\n<p>从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后再来看看上面的不安全的问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<h3 id=\"目前多进程架构\"><a href=\"#目前多进程架构\" class=\"headerlink\" title=\"目前多进程架构\"></a>目前多进程架构</h3><p>最新的Chrome进程架构图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"目前多进程架构图\"></p>\n<p>从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。</p>\n<p><strong>浏览器进程</strong>只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。</p>\n<p><strong>渲染进程</strong>（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。</p>\n<ul>\n<li><strong>GUI渲染线程</strong>负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。</li>\n<li><strong>Javascript引擎线程</strong>，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。<ul>\n<li><strong>GUI渲染线程和Javascript引擎线程是互斥的</strong>。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</li>\n</ul>\n</li>\n<li><strong>定时触发器线程</strong>，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。</li>\n<li><strong>事件触发线程</strong>，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。</li>\n<li><strong>异步http请求线程</strong>，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</li>\n</ul>\n<p><strong>GPU进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n<p><strong>网络进程</strong>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n<p><strong>插件进程</strong>主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p>\n"},{"title":"svg相关笔记","keywords":"svg","_content":"## 一、入门指南\n\n### 1. 图形系统\n\n计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。\n\n### 2. SVG(Scalable Vector Graphics)\n\nSVG` 是一种 `XML` 应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的 `XML` 和 `SVG` 版本都为 `1.1\n\nSVG文档结构是标准的 `XML` 文档，根元素 `svg` 定义图形的大小，根元素中包含各种的形状元素。`SVG` 允许使用单独的属性指定元素的样式。\n\n`SVG` 使用 `g` 元素对图形进行分组，使用 `use` 元素实现元素的复用。\n\n## 二、在网页中使用\n\n### 1. 将SVG作为图像\n\n将 `svg` 作为图像包含在HTML标记的 `img` 元素内，但是这样有一定的局限性：\n\n**`SVG`转为栅格图像时与主页面分离，并且无法在两者之间通信( `SVG` 渲染过程与主页面独立)。主页面上的样式对 `SVG` 无效，运行在主页面上的脚本无法感知或者修改 `SVG` 文档结构。**\n\n在 `CSS` 中包含 `SVG`，最常用的是 `background-image` 属性，应该避免 `SVG` 元素文件太大。\n\n###  2. 将SVG作为应用程序\n\n使用 `object` 元素将 `SVG` 嵌入 `HTML` 文档中，`object`元素的 `type` 属性表示要嵌入的文档类型，对用 `SVG` 应该是`type=\"image/svg+xml\"`。`object` 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。\n\n## 三、坐标系统\n\n###  1. 视口\n\n视口是指文档打算使用的画布区域。在 `svg` 元素上使用 `width` 和 `height` 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为`em`、`ex`、`px`、`pt`、`pc`、`cm`、`mm` 和 `in`)也可以为百分比。\n\n### 2. 默认用户坐标\n\n`SVG` 阅读器会设置一个坐标系统，即原点 `(0,0)` 位于视口的左上角，`x` 向右递增，`y` 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。\n\n在 `SVG` 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 `SVG` 文档中各个元素的单位可以不统一。\n\n### 3. 指定用户坐标\n\n摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 `svg` 元素上设置 `viewBox` 属性。\n\n`viewBox` 属性由 `4` 个数值组成，分别代表要叠加在视口上的最小 `x`、最小 `y`，宽度、高度。\n\n既然可以对 `svg` 自定义用户坐标，那么肯定要解决 `svg` 视口长宽比例和 `viewBox` 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 `preserveAspectRatio` 属性了。\n\n如果 `viewBox` 的长宽比例与视口的长宽比例不同，那么 `svg` 可以有以下三种选择：\n\n- 按较小的尺寸等比例缩放图形，使图形完全填充视口\n- 按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分\n- 拉伸和压缩绘图以使其恰好填充视口\n\n```\npreserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = \"alignment[meet|slice]\"\n```\n\n默认值为 `\"xMidYMid meet\"`\n\n`alignment`指定轴和位置，`x` 和 `y` 方向都有 `min`, `mid`, `max` 三种方式，分别表示 `x` 和 `y` 方向的对齐方式，对齐方式由 `x` 和 `y` 组合指定，共 `9` 中方式，也就是 `alignment` 共有如下 `9` 个取值：\n\n| y\\x      | xMin     | xMid     | xMax     |\n| -------- | -------- | -------- | -------- |\n| **yMin** | xMinYMin | xMidYMin | xMaxYMin |\n| **yMid** | xMinYMid | xMidYMid | xMaxYMid |\n| **yMax** | xMinYMax | xMidYMax | xMaxYMax |\n\n`meet` 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间\n\n`slice` 说明符直接裁剪超出视口的部分\n\n除了上述操作之外，还可以指定 `preserveAspectRatio=\"none\"`，用于在 `viewBox` 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。\n\n### 4. 嵌套坐标系统\n\n可以将另一个 `svg` 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 `svg` 中可以嵌套另一个 `svg`，每个 `svg` 都有自己独立的视口和坐标系统\n\n## 四、基本形状\n\n###  1. 线段\n\n`line` 元素，使用 `x1`, `y1`, `x2`, `y2` 属性指定线段的起止点坐标。有如下特性:\n\n| 特性               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `stroke-width`     | 笔画宽度，坐标网格线位于笔画的正中间，可以使用 `css` 的 `shape-rendering` 值来控制反锯齿特性 |\n| `stroke`           | 笔画颜色                                                     |\n| `stroke-opacity`   | 线条的不透明度                                               |\n| `stroke-dasharray` | 虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙... |\n\n### 2. 矩形\n\n`rect`元素，使用`x`,`y`,`width`,`height`表示一个矩形\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内 |\n| `rx`/`ry`      | 圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值 |\n\n### 3. 圆和椭圆\n\n`circle` 元素表示圆,由 `cx`,`cy`,`r` 属性界定 `ellipse` 元素表示椭圆,由 `cx`,`cy`,`rx`,`ry` 界定\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内 |\n\n### 4. 多边形\n\n`polygon` 元素指定一个多边形,由 `points` 属性指定的一系列坐标点界定，会自动封闭\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度                                                     |\n| `fill-rule`    | 填充规则，如果多边形的边有交叉时，需要指定，可以取 `mozero`(默认)和 `evenodd` 两个值。 |\n\n`fill-rule` 值为 `nonzero` 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 `1`，如果是从左往右则总数减 `1`. 如果最后总数为 `0` 则认为改点在图形外部，否则在内部。\n\n`fill-rule` 值为 `evenodd` 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。\n\n### 5. 折线\n\n`polyline` 元素表示一个折线，使用 `points` 属性指定一系列点，不自动封闭图形。\n\n### 6. 特性总结\n\n| 特性                | 说明                                               |\n| ------------------- | -------------------------------------------------- |\n| `stroke`            | 笔画颜色                                           |\n| `stroke-width`      | 笔画宽度                                           |\n| `stroke-opacity`    | 笔画不透明度                                       |\n| `stroke-dasharray`  | 虚线笔画                                           |\n| `stroke-linecap`    | 笔画头的形状 `butt`(默认),`round`,`square`         |\n| `stroke-linejoin`   | 图形棱角，有`miter`(默认),`round`和`bevel`三个取值 |\n| `stroke-miterlimit` | 相交处显示宽度与线宽的最大比例，默认为`4`          |\n| `fill`              | 填充颜色 默认`black`                               |\n| `fill-opacity`      | 填充不透明度                                       |\n| `fill-rule`         | 填充规则                                           |\n\n## 五、文档结构\n\n### 1. 结构和表现\n\n`SVG` 允许文档表现和文档结构分离，`SVG` 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性\n\n| 表现方式   | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 内联样式   | 元素内部使用 `style` 属性                                    |\n| 内部样式表 | 内部样式定义在 `defs` 元素内部                               |\n| 外部样式表 | 与 `html` 类似，将样式定义在 `css` 文件中，使用选择器来设置相应的元素样式 |\n| 表现属性   | `SVG` 允许以属性的形式指定表现样式，但是**表现属性的优先级最低**，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式 |\n\n内部样式表示例：\n\n```xml\n<svg width=\"200px\" height=\"200px\" xmlns=\"http://www.w3.org/2000/svg>\n    <defs>\n        <style type=\"text/css\"><![CDATA[\n            circle{\n                fill:#ccc\n            }\n        ]]></style>\n    </defs>\n    <circle cx=\"10\" cy=\"10\" r=\"5\"/>\n</svg>\n```\n\n### 2. 分组和引用\n\n`g` 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。\n\n`use` 元素用来复用图形中重复出现的元素，需要为 `use` 标签的 `xlink:href` 指定 `URI` 来引用指定的图形元素。同时还要指定`x`和`y`属性以表示组合应该移动到哪个位置。`use`元素并不限制只能使用同一个文件内的对象，`xlink:href`属性可以指定任何有效的文件或`URI`。\n\n`defs`元素用来定义复用的元素，但是定义在`defs`内的元素并不会被显示，而是作为模板供其他地方使用。\n\n`symbol`元素与g元素不同，`symbol`永远不会被显示，也可以用来指定被后续使用的元素，`symbol`元素可以指定 `viewBox` 和`preserveAspectRatio` 属性。在引用时通过为 `use` 元素指定 `width` 和 `height` 属性就可以让 `symbol` 元素适配视口大小。\n\n`image` 可以用来包含一个完整的 `SVG` 或栅格文件。如果包含一个 `SVG` 文件，则视口会基于引用的文件的 `x`,`y`,`width`,`height` 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。\n\n`SVG`规范要求 `SVG` 阅读器支持 `JPEG` 和 `PNG` 两种栅格文件。\n\n## 六、坐标系统变换\n\n### 1. translate变换\n\n`translate` 变换用来对用户坐标进行平移，通过制定 `transform` 属性值来设置: `transform = \"translate(x,y)\"`。\n\n`translate` 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。\n\n### 2. scale变换\n\n缩放坐标系统。`transform = \"scale(value)\"` 或者 `transform=\"scale(x-value,y-value)\"`。\n\n仅仅使用 `scale(n)` 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 `n` 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。\n\n*技巧：如果从其他系统传输数据到 `SVG`，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，`y`向上递增，`x`向右递增。而 `SVG` 坐标原点位于左上角，此时使用 `scale(1,-1)` 就可以完成两者之间的转换。*\n\n**缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。**\n\n### 3. rotate变换\n\n根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，`0` 度为 `3` 点钟方向。\n\n注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： `translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)`\n\n但是有个更简单的方式：`rotate(angle,centerX,centerY)`\n\n### 4. 围绕中心点缩放\n\n上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：\n\n```\ntranslate(-centerX*(factor-1),-centerY*(factor-1)) scale(factor)\n```\n\n### 5. skewX和skewY变换\n\n这两个变换用来倾斜某个轴，一般形式为 `skewX(angle),skewY(angle)`。这样的结果就是使得 `x` 轴和 `y` 轴不再垂直。\n\n### 6. 矩阵变换\n\n计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 `matrix(a,b,c,d,e,f)`，此时指定的变换矩阵为:\n\n```text\na  c  e\nb  d  f\n0  0  1\n```\n\n## 七、路径\n\n### 1. path命令\n\n`SVG` 中所有基本形状都是 `path` 的简写形式，但是建议使用简写形式，因为这样可以使 `SVG` 文档更可读。\n\n`path` 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。\n\n下表为 `path` 命令总结，其中大写表示绝对坐标，小写表示相对坐标：\n\n| 命令    | 参数                                        | 说明                                                         |\n| ------- | ------------------------------------------- | ------------------------------------------------------------ |\n| `M` `m` | `x y`                                       | 移动画笔到制定坐标                                           |\n| `L` `l` | `x y`                                       | 绘制一条到给定坐标的线                                       |\n| `H` `h` | `x`                                         | 绘制一条到给定 `x` 坐标的横线                                |\n| `V` `v` | `y`                                         | 绘制一条到给定`y`坐标的垂线                                  |\n| `A` `a` | `rx ry x-axis-rotation large-arc sweep x y` | 圆弧曲线命令有7个参数，依次表示`x`方向半径、`y`方向半径、旋转角度、大圆标识、顺逆时针标识、目标点`x`、目标点`y`。大圆标识和顺逆时针以`0`和`1`表示。`0`表示小圆、逆时针 |\n| `Q` `q` | `x1 y1 x y`                                 | 绘制一条从当前点到`x, y`控制点为`x1, y1`的二次贝塞尔曲线     |\n| `T` `t` | `x y`                                       | 绘制一条从当前点到`x`,`y`的光滑二次贝塞尔曲线，控制点为前一个`Q`命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。 |\n| `C` `c` | `x1 y1 x2 y2 x y`                           | 绘制一条从当前点到 `x`,`y`控制点为`x1,y1` `x2,y2`的三次贝塞尔曲线 |\n| `S` `s` | `x2 y2 x y`                                 | 绘制一条从当前点到`x,y`的光滑三次贝塞尔曲线。第一个控制点为前一个`C`命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。 |\n\n路径的填充同样可以使用 `fill-rule` 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。\n\n## 八、渐变\n\n### 1. 线性渐变\n\n线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。\n\n线性渐变使用`linearGradient`元素表示：\n\n```xml\n<defs>\n\t<linearGradient id=\"linear\">\n\t\t<stop offset=\"0%\" style=\"stop-color:#ffcc00;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#0099cc;\"></stop>\n\t</linearGradient>\n</defs>\n\t<rect x=\"20\" y=\"20\" width=\"200\" height=\"100\" style=\"fill:url(#linear);stroke:black;\"></rect>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg)\n\n`stop`元素有两个必要属性：`offset`和`stop-color`。`offset`属性用来指定在哪个点的颜色应该等于`stop-color`。`offset`的取值范围0%-100%。\n\n`stop`元素的属性：\n\n| 属性           | 说明                             |\n| -------------- | -------------------------------- |\n| `offset`       | 必需，取值范围 `0%-100%`         |\n| `stop-color`   | 必需，对应 `offset` 位置点的颜色 |\n| `stop-opacity` | 对应 `offset` 位置点的不透明度   |\n\n`linearGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `x1`,`y1`      | 渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右     |\n| `x2`,`y2`      | 渐变的终点位置，使用百分比表示                               |\n| `spreadMethod` | 如果设置的`offset`不能覆盖整个对象，该怎么填充。`pad`: 起点或终点颜色会扩展到对象边缘。`repeat`: 渐变重复起点到终点的过程。`reflect`: 渐变按终点-起点-终点的排列重复。 |\n\n### 2. 径向渐变\n\n径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。\n\n```xml\n<defs>\n\t<radialGradient id=\"radial\" cx=\"50%\" cy=\"50%\" >\n\t\t<stop offset=\"0%\" style=\"stop-color:#f00;\"></stop>\n\t\t<stop offset=\"50%\" style=\"stop-color:#0f0;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#00f;\"></stop>\n\t</radialGradient>\n</defs>\n<rect x=\"20\" y=\"20\" width=\"200\" height=\"200\" style=\"fill:url(#radial);stroke:black;\"></rect>\t\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg)\n\n`radialGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `cx`,`cy`,`r`  | 定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为`50%` |\n| `fx`,`fy`      | `0%`点所处的圆路径的圆心，默认和`cx`,`cy`一样                |\n| `spreadMethod` | `pad`,`repeat`,`reflect` 三个值，用来解决绘制范围没有到达图形边缘的情况。 |\n\n## 九、文本\n\n### 1. 相关术语\n\n| 术语                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 字符                  | `XML`中，字符是指带有一个数字值得一个或多个字节，数字值与`Unidode`标准对应 |\n| 符号                  | 字符的视觉呈现。每个字符可以有多种视觉呈现                   |\n| 字体                  | 代表某个字符集合的一组符号                                   |\n| 基线                  | 字体中所有符号以基线对齐                                     |\n| 上坡度                | 基线到字体中最高字符的顶部距离                               |\n| 下坡度                | 基线到最深字符底部的距离                                     |\n| 大写字母高度、`x`高度 | 大写字母高度是指基线上大写字母的高度，`x`高度是基线到小写字母`x`顶部的高度 |\n\n### 2. 文本元素的基本属性\n\n`text` 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。\n\n| 属性              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| `font-family`     | 以空格分割的一系列字体名称或通用字体名称                     |\n| `font-size`       | 如果有多行文本，则 `font-size` 为平行的两条基线的距离        |\n| `font-weight`     | 两个值：`bold`(粗体)和`nromal`(默认)                         |\n| `font-style`      | 常用的两个值:`italic`(斜体)和`normal`                        |\n| `text-decoration` | 可能的值:`none`,`underline`(下划线),`overline`(上划线),`line-through`(删除线) |\n| `word-spacing`    | 单词之间的距离                                               |\n| `letter-spacing`  | 字母之间的间距                                               |\n| `text-anchor`     | 对齐方式：`start`,`middle`,`end`                             |\n| `textLength`      | 设置文本的长度                                               |\n| `lengthAdjust`    | 在指定了`textLength`时，可以通过`lengthAdjust`属性设置字符的调整方式，值为 `spacing`(默认)时,只调整字符的间距。当值为`spacingAndGlyphs`时，同时调整字符间距和字符本身的大小 |\n\n### 3. tspan元素\n\n`text` 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入`tspan` 元素。`tspan` 元素与`html`的`span`元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。\n\n`tspan`元素除大小，颜色等表现样式之外，还可以设置以下属性：\n\n| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `dx`,`dy`        | `x`和`y`方向的偏移                                           |\n| `x`,`y`          | 对`tspan`进行绝对定位                                        |\n| `rotate`         | 旋转字符，可以同时设置多个值，这些值会依次作用在`tspan`包裹的字母上 |\n| `baseline-shift` | 与`dy`属性设置上下标相比，这个属性更方便，当为`super`时，会上标。`sub` 时为下标。仅仅在所在的`tspan`内有效 |\n\n### 4. 纵向文本\n\n文本一般从左到右排列，如果需要上下排列，则需要使用`writing-mode`属性。\n\n设置`writing-mode`属性值为`tb`(top to bottom)，可以将文本上下排列。\n\n## 5. 文本路径\n\n如果要使得文本沿着某条路径排列，则需要使用`textPath`元素。需要将文本放在`textPath`元素内部，然后使用`textPath`元素的`xlink:href`属性引用一个定义好的`path`元素。\n\n```xml\n<defs>\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n</defs>\n<g transform=\"translate(10,50)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n<g transform=\"translate(10,100)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\" startOffset=\"50%\" text-anchor=\"middle\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg)\n\n`startOffset`属性用来指定文本的起点，当设置为`50%`，并且设置`text-anchor`为`middle`时，文本会被定为在`path`的中间。","source":"_posts/svg.md","raw":"---\ntitle: svg相关笔记\ntag: svg\nkeywords: svg\ncategories: 前端可视化库\n---\n## 一、入门指南\n\n### 1. 图形系统\n\n计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。\n\n### 2. SVG(Scalable Vector Graphics)\n\nSVG` 是一种 `XML` 应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的 `XML` 和 `SVG` 版本都为 `1.1\n\nSVG文档结构是标准的 `XML` 文档，根元素 `svg` 定义图形的大小，根元素中包含各种的形状元素。`SVG` 允许使用单独的属性指定元素的样式。\n\n`SVG` 使用 `g` 元素对图形进行分组，使用 `use` 元素实现元素的复用。\n\n## 二、在网页中使用\n\n### 1. 将SVG作为图像\n\n将 `svg` 作为图像包含在HTML标记的 `img` 元素内，但是这样有一定的局限性：\n\n**`SVG`转为栅格图像时与主页面分离，并且无法在两者之间通信( `SVG` 渲染过程与主页面独立)。主页面上的样式对 `SVG` 无效，运行在主页面上的脚本无法感知或者修改 `SVG` 文档结构。**\n\n在 `CSS` 中包含 `SVG`，最常用的是 `background-image` 属性，应该避免 `SVG` 元素文件太大。\n\n###  2. 将SVG作为应用程序\n\n使用 `object` 元素将 `SVG` 嵌入 `HTML` 文档中，`object`元素的 `type` 属性表示要嵌入的文档类型，对用 `SVG` 应该是`type=\"image/svg+xml\"`。`object` 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。\n\n## 三、坐标系统\n\n###  1. 视口\n\n视口是指文档打算使用的画布区域。在 `svg` 元素上使用 `width` 和 `height` 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为`em`、`ex`、`px`、`pt`、`pc`、`cm`、`mm` 和 `in`)也可以为百分比。\n\n### 2. 默认用户坐标\n\n`SVG` 阅读器会设置一个坐标系统，即原点 `(0,0)` 位于视口的左上角，`x` 向右递增，`y` 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。\n\n在 `SVG` 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 `SVG` 文档中各个元素的单位可以不统一。\n\n### 3. 指定用户坐标\n\n摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 `svg` 元素上设置 `viewBox` 属性。\n\n`viewBox` 属性由 `4` 个数值组成，分别代表要叠加在视口上的最小 `x`、最小 `y`，宽度、高度。\n\n既然可以对 `svg` 自定义用户坐标，那么肯定要解决 `svg` 视口长宽比例和 `viewBox` 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 `preserveAspectRatio` 属性了。\n\n如果 `viewBox` 的长宽比例与视口的长宽比例不同，那么 `svg` 可以有以下三种选择：\n\n- 按较小的尺寸等比例缩放图形，使图形完全填充视口\n- 按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分\n- 拉伸和压缩绘图以使其恰好填充视口\n\n```\npreserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = \"alignment[meet|slice]\"\n```\n\n默认值为 `\"xMidYMid meet\"`\n\n`alignment`指定轴和位置，`x` 和 `y` 方向都有 `min`, `mid`, `max` 三种方式，分别表示 `x` 和 `y` 方向的对齐方式，对齐方式由 `x` 和 `y` 组合指定，共 `9` 中方式，也就是 `alignment` 共有如下 `9` 个取值：\n\n| y\\x      | xMin     | xMid     | xMax     |\n| -------- | -------- | -------- | -------- |\n| **yMin** | xMinYMin | xMidYMin | xMaxYMin |\n| **yMid** | xMinYMid | xMidYMid | xMaxYMid |\n| **yMax** | xMinYMax | xMidYMax | xMaxYMax |\n\n`meet` 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间\n\n`slice` 说明符直接裁剪超出视口的部分\n\n除了上述操作之外，还可以指定 `preserveAspectRatio=\"none\"`，用于在 `viewBox` 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。\n\n### 4. 嵌套坐标系统\n\n可以将另一个 `svg` 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 `svg` 中可以嵌套另一个 `svg`，每个 `svg` 都有自己独立的视口和坐标系统\n\n## 四、基本形状\n\n###  1. 线段\n\n`line` 元素，使用 `x1`, `y1`, `x2`, `y2` 属性指定线段的起止点坐标。有如下特性:\n\n| 特性               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `stroke-width`     | 笔画宽度，坐标网格线位于笔画的正中间，可以使用 `css` 的 `shape-rendering` 值来控制反锯齿特性 |\n| `stroke`           | 笔画颜色                                                     |\n| `stroke-opacity`   | 线条的不透明度                                               |\n| `stroke-dasharray` | 虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙... |\n\n### 2. 矩形\n\n`rect`元素，使用`x`,`y`,`width`,`height`表示一个矩形\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内 |\n| `rx`/`ry`      | 圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值 |\n\n### 3. 圆和椭圆\n\n`circle` 元素表示圆,由 `cx`,`cy`,`r` 属性界定 `ellipse` 元素表示椭圆,由 `cx`,`cy`,`rx`,`ry` 界定\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内 |\n\n### 4. 多边形\n\n`polygon` 元素指定一个多边形,由 `points` 属性指定的一系列坐标点界定，会自动封闭\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度                                                     |\n| `fill-rule`    | 填充规则，如果多边形的边有交叉时，需要指定，可以取 `mozero`(默认)和 `evenodd` 两个值。 |\n\n`fill-rule` 值为 `nonzero` 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 `1`，如果是从左往右则总数减 `1`. 如果最后总数为 `0` 则认为改点在图形外部，否则在内部。\n\n`fill-rule` 值为 `evenodd` 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。\n\n### 5. 折线\n\n`polyline` 元素表示一个折线，使用 `points` 属性指定一系列点，不自动封闭图形。\n\n### 6. 特性总结\n\n| 特性                | 说明                                               |\n| ------------------- | -------------------------------------------------- |\n| `stroke`            | 笔画颜色                                           |\n| `stroke-width`      | 笔画宽度                                           |\n| `stroke-opacity`    | 笔画不透明度                                       |\n| `stroke-dasharray`  | 虚线笔画                                           |\n| `stroke-linecap`    | 笔画头的形状 `butt`(默认),`round`,`square`         |\n| `stroke-linejoin`   | 图形棱角，有`miter`(默认),`round`和`bevel`三个取值 |\n| `stroke-miterlimit` | 相交处显示宽度与线宽的最大比例，默认为`4`          |\n| `fill`              | 填充颜色 默认`black`                               |\n| `fill-opacity`      | 填充不透明度                                       |\n| `fill-rule`         | 填充规则                                           |\n\n## 五、文档结构\n\n### 1. 结构和表现\n\n`SVG` 允许文档表现和文档结构分离，`SVG` 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性\n\n| 表现方式   | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 内联样式   | 元素内部使用 `style` 属性                                    |\n| 内部样式表 | 内部样式定义在 `defs` 元素内部                               |\n| 外部样式表 | 与 `html` 类似，将样式定义在 `css` 文件中，使用选择器来设置相应的元素样式 |\n| 表现属性   | `SVG` 允许以属性的形式指定表现样式，但是**表现属性的优先级最低**，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式 |\n\n内部样式表示例：\n\n```xml\n<svg width=\"200px\" height=\"200px\" xmlns=\"http://www.w3.org/2000/svg>\n    <defs>\n        <style type=\"text/css\"><![CDATA[\n            circle{\n                fill:#ccc\n            }\n        ]]></style>\n    </defs>\n    <circle cx=\"10\" cy=\"10\" r=\"5\"/>\n</svg>\n```\n\n### 2. 分组和引用\n\n`g` 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。\n\n`use` 元素用来复用图形中重复出现的元素，需要为 `use` 标签的 `xlink:href` 指定 `URI` 来引用指定的图形元素。同时还要指定`x`和`y`属性以表示组合应该移动到哪个位置。`use`元素并不限制只能使用同一个文件内的对象，`xlink:href`属性可以指定任何有效的文件或`URI`。\n\n`defs`元素用来定义复用的元素，但是定义在`defs`内的元素并不会被显示，而是作为模板供其他地方使用。\n\n`symbol`元素与g元素不同，`symbol`永远不会被显示，也可以用来指定被后续使用的元素，`symbol`元素可以指定 `viewBox` 和`preserveAspectRatio` 属性。在引用时通过为 `use` 元素指定 `width` 和 `height` 属性就可以让 `symbol` 元素适配视口大小。\n\n`image` 可以用来包含一个完整的 `SVG` 或栅格文件。如果包含一个 `SVG` 文件，则视口会基于引用的文件的 `x`,`y`,`width`,`height` 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。\n\n`SVG`规范要求 `SVG` 阅读器支持 `JPEG` 和 `PNG` 两种栅格文件。\n\n## 六、坐标系统变换\n\n### 1. translate变换\n\n`translate` 变换用来对用户坐标进行平移，通过制定 `transform` 属性值来设置: `transform = \"translate(x,y)\"`。\n\n`translate` 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。\n\n### 2. scale变换\n\n缩放坐标系统。`transform = \"scale(value)\"` 或者 `transform=\"scale(x-value,y-value)\"`。\n\n仅仅使用 `scale(n)` 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 `n` 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。\n\n*技巧：如果从其他系统传输数据到 `SVG`，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，`y`向上递增，`x`向右递增。而 `SVG` 坐标原点位于左上角，此时使用 `scale(1,-1)` 就可以完成两者之间的转换。*\n\n**缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。**\n\n### 3. rotate变换\n\n根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，`0` 度为 `3` 点钟方向。\n\n注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： `translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)`\n\n但是有个更简单的方式：`rotate(angle,centerX,centerY)`\n\n### 4. 围绕中心点缩放\n\n上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：\n\n```\ntranslate(-centerX*(factor-1),-centerY*(factor-1)) scale(factor)\n```\n\n### 5. skewX和skewY变换\n\n这两个变换用来倾斜某个轴，一般形式为 `skewX(angle),skewY(angle)`。这样的结果就是使得 `x` 轴和 `y` 轴不再垂直。\n\n### 6. 矩阵变换\n\n计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 `matrix(a,b,c,d,e,f)`，此时指定的变换矩阵为:\n\n```text\na  c  e\nb  d  f\n0  0  1\n```\n\n## 七、路径\n\n### 1. path命令\n\n`SVG` 中所有基本形状都是 `path` 的简写形式，但是建议使用简写形式，因为这样可以使 `SVG` 文档更可读。\n\n`path` 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。\n\n下表为 `path` 命令总结，其中大写表示绝对坐标，小写表示相对坐标：\n\n| 命令    | 参数                                        | 说明                                                         |\n| ------- | ------------------------------------------- | ------------------------------------------------------------ |\n| `M` `m` | `x y`                                       | 移动画笔到制定坐标                                           |\n| `L` `l` | `x y`                                       | 绘制一条到给定坐标的线                                       |\n| `H` `h` | `x`                                         | 绘制一条到给定 `x` 坐标的横线                                |\n| `V` `v` | `y`                                         | 绘制一条到给定`y`坐标的垂线                                  |\n| `A` `a` | `rx ry x-axis-rotation large-arc sweep x y` | 圆弧曲线命令有7个参数，依次表示`x`方向半径、`y`方向半径、旋转角度、大圆标识、顺逆时针标识、目标点`x`、目标点`y`。大圆标识和顺逆时针以`0`和`1`表示。`0`表示小圆、逆时针 |\n| `Q` `q` | `x1 y1 x y`                                 | 绘制一条从当前点到`x, y`控制点为`x1, y1`的二次贝塞尔曲线     |\n| `T` `t` | `x y`                                       | 绘制一条从当前点到`x`,`y`的光滑二次贝塞尔曲线，控制点为前一个`Q`命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。 |\n| `C` `c` | `x1 y1 x2 y2 x y`                           | 绘制一条从当前点到 `x`,`y`控制点为`x1,y1` `x2,y2`的三次贝塞尔曲线 |\n| `S` `s` | `x2 y2 x y`                                 | 绘制一条从当前点到`x,y`的光滑三次贝塞尔曲线。第一个控制点为前一个`C`命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。 |\n\n路径的填充同样可以使用 `fill-rule` 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。\n\n## 八、渐变\n\n### 1. 线性渐变\n\n线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。\n\n线性渐变使用`linearGradient`元素表示：\n\n```xml\n<defs>\n\t<linearGradient id=\"linear\">\n\t\t<stop offset=\"0%\" style=\"stop-color:#ffcc00;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#0099cc;\"></stop>\n\t</linearGradient>\n</defs>\n\t<rect x=\"20\" y=\"20\" width=\"200\" height=\"100\" style=\"fill:url(#linear);stroke:black;\"></rect>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg)\n\n`stop`元素有两个必要属性：`offset`和`stop-color`。`offset`属性用来指定在哪个点的颜色应该等于`stop-color`。`offset`的取值范围0%-100%。\n\n`stop`元素的属性：\n\n| 属性           | 说明                             |\n| -------------- | -------------------------------- |\n| `offset`       | 必需，取值范围 `0%-100%`         |\n| `stop-color`   | 必需，对应 `offset` 位置点的颜色 |\n| `stop-opacity` | 对应 `offset` 位置点的不透明度   |\n\n`linearGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `x1`,`y1`      | 渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右     |\n| `x2`,`y2`      | 渐变的终点位置，使用百分比表示                               |\n| `spreadMethod` | 如果设置的`offset`不能覆盖整个对象，该怎么填充。`pad`: 起点或终点颜色会扩展到对象边缘。`repeat`: 渐变重复起点到终点的过程。`reflect`: 渐变按终点-起点-终点的排列重复。 |\n\n### 2. 径向渐变\n\n径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。\n\n```xml\n<defs>\n\t<radialGradient id=\"radial\" cx=\"50%\" cy=\"50%\" >\n\t\t<stop offset=\"0%\" style=\"stop-color:#f00;\"></stop>\n\t\t<stop offset=\"50%\" style=\"stop-color:#0f0;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#00f;\"></stop>\n\t</radialGradient>\n</defs>\n<rect x=\"20\" y=\"20\" width=\"200\" height=\"200\" style=\"fill:url(#radial);stroke:black;\"></rect>\t\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg)\n\n`radialGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `cx`,`cy`,`r`  | 定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为`50%` |\n| `fx`,`fy`      | `0%`点所处的圆路径的圆心，默认和`cx`,`cy`一样                |\n| `spreadMethod` | `pad`,`repeat`,`reflect` 三个值，用来解决绘制范围没有到达图形边缘的情况。 |\n\n## 九、文本\n\n### 1. 相关术语\n\n| 术语                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 字符                  | `XML`中，字符是指带有一个数字值得一个或多个字节，数字值与`Unidode`标准对应 |\n| 符号                  | 字符的视觉呈现。每个字符可以有多种视觉呈现                   |\n| 字体                  | 代表某个字符集合的一组符号                                   |\n| 基线                  | 字体中所有符号以基线对齐                                     |\n| 上坡度                | 基线到字体中最高字符的顶部距离                               |\n| 下坡度                | 基线到最深字符底部的距离                                     |\n| 大写字母高度、`x`高度 | 大写字母高度是指基线上大写字母的高度，`x`高度是基线到小写字母`x`顶部的高度 |\n\n### 2. 文本元素的基本属性\n\n`text` 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。\n\n| 属性              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| `font-family`     | 以空格分割的一系列字体名称或通用字体名称                     |\n| `font-size`       | 如果有多行文本，则 `font-size` 为平行的两条基线的距离        |\n| `font-weight`     | 两个值：`bold`(粗体)和`nromal`(默认)                         |\n| `font-style`      | 常用的两个值:`italic`(斜体)和`normal`                        |\n| `text-decoration` | 可能的值:`none`,`underline`(下划线),`overline`(上划线),`line-through`(删除线) |\n| `word-spacing`    | 单词之间的距离                                               |\n| `letter-spacing`  | 字母之间的间距                                               |\n| `text-anchor`     | 对齐方式：`start`,`middle`,`end`                             |\n| `textLength`      | 设置文本的长度                                               |\n| `lengthAdjust`    | 在指定了`textLength`时，可以通过`lengthAdjust`属性设置字符的调整方式，值为 `spacing`(默认)时,只调整字符的间距。当值为`spacingAndGlyphs`时，同时调整字符间距和字符本身的大小 |\n\n### 3. tspan元素\n\n`text` 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入`tspan` 元素。`tspan` 元素与`html`的`span`元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。\n\n`tspan`元素除大小，颜色等表现样式之外，还可以设置以下属性：\n\n| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `dx`,`dy`        | `x`和`y`方向的偏移                                           |\n| `x`,`y`          | 对`tspan`进行绝对定位                                        |\n| `rotate`         | 旋转字符，可以同时设置多个值，这些值会依次作用在`tspan`包裹的字母上 |\n| `baseline-shift` | 与`dy`属性设置上下标相比，这个属性更方便，当为`super`时，会上标。`sub` 时为下标。仅仅在所在的`tspan`内有效 |\n\n### 4. 纵向文本\n\n文本一般从左到右排列，如果需要上下排列，则需要使用`writing-mode`属性。\n\n设置`writing-mode`属性值为`tb`(top to bottom)，可以将文本上下排列。\n\n## 5. 文本路径\n\n如果要使得文本沿着某条路径排列，则需要使用`textPath`元素。需要将文本放在`textPath`元素内部，然后使用`textPath`元素的`xlink:href`属性引用一个定义好的`path`元素。\n\n```xml\n<defs>\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n</defs>\n<g transform=\"translate(10,50)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n<g transform=\"translate(10,100)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\" startOffset=\"50%\" text-anchor=\"middle\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg)\n\n`startOffset`属性用来指定文本的起点，当设置为`50%`，并且设置`text-anchor`为`middle`时，文本会被定为在`path`的中间。","slug":"svg","published":1,"date":"2021-09-22T03:34:56.188Z","updated":"2021-10-12T03:01:44.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinw000z18uq37yv8pwn","content":"<h2 id=\"一、入门指南\"><a href=\"#一、入门指南\" class=\"headerlink\" title=\"一、入门指南\"></a>一、入门指南</h2><h3 id=\"1-图形系统\"><a href=\"#1-图形系统\" class=\"headerlink\" title=\"1. 图形系统\"></a>1. 图形系统</h3><p>计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。</p>\n<h3 id=\"2-SVG-Scalable-Vector-Graphics\"><a href=\"#2-SVG-Scalable-Vector-Graphics\" class=\"headerlink\" title=\"2. SVG(Scalable Vector Graphics)\"></a>2. SVG(Scalable Vector Graphics)</h3><p>SVG<code>是一种</code>XML<code>应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的</code>XML<code>和</code>SVG<code>版本都为</code>1.1</p>\n<p>SVG文档结构是标准的 <code>XML</code> 文档，根元素 <code>svg</code> 定义图形的大小，根元素中包含各种的形状元素。<code>SVG</code> 允许使用单独的属性指定元素的样式。</p>\n<p><code>SVG</code> 使用 <code>g</code> 元素对图形进行分组，使用 <code>use</code> 元素实现元素的复用。</p>\n<h2 id=\"二、在网页中使用\"><a href=\"#二、在网页中使用\" class=\"headerlink\" title=\"二、在网页中使用\"></a>二、在网页中使用</h2><h3 id=\"1-将SVG作为图像\"><a href=\"#1-将SVG作为图像\" class=\"headerlink\" title=\"1. 将SVG作为图像\"></a>1. 将SVG作为图像</h3><p>将 <code>svg</code> 作为图像包含在HTML标记的 <code>img</code> 元素内，但是这样有一定的局限性：</p>\n<p><strong><code>SVG</code>转为栅格图像时与主页面分离，并且无法在两者之间通信( <code>SVG</code> 渲染过程与主页面独立)。主页面上的样式对 <code>SVG</code> 无效，运行在主页面上的脚本无法感知或者修改 <code>SVG</code> 文档结构。</strong></p>\n<p>在 <code>CSS</code> 中包含 <code>SVG</code>，最常用的是 <code>background-image</code> 属性，应该避免 <code>SVG</code> 元素文件太大。</p>\n<h3 id=\"2-将SVG作为应用程序\"><a href=\"#2-将SVG作为应用程序\" class=\"headerlink\" title=\"2. 将SVG作为应用程序\"></a>2. 将SVG作为应用程序</h3><p>使用 <code>object</code> 元素将 <code>SVG</code> 嵌入 <code>HTML</code> 文档中，<code>object</code>元素的 <code>type</code> 属性表示要嵌入的文档类型，对用 <code>SVG</code> 应该是<code>type=&quot;image/svg+xml&quot;</code>。<code>object</code> 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。</p>\n<h2 id=\"三、坐标系统\"><a href=\"#三、坐标系统\" class=\"headerlink\" title=\"三、坐标系统\"></a>三、坐标系统</h2><h3 id=\"1-视口\"><a href=\"#1-视口\" class=\"headerlink\" title=\"1. 视口\"></a>1. 视口</h3><p>视口是指文档打算使用的画布区域。在 <code>svg</code> 元素上使用 <code>width</code> 和 <code>height</code> 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为<code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code> 和 <code>in</code>)也可以为百分比。</p>\n<h3 id=\"2-默认用户坐标\"><a href=\"#2-默认用户坐标\" class=\"headerlink\" title=\"2. 默认用户坐标\"></a>2. 默认用户坐标</h3><p><code>SVG</code> 阅读器会设置一个坐标系统，即原点 <code>(0,0)</code> 位于视口的左上角，<code>x</code> 向右递增，<code>y</code> 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。</p>\n<p>在 <code>SVG</code> 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 <code>SVG</code> 文档中各个元素的单位可以不统一。</p>\n<h3 id=\"3-指定用户坐标\"><a href=\"#3-指定用户坐标\" class=\"headerlink\" title=\"3. 指定用户坐标\"></a>3. 指定用户坐标</h3><p>摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 <code>svg</code> 元素上设置 <code>viewBox</code> 属性。</p>\n<p><code>viewBox</code> 属性由 <code>4</code> 个数值组成，分别代表要叠加在视口上的最小 <code>x</code>、最小 <code>y</code>，宽度、高度。</p>\n<p>既然可以对 <code>svg</code> 自定义用户坐标，那么肯定要解决 <code>svg</code> 视口长宽比例和 <code>viewBox</code> 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 <code>preserveAspectRatio</code> 属性了。</p>\n<p>如果 <code>viewBox</code> 的长宽比例与视口的长宽比例不同，那么 <code>svg</code> 可以有以下三种选择：</p>\n<ul>\n<li>按较小的尺寸等比例缩放图形，使图形完全填充视口</li>\n<li>按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分</li>\n<li>拉伸和压缩绘图以使其恰好填充视口</li>\n</ul>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">preserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = <span class=\"hljs-string\">&quot;alignment[meet|slice]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>默认值为 <code>&quot;xMidYMid meet&quot;</code></p>\n<p><code>alignment</code>指定轴和位置，<code>x</code> 和 <code>y</code> 方向都有 <code>min</code>, <code>mid</code>, <code>max</code> 三种方式，分别表示 <code>x</code> 和 <code>y</code> 方向的对齐方式，对齐方式由 <code>x</code> 和 <code>y</code> 组合指定，共 <code>9</code> 中方式，也就是 <code>alignment</code> 共有如下 <code>9</code> 个取值：</p>\n<table>\n<thead>\n<tr>\n<th>y\\x</th>\n<th>xMin</th>\n<th>xMid</th>\n<th>xMax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>yMin</strong></td>\n<td>xMinYMin</td>\n<td>xMidYMin</td>\n<td>xMaxYMin</td>\n</tr>\n<tr>\n<td><strong>yMid</strong></td>\n<td>xMinYMid</td>\n<td>xMidYMid</td>\n<td>xMaxYMid</td>\n</tr>\n<tr>\n<td><strong>yMax</strong></td>\n<td>xMinYMax</td>\n<td>xMidYMax</td>\n<td>xMaxYMax</td>\n</tr>\n</tbody></table>\n<p><code>meet</code> 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间</p>\n<p><code>slice</code> 说明符直接裁剪超出视口的部分</p>\n<p>除了上述操作之外，还可以指定 <code>preserveAspectRatio=&quot;none&quot;</code>，用于在 <code>viewBox</code> 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。</p>\n<h3 id=\"4-嵌套坐标系统\"><a href=\"#4-嵌套坐标系统\" class=\"headerlink\" title=\"4. 嵌套坐标系统\"></a>4. 嵌套坐标系统</h3><p>可以将另一个 <code>svg</code> 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 <code>svg</code> 中可以嵌套另一个 <code>svg</code>，每个 <code>svg</code> 都有自己独立的视口和坐标系统</p>\n<h2 id=\"四、基本形状\"><a href=\"#四、基本形状\" class=\"headerlink\" title=\"四、基本形状\"></a>四、基本形状</h2><h3 id=\"1-线段\"><a href=\"#1-线段\" class=\"headerlink\" title=\"1. 线段\"></a>1. 线段</h3><p><code>line</code> 元素，使用 <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> 属性指定线段的起止点坐标。有如下特性:</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度，坐标网格线位于笔画的正中间，可以使用 <code>css</code> 的 <code>shape-rendering</code> 值来控制反锯齿特性</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>线条的不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙…</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-矩形\"><a href=\"#2-矩形\" class=\"headerlink\" title=\"2. 矩形\"></a>2. 矩形</h3><p><code>rect</code>元素，使用<code>x</code>,<code>y</code>,<code>width</code>,<code>height</code>表示一个矩形</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内</td>\n</tr>\n<tr>\n<td><code>rx</code>/<code>ry</code></td>\n<td>圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-圆和椭圆\"><a href=\"#3-圆和椭圆\" class=\"headerlink\" title=\"3. 圆和椭圆\"></a>3. 圆和椭圆</h3><p><code>circle</code> 元素表示圆,由 <code>cx</code>,<code>cy</code>,<code>r</code> 属性界定 <code>ellipse</code> 元素表示椭圆,由 <code>cx</code>,<code>cy</code>,<code>rx</code>,<code>ry</code> 界定</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-多边形\"><a href=\"#4-多边形\" class=\"headerlink\" title=\"4. 多边形\"></a>4. 多边形</h3><p><code>polygon</code> 元素指定一个多边形,由 <code>points</code> 属性指定的一系列坐标点界定，会自动封闭</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则，如果多边形的边有交叉时，需要指定，可以取 <code>mozero</code>(默认)和 <code>evenodd</code> 两个值。</td>\n</tr>\n</tbody></table>\n<p><code>fill-rule</code> 值为 <code>nonzero</code> 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 <code>1</code>，如果是从左往右则总数减 <code>1</code>. 如果最后总数为 <code>0</code> 则认为改点在图形外部，否则在内部。</p>\n<p><code>fill-rule</code> 值为 <code>evenodd</code> 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。</p>\n<h3 id=\"5-折线\"><a href=\"#5-折线\" class=\"headerlink\" title=\"5. 折线\"></a>5. 折线</h3><p><code>polyline</code> 元素表示一个折线，使用 <code>points</code> 属性指定一系列点，不自动封闭图形。</p>\n<h3 id=\"6-特性总结\"><a href=\"#6-特性总结\" class=\"headerlink\" title=\"6. 特性总结\"></a>6. 特性总结</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>笔画不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线笔画</td>\n</tr>\n<tr>\n<td><code>stroke-linecap</code></td>\n<td>笔画头的形状 <code>butt</code>(默认),<code>round</code>,<code>square</code></td>\n</tr>\n<tr>\n<td><code>stroke-linejoin</code></td>\n<td>图形棱角，有<code>miter</code>(默认),<code>round</code>和<code>bevel</code>三个取值</td>\n</tr>\n<tr>\n<td><code>stroke-miterlimit</code></td>\n<td>相交处显示宽度与线宽的最大比例，默认为<code>4</code></td>\n</tr>\n<tr>\n<td><code>fill</code></td>\n<td>填充颜色 默认<code>black</code></td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、文档结构\"><a href=\"#五、文档结构\" class=\"headerlink\" title=\"五、文档结构\"></a>五、文档结构</h2><h3 id=\"1-结构和表现\"><a href=\"#1-结构和表现\" class=\"headerlink\" title=\"1. 结构和表现\"></a>1. 结构和表现</h3><p><code>SVG</code> 允许文档表现和文档结构分离，<code>SVG</code> 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性</p>\n<table>\n<thead>\n<tr>\n<th>表现方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内联样式</td>\n<td>元素内部使用 <code>style</code> 属性</td>\n</tr>\n<tr>\n<td>内部样式表</td>\n<td>内部样式定义在 <code>defs</code> 元素内部</td>\n</tr>\n<tr>\n<td>外部样式表</td>\n<td>与 <code>html</code> 类似，将样式定义在 <code>css</code> 文件中，使用选择器来设置相应的元素样式</td>\n</tr>\n<tr>\n<td>表现属性</td>\n<td><code>SVG</code> 允许以属性的形式指定表现样式，但是<strong>表现属性的优先级最低</strong>，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式</td>\n</tr>\n</tbody></table>\n<p>内部样式表示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2000/svg&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    &lt;defs&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">        &lt;style type=&quot;</span><span class=\"hljs-attr\">text</span>/<span class=\"hljs-attr\">css</span>&quot;&gt;</span>&lt;![CDATA[<br>            circle&#123;<br>                fill:#ccc<br>            &#125;<br>        ]]&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;5&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-分组和引用\"><a href=\"#2-分组和引用\" class=\"headerlink\" title=\"2. 分组和引用\"></a>2. 分组和引用</h3><p><code>g</code> 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。</p>\n<p><code>use</code> 元素用来复用图形中重复出现的元素，需要为 <code>use</code> 标签的 <code>xlink:href</code> 指定 <code>URI</code> 来引用指定的图形元素。同时还要指定<code>x</code>和<code>y</code>属性以表示组合应该移动到哪个位置。<code>use</code>元素并不限制只能使用同一个文件内的对象，<code>xlink:href</code>属性可以指定任何有效的文件或<code>URI</code>。</p>\n<p><code>defs</code>元素用来定义复用的元素，但是定义在<code>defs</code>内的元素并不会被显示，而是作为模板供其他地方使用。</p>\n<p><code>symbol</code>元素与g元素不同，<code>symbol</code>永远不会被显示，也可以用来指定被后续使用的元素，<code>symbol</code>元素可以指定 <code>viewBox</code> 和<code>preserveAspectRatio</code> 属性。在引用时通过为 <code>use</code> 元素指定 <code>width</code> 和 <code>height</code> 属性就可以让 <code>symbol</code> 元素适配视口大小。</p>\n<p><code>image</code> 可以用来包含一个完整的 <code>SVG</code> 或栅格文件。如果包含一个 <code>SVG</code> 文件，则视口会基于引用的文件的 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。</p>\n<p><code>SVG</code>规范要求 <code>SVG</code> 阅读器支持 <code>JPEG</code> 和 <code>PNG</code> 两种栅格文件。</p>\n<h2 id=\"六、坐标系统变换\"><a href=\"#六、坐标系统变换\" class=\"headerlink\" title=\"六、坐标系统变换\"></a>六、坐标系统变换</h2><h3 id=\"1-translate变换\"><a href=\"#1-translate变换\" class=\"headerlink\" title=\"1. translate变换\"></a>1. translate变换</h3><p><code>translate</code> 变换用来对用户坐标进行平移，通过制定 <code>transform</code> 属性值来设置: <code>transform = &quot;translate(x,y)&quot;</code>。</p>\n<p><code>translate</code> 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。</p>\n<h3 id=\"2-scale变换\"><a href=\"#2-scale变换\" class=\"headerlink\" title=\"2. scale变换\"></a>2. scale变换</h3><p>缩放坐标系统。<code>transform = &quot;scale(value)&quot;</code> 或者 <code>transform=&quot;scale(x-value,y-value)&quot;</code>。</p>\n<p>仅仅使用 <code>scale(n)</code> 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 <code>n</code> 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。</p>\n<p><em>技巧：如果从其他系统传输数据到 <code>SVG</code>，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，<code>y</code>向上递增，<code>x</code>向右递增。而 <code>SVG</code> 坐标原点位于左上角，此时使用 <code>scale(1,-1)</code> 就可以完成两者之间的转换。</em></p>\n<p><strong>缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。</strong></p>\n<h3 id=\"3-rotate变换\"><a href=\"#3-rotate变换\" class=\"headerlink\" title=\"3. rotate变换\"></a>3. rotate变换</h3><p>根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，<code>0</code> 度为 <code>3</code> 点钟方向。</p>\n<p>注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： <code>translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)</code></p>\n<p>但是有个更简单的方式：<code>rotate(angle,centerX,centerY)</code></p>\n<h3 id=\"4-围绕中心点缩放\"><a href=\"#4-围绕中心点缩放\" class=\"headerlink\" title=\"4. 围绕中心点缩放\"></a>4. 围绕中心点缩放</h3><p>上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">translate</span>(-centerX*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>),-centerY*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>)) <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-built_in\">factor</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-skewX和skewY变换\"><a href=\"#5-skewX和skewY变换\" class=\"headerlink\" title=\"5. skewX和skewY变换\"></a>5. skewX和skewY变换</h3><p>这两个变换用来倾斜某个轴，一般形式为 <code>skewX(angle),skewY(angle)</code>。这样的结果就是使得 <code>x</code> 轴和 <code>y</code> 轴不再垂直。</p>\n<h3 id=\"6-矩阵变换\"><a href=\"#6-矩阵变换\" class=\"headerlink\" title=\"6. 矩阵变换\"></a>6. 矩阵变换</h3><p>计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 <code>matrix(a,b,c,d,e,f)</code>，此时指定的变换矩阵为:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">a  c  e<br>b  d  f<br>0  0  1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、路径\"><a href=\"#七、路径\" class=\"headerlink\" title=\"七、路径\"></a>七、路径</h2><h3 id=\"1-path命令\"><a href=\"#1-path命令\" class=\"headerlink\" title=\"1. path命令\"></a>1. path命令</h3><p><code>SVG</code> 中所有基本形状都是 <code>path</code> 的简写形式，但是建议使用简写形式，因为这样可以使 <code>SVG</code> 文档更可读。</p>\n<p><code>path</code> 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。</p>\n<p>下表为 <code>path</code> 命令总结，其中大写表示绝对坐标，小写表示相对坐标：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>M</code> <code>m</code></td>\n<td><code>x y</code></td>\n<td>移动画笔到制定坐标</td>\n</tr>\n<tr>\n<td><code>L</code> <code>l</code></td>\n<td><code>x y</code></td>\n<td>绘制一条到给定坐标的线</td>\n</tr>\n<tr>\n<td><code>H</code> <code>h</code></td>\n<td><code>x</code></td>\n<td>绘制一条到给定 <code>x</code> 坐标的横线</td>\n</tr>\n<tr>\n<td><code>V</code> <code>v</code></td>\n<td><code>y</code></td>\n<td>绘制一条到给定<code>y</code>坐标的垂线</td>\n</tr>\n<tr>\n<td><code>A</code> <code>a</code></td>\n<td><code>rx ry x-axis-rotation large-arc sweep x y</code></td>\n<td>圆弧曲线命令有7个参数，依次表示<code>x</code>方向半径、<code>y</code>方向半径、旋转角度、大圆标识、顺逆时针标识、目标点<code>x</code>、目标点<code>y</code>。大圆标识和顺逆时针以<code>0</code>和<code>1</code>表示。<code>0</code>表示小圆、逆时针</td>\n</tr>\n<tr>\n<td><code>Q</code> <code>q</code></td>\n<td><code>x1 y1 x y</code></td>\n<td>绘制一条从当前点到<code>x, y</code>控制点为<code>x1, y1</code>的二次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>T</code> <code>t</code></td>\n<td><code>x y</code></td>\n<td>绘制一条从当前点到<code>x</code>,<code>y</code>的光滑二次贝塞尔曲线，控制点为前一个<code>Q</code>命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。</td>\n</tr>\n<tr>\n<td><code>C</code> <code>c</code></td>\n<td><code>x1 y1 x2 y2 x y</code></td>\n<td>绘制一条从当前点到 <code>x</code>,<code>y</code>控制点为<code>x1,y1</code> <code>x2,y2</code>的三次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>S</code> <code>s</code></td>\n<td><code>x2 y2 x y</code></td>\n<td>绘制一条从当前点到<code>x,y</code>的光滑三次贝塞尔曲线。第一个控制点为前一个<code>C</code>命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。</td>\n</tr>\n</tbody></table>\n<p>路径的填充同样可以使用 <code>fill-rule</code> 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。</p>\n<h2 id=\"八、渐变\"><a href=\"#八、渐变\" class=\"headerlink\" title=\"八、渐变\"></a>八、渐变</h2><h3 id=\"1-线性渐变\"><a href=\"#1-线性渐变\" class=\"headerlink\" title=\"1. 线性渐变\"></a>1. 线性渐变</h3><p>线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。</p>\n<p>线性渐变使用<code>linearGradient</code>元素表示：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">linearGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;linear&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#ffcc00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0099cc;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">linearGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#linear);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg\" alt=\"img\"></p>\n<p><code>stop</code>元素有两个必要属性：<code>offset</code>和<code>stop-color</code>。<code>offset</code>属性用来指定在哪个点的颜色应该等于<code>stop-color</code>。<code>offset</code>的取值范围0%-100%。</p>\n<p><code>stop</code>元素的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>offset</code></td>\n<td>必需，取值范围 <code>0%-100%</code></td>\n</tr>\n<tr>\n<td><code>stop-color</code></td>\n<td>必需，对应 <code>offset</code> 位置点的颜色</td>\n</tr>\n<tr>\n<td><code>stop-opacity</code></td>\n<td>对应 <code>offset</code> 位置点的不透明度</td>\n</tr>\n</tbody></table>\n<p><code>linearGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>x1</code>,<code>y1</code></td>\n<td>渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右</td>\n</tr>\n<tr>\n<td><code>x2</code>,<code>y2</code></td>\n<td>渐变的终点位置，使用百分比表示</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td>如果设置的<code>offset</code>不能覆盖整个对象，该怎么填充。<code>pad</code>: 起点或终点颜色会扩展到对象边缘。<code>repeat</code>: 渐变重复起点到终点的过程。<code>reflect</code>: 渐变按终点-起点-终点的排列重复。</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-径向渐变\"><a href=\"#2-径向渐变\" class=\"headerlink\" title=\"2. 径向渐变\"></a>2. 径向渐变</h3><p>径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">radialGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;radial&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> &gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#f00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0f0;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#00f;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">radialGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#radial);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\t<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg\" alt=\"img\"></p>\n<p><code>radialGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cx</code>,<code>cy</code>,<code>r</code></td>\n<td>定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为<code>50%</code></td>\n</tr>\n<tr>\n<td><code>fx</code>,<code>fy</code></td>\n<td><code>0%</code>点所处的圆路径的圆心，默认和<code>cx</code>,<code>cy</code>一样</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td><code>pad</code>,<code>repeat</code>,<code>reflect</code> 三个值，用来解决绘制范围没有到达图形边缘的情况。</td>\n</tr>\n</tbody></table>\n<h2 id=\"九、文本\"><a href=\"#九、文本\" class=\"headerlink\" title=\"九、文本\"></a>九、文本</h2><h3 id=\"1-相关术语\"><a href=\"#1-相关术语\" class=\"headerlink\" title=\"1. 相关术语\"></a>1. 相关术语</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符</td>\n<td><code>XML</code>中，字符是指带有一个数字值得一个或多个字节，数字值与<code>Unidode</code>标准对应</td>\n</tr>\n<tr>\n<td>符号</td>\n<td>字符的视觉呈现。每个字符可以有多种视觉呈现</td>\n</tr>\n<tr>\n<td>字体</td>\n<td>代表某个字符集合的一组符号</td>\n</tr>\n<tr>\n<td>基线</td>\n<td>字体中所有符号以基线对齐</td>\n</tr>\n<tr>\n<td>上坡度</td>\n<td>基线到字体中最高字符的顶部距离</td>\n</tr>\n<tr>\n<td>下坡度</td>\n<td>基线到最深字符底部的距离</td>\n</tr>\n<tr>\n<td>大写字母高度、<code>x</code>高度</td>\n<td>大写字母高度是指基线上大写字母的高度，<code>x</code>高度是基线到小写字母<code>x</code>顶部的高度</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-文本元素的基本属性\"><a href=\"#2-文本元素的基本属性\" class=\"headerlink\" title=\"2. 文本元素的基本属性\"></a>2. 文本元素的基本属性</h3><p><code>text</code> 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>font-family</code></td>\n<td>以空格分割的一系列字体名称或通用字体名称</td>\n</tr>\n<tr>\n<td><code>font-size</code></td>\n<td>如果有多行文本，则 <code>font-size</code> 为平行的两条基线的距离</td>\n</tr>\n<tr>\n<td><code>font-weight</code></td>\n<td>两个值：<code>bold</code>(粗体)和<code>nromal</code>(默认)</td>\n</tr>\n<tr>\n<td><code>font-style</code></td>\n<td>常用的两个值:<code>italic</code>(斜体)和<code>normal</code></td>\n</tr>\n<tr>\n<td><code>text-decoration</code></td>\n<td>可能的值:<code>none</code>,<code>underline</code>(下划线),<code>overline</code>(上划线),<code>line-through</code>(删除线)</td>\n</tr>\n<tr>\n<td><code>word-spacing</code></td>\n<td>单词之间的距离</td>\n</tr>\n<tr>\n<td><code>letter-spacing</code></td>\n<td>字母之间的间距</td>\n</tr>\n<tr>\n<td><code>text-anchor</code></td>\n<td>对齐方式：<code>start</code>,<code>middle</code>,<code>end</code></td>\n</tr>\n<tr>\n<td><code>textLength</code></td>\n<td>设置文本的长度</td>\n</tr>\n<tr>\n<td><code>lengthAdjust</code></td>\n<td>在指定了<code>textLength</code>时，可以通过<code>lengthAdjust</code>属性设置字符的调整方式，值为 <code>spacing</code>(默认)时,只调整字符的间距。当值为<code>spacingAndGlyphs</code>时，同时调整字符间距和字符本身的大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-tspan元素\"><a href=\"#3-tspan元素\" class=\"headerlink\" title=\"3. tspan元素\"></a>3. tspan元素</h3><p><code>text</code> 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入<code>tspan</code> 元素。<code>tspan</code> 元素与<code>html</code>的<code>span</code>元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。</p>\n<p><code>tspan</code>元素除大小，颜色等表现样式之外，还可以设置以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dx</code>,<code>dy</code></td>\n<td><code>x</code>和<code>y</code>方向的偏移</td>\n</tr>\n<tr>\n<td><code>x</code>,<code>y</code></td>\n<td>对<code>tspan</code>进行绝对定位</td>\n</tr>\n<tr>\n<td><code>rotate</code></td>\n<td>旋转字符，可以同时设置多个值，这些值会依次作用在<code>tspan</code>包裹的字母上</td>\n</tr>\n<tr>\n<td><code>baseline-shift</code></td>\n<td>与<code>dy</code>属性设置上下标相比，这个属性更方便，当为<code>super</code>时，会上标。<code>sub</code> 时为下标。仅仅在所在的<code>tspan</code>内有效</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-纵向文本\"><a href=\"#4-纵向文本\" class=\"headerlink\" title=\"4. 纵向文本\"></a>4. 纵向文本</h3><p>文本一般从左到右排列，如果需要上下排列，则需要使用<code>writing-mode</code>属性。</p>\n<p>设置<code>writing-mode</code>属性值为<code>tb</code>(top to bottom)，可以将文本上下排列。</p>\n<h2 id=\"5-文本路径\"><a href=\"#5-文本路径\" class=\"headerlink\" title=\"5. 文本路径\"></a>5. 文本路径</h2><p>如果要使得文本沿着某条路径排列，则需要使用<code>textPath</code>元素。需要将文本放在<code>textPath</code>元素内部，然后使用<code>textPath</code>元素的<code>xlink:href</code>属性引用一个定义好的<code>path</code>元素。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,50)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,100)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span> <span class=\"hljs-attr\">startOffset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">text-anchor</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg\" alt=\"img\"></p>\n<p><code>startOffset</code>属性用来指定文本的起点，当设置为<code>50%</code>，并且设置<code>text-anchor</code>为<code>middle</code>时，文本会被定为在<code>path</code>的中间。</p>\n","site":{"data":{}},"wordcount":9311,"excerpt":"","more":"<h2 id=\"一、入门指南\"><a href=\"#一、入门指南\" class=\"headerlink\" title=\"一、入门指南\"></a>一、入门指南</h2><h3 id=\"1-图形系统\"><a href=\"#1-图形系统\" class=\"headerlink\" title=\"1. 图形系统\"></a>1. 图形系统</h3><p>计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。</p>\n<h3 id=\"2-SVG-Scalable-Vector-Graphics\"><a href=\"#2-SVG-Scalable-Vector-Graphics\" class=\"headerlink\" title=\"2. SVG(Scalable Vector Graphics)\"></a>2. SVG(Scalable Vector Graphics)</h3><p>SVG<code>是一种</code>XML<code>应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的</code>XML<code>和</code>SVG<code>版本都为</code>1.1</p>\n<p>SVG文档结构是标准的 <code>XML</code> 文档，根元素 <code>svg</code> 定义图形的大小，根元素中包含各种的形状元素。<code>SVG</code> 允许使用单独的属性指定元素的样式。</p>\n<p><code>SVG</code> 使用 <code>g</code> 元素对图形进行分组，使用 <code>use</code> 元素实现元素的复用。</p>\n<h2 id=\"二、在网页中使用\"><a href=\"#二、在网页中使用\" class=\"headerlink\" title=\"二、在网页中使用\"></a>二、在网页中使用</h2><h3 id=\"1-将SVG作为图像\"><a href=\"#1-将SVG作为图像\" class=\"headerlink\" title=\"1. 将SVG作为图像\"></a>1. 将SVG作为图像</h3><p>将 <code>svg</code> 作为图像包含在HTML标记的 <code>img</code> 元素内，但是这样有一定的局限性：</p>\n<p><strong><code>SVG</code>转为栅格图像时与主页面分离，并且无法在两者之间通信( <code>SVG</code> 渲染过程与主页面独立)。主页面上的样式对 <code>SVG</code> 无效，运行在主页面上的脚本无法感知或者修改 <code>SVG</code> 文档结构。</strong></p>\n<p>在 <code>CSS</code> 中包含 <code>SVG</code>，最常用的是 <code>background-image</code> 属性，应该避免 <code>SVG</code> 元素文件太大。</p>\n<h3 id=\"2-将SVG作为应用程序\"><a href=\"#2-将SVG作为应用程序\" class=\"headerlink\" title=\"2. 将SVG作为应用程序\"></a>2. 将SVG作为应用程序</h3><p>使用 <code>object</code> 元素将 <code>SVG</code> 嵌入 <code>HTML</code> 文档中，<code>object</code>元素的 <code>type</code> 属性表示要嵌入的文档类型，对用 <code>SVG</code> 应该是<code>type=&quot;image/svg+xml&quot;</code>。<code>object</code> 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。</p>\n<h2 id=\"三、坐标系统\"><a href=\"#三、坐标系统\" class=\"headerlink\" title=\"三、坐标系统\"></a>三、坐标系统</h2><h3 id=\"1-视口\"><a href=\"#1-视口\" class=\"headerlink\" title=\"1. 视口\"></a>1. 视口</h3><p>视口是指文档打算使用的画布区域。在 <code>svg</code> 元素上使用 <code>width</code> 和 <code>height</code> 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为<code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code> 和 <code>in</code>)也可以为百分比。</p>\n<h3 id=\"2-默认用户坐标\"><a href=\"#2-默认用户坐标\" class=\"headerlink\" title=\"2. 默认用户坐标\"></a>2. 默认用户坐标</h3><p><code>SVG</code> 阅读器会设置一个坐标系统，即原点 <code>(0,0)</code> 位于视口的左上角，<code>x</code> 向右递增，<code>y</code> 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。</p>\n<p>在 <code>SVG</code> 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 <code>SVG</code> 文档中各个元素的单位可以不统一。</p>\n<h3 id=\"3-指定用户坐标\"><a href=\"#3-指定用户坐标\" class=\"headerlink\" title=\"3. 指定用户坐标\"></a>3. 指定用户坐标</h3><p>摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 <code>svg</code> 元素上设置 <code>viewBox</code> 属性。</p>\n<p><code>viewBox</code> 属性由 <code>4</code> 个数值组成，分别代表要叠加在视口上的最小 <code>x</code>、最小 <code>y</code>，宽度、高度。</p>\n<p>既然可以对 <code>svg</code> 自定义用户坐标，那么肯定要解决 <code>svg</code> 视口长宽比例和 <code>viewBox</code> 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 <code>preserveAspectRatio</code> 属性了。</p>\n<p>如果 <code>viewBox</code> 的长宽比例与视口的长宽比例不同，那么 <code>svg</code> 可以有以下三种选择：</p>\n<ul>\n<li>按较小的尺寸等比例缩放图形，使图形完全填充视口</li>\n<li>按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分</li>\n<li>拉伸和压缩绘图以使其恰好填充视口</li>\n</ul>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">preserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = <span class=\"hljs-string\">&quot;alignment[meet|slice]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>默认值为 <code>&quot;xMidYMid meet&quot;</code></p>\n<p><code>alignment</code>指定轴和位置，<code>x</code> 和 <code>y</code> 方向都有 <code>min</code>, <code>mid</code>, <code>max</code> 三种方式，分别表示 <code>x</code> 和 <code>y</code> 方向的对齐方式，对齐方式由 <code>x</code> 和 <code>y</code> 组合指定，共 <code>9</code> 中方式，也就是 <code>alignment</code> 共有如下 <code>9</code> 个取值：</p>\n<table>\n<thead>\n<tr>\n<th>y\\x</th>\n<th>xMin</th>\n<th>xMid</th>\n<th>xMax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>yMin</strong></td>\n<td>xMinYMin</td>\n<td>xMidYMin</td>\n<td>xMaxYMin</td>\n</tr>\n<tr>\n<td><strong>yMid</strong></td>\n<td>xMinYMid</td>\n<td>xMidYMid</td>\n<td>xMaxYMid</td>\n</tr>\n<tr>\n<td><strong>yMax</strong></td>\n<td>xMinYMax</td>\n<td>xMidYMax</td>\n<td>xMaxYMax</td>\n</tr>\n</tbody></table>\n<p><code>meet</code> 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间</p>\n<p><code>slice</code> 说明符直接裁剪超出视口的部分</p>\n<p>除了上述操作之外，还可以指定 <code>preserveAspectRatio=&quot;none&quot;</code>，用于在 <code>viewBox</code> 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。</p>\n<h3 id=\"4-嵌套坐标系统\"><a href=\"#4-嵌套坐标系统\" class=\"headerlink\" title=\"4. 嵌套坐标系统\"></a>4. 嵌套坐标系统</h3><p>可以将另一个 <code>svg</code> 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 <code>svg</code> 中可以嵌套另一个 <code>svg</code>，每个 <code>svg</code> 都有自己独立的视口和坐标系统</p>\n<h2 id=\"四、基本形状\"><a href=\"#四、基本形状\" class=\"headerlink\" title=\"四、基本形状\"></a>四、基本形状</h2><h3 id=\"1-线段\"><a href=\"#1-线段\" class=\"headerlink\" title=\"1. 线段\"></a>1. 线段</h3><p><code>line</code> 元素，使用 <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> 属性指定线段的起止点坐标。有如下特性:</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度，坐标网格线位于笔画的正中间，可以使用 <code>css</code> 的 <code>shape-rendering</code> 值来控制反锯齿特性</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>线条的不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙…</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-矩形\"><a href=\"#2-矩形\" class=\"headerlink\" title=\"2. 矩形\"></a>2. 矩形</h3><p><code>rect</code>元素，使用<code>x</code>,<code>y</code>,<code>width</code>,<code>height</code>表示一个矩形</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内</td>\n</tr>\n<tr>\n<td><code>rx</code>/<code>ry</code></td>\n<td>圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-圆和椭圆\"><a href=\"#3-圆和椭圆\" class=\"headerlink\" title=\"3. 圆和椭圆\"></a>3. 圆和椭圆</h3><p><code>circle</code> 元素表示圆,由 <code>cx</code>,<code>cy</code>,<code>r</code> 属性界定 <code>ellipse</code> 元素表示椭圆,由 <code>cx</code>,<code>cy</code>,<code>rx</code>,<code>ry</code> 界定</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-多边形\"><a href=\"#4-多边形\" class=\"headerlink\" title=\"4. 多边形\"></a>4. 多边形</h3><p><code>polygon</code> 元素指定一个多边形,由 <code>points</code> 属性指定的一系列坐标点界定，会自动封闭</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则，如果多边形的边有交叉时，需要指定，可以取 <code>mozero</code>(默认)和 <code>evenodd</code> 两个值。</td>\n</tr>\n</tbody></table>\n<p><code>fill-rule</code> 值为 <code>nonzero</code> 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 <code>1</code>，如果是从左往右则总数减 <code>1</code>. 如果最后总数为 <code>0</code> 则认为改点在图形外部，否则在内部。</p>\n<p><code>fill-rule</code> 值为 <code>evenodd</code> 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。</p>\n<h3 id=\"5-折线\"><a href=\"#5-折线\" class=\"headerlink\" title=\"5. 折线\"></a>5. 折线</h3><p><code>polyline</code> 元素表示一个折线，使用 <code>points</code> 属性指定一系列点，不自动封闭图形。</p>\n<h3 id=\"6-特性总结\"><a href=\"#6-特性总结\" class=\"headerlink\" title=\"6. 特性总结\"></a>6. 特性总结</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>笔画不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线笔画</td>\n</tr>\n<tr>\n<td><code>stroke-linecap</code></td>\n<td>笔画头的形状 <code>butt</code>(默认),<code>round</code>,<code>square</code></td>\n</tr>\n<tr>\n<td><code>stroke-linejoin</code></td>\n<td>图形棱角，有<code>miter</code>(默认),<code>round</code>和<code>bevel</code>三个取值</td>\n</tr>\n<tr>\n<td><code>stroke-miterlimit</code></td>\n<td>相交处显示宽度与线宽的最大比例，默认为<code>4</code></td>\n</tr>\n<tr>\n<td><code>fill</code></td>\n<td>填充颜色 默认<code>black</code></td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、文档结构\"><a href=\"#五、文档结构\" class=\"headerlink\" title=\"五、文档结构\"></a>五、文档结构</h2><h3 id=\"1-结构和表现\"><a href=\"#1-结构和表现\" class=\"headerlink\" title=\"1. 结构和表现\"></a>1. 结构和表现</h3><p><code>SVG</code> 允许文档表现和文档结构分离，<code>SVG</code> 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性</p>\n<table>\n<thead>\n<tr>\n<th>表现方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内联样式</td>\n<td>元素内部使用 <code>style</code> 属性</td>\n</tr>\n<tr>\n<td>内部样式表</td>\n<td>内部样式定义在 <code>defs</code> 元素内部</td>\n</tr>\n<tr>\n<td>外部样式表</td>\n<td>与 <code>html</code> 类似，将样式定义在 <code>css</code> 文件中，使用选择器来设置相应的元素样式</td>\n</tr>\n<tr>\n<td>表现属性</td>\n<td><code>SVG</code> 允许以属性的形式指定表现样式，但是<strong>表现属性的优先级最低</strong>，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式</td>\n</tr>\n</tbody></table>\n<p>内部样式表示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2000/svg&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    &lt;defs&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">        &lt;style type=&quot;</span><span class=\"hljs-attr\">text</span>/<span class=\"hljs-attr\">css</span>&quot;&gt;</span>&lt;![CDATA[<br>            circle&#123;<br>                fill:#ccc<br>            &#125;<br>        ]]&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;5&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-分组和引用\"><a href=\"#2-分组和引用\" class=\"headerlink\" title=\"2. 分组和引用\"></a>2. 分组和引用</h3><p><code>g</code> 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。</p>\n<p><code>use</code> 元素用来复用图形中重复出现的元素，需要为 <code>use</code> 标签的 <code>xlink:href</code> 指定 <code>URI</code> 来引用指定的图形元素。同时还要指定<code>x</code>和<code>y</code>属性以表示组合应该移动到哪个位置。<code>use</code>元素并不限制只能使用同一个文件内的对象，<code>xlink:href</code>属性可以指定任何有效的文件或<code>URI</code>。</p>\n<p><code>defs</code>元素用来定义复用的元素，但是定义在<code>defs</code>内的元素并不会被显示，而是作为模板供其他地方使用。</p>\n<p><code>symbol</code>元素与g元素不同，<code>symbol</code>永远不会被显示，也可以用来指定被后续使用的元素，<code>symbol</code>元素可以指定 <code>viewBox</code> 和<code>preserveAspectRatio</code> 属性。在引用时通过为 <code>use</code> 元素指定 <code>width</code> 和 <code>height</code> 属性就可以让 <code>symbol</code> 元素适配视口大小。</p>\n<p><code>image</code> 可以用来包含一个完整的 <code>SVG</code> 或栅格文件。如果包含一个 <code>SVG</code> 文件，则视口会基于引用的文件的 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。</p>\n<p><code>SVG</code>规范要求 <code>SVG</code> 阅读器支持 <code>JPEG</code> 和 <code>PNG</code> 两种栅格文件。</p>\n<h2 id=\"六、坐标系统变换\"><a href=\"#六、坐标系统变换\" class=\"headerlink\" title=\"六、坐标系统变换\"></a>六、坐标系统变换</h2><h3 id=\"1-translate变换\"><a href=\"#1-translate变换\" class=\"headerlink\" title=\"1. translate变换\"></a>1. translate变换</h3><p><code>translate</code> 变换用来对用户坐标进行平移，通过制定 <code>transform</code> 属性值来设置: <code>transform = &quot;translate(x,y)&quot;</code>。</p>\n<p><code>translate</code> 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。</p>\n<h3 id=\"2-scale变换\"><a href=\"#2-scale变换\" class=\"headerlink\" title=\"2. scale变换\"></a>2. scale变换</h3><p>缩放坐标系统。<code>transform = &quot;scale(value)&quot;</code> 或者 <code>transform=&quot;scale(x-value,y-value)&quot;</code>。</p>\n<p>仅仅使用 <code>scale(n)</code> 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 <code>n</code> 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。</p>\n<p><em>技巧：如果从其他系统传输数据到 <code>SVG</code>，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，<code>y</code>向上递增，<code>x</code>向右递增。而 <code>SVG</code> 坐标原点位于左上角，此时使用 <code>scale(1,-1)</code> 就可以完成两者之间的转换。</em></p>\n<p><strong>缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。</strong></p>\n<h3 id=\"3-rotate变换\"><a href=\"#3-rotate变换\" class=\"headerlink\" title=\"3. rotate变换\"></a>3. rotate变换</h3><p>根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，<code>0</code> 度为 <code>3</code> 点钟方向。</p>\n<p>注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： <code>translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)</code></p>\n<p>但是有个更简单的方式：<code>rotate(angle,centerX,centerY)</code></p>\n<h3 id=\"4-围绕中心点缩放\"><a href=\"#4-围绕中心点缩放\" class=\"headerlink\" title=\"4. 围绕中心点缩放\"></a>4. 围绕中心点缩放</h3><p>上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">translate</span>(-centerX*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>),-centerY*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>)) <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-built_in\">factor</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-skewX和skewY变换\"><a href=\"#5-skewX和skewY变换\" class=\"headerlink\" title=\"5. skewX和skewY变换\"></a>5. skewX和skewY变换</h3><p>这两个变换用来倾斜某个轴，一般形式为 <code>skewX(angle),skewY(angle)</code>。这样的结果就是使得 <code>x</code> 轴和 <code>y</code> 轴不再垂直。</p>\n<h3 id=\"6-矩阵变换\"><a href=\"#6-矩阵变换\" class=\"headerlink\" title=\"6. 矩阵变换\"></a>6. 矩阵变换</h3><p>计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 <code>matrix(a,b,c,d,e,f)</code>，此时指定的变换矩阵为:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">a  c  e<br>b  d  f<br>0  0  1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、路径\"><a href=\"#七、路径\" class=\"headerlink\" title=\"七、路径\"></a>七、路径</h2><h3 id=\"1-path命令\"><a href=\"#1-path命令\" class=\"headerlink\" title=\"1. path命令\"></a>1. path命令</h3><p><code>SVG</code> 中所有基本形状都是 <code>path</code> 的简写形式，但是建议使用简写形式，因为这样可以使 <code>SVG</code> 文档更可读。</p>\n<p><code>path</code> 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。</p>\n<p>下表为 <code>path</code> 命令总结，其中大写表示绝对坐标，小写表示相对坐标：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>M</code> <code>m</code></td>\n<td><code>x y</code></td>\n<td>移动画笔到制定坐标</td>\n</tr>\n<tr>\n<td><code>L</code> <code>l</code></td>\n<td><code>x y</code></td>\n<td>绘制一条到给定坐标的线</td>\n</tr>\n<tr>\n<td><code>H</code> <code>h</code></td>\n<td><code>x</code></td>\n<td>绘制一条到给定 <code>x</code> 坐标的横线</td>\n</tr>\n<tr>\n<td><code>V</code> <code>v</code></td>\n<td><code>y</code></td>\n<td>绘制一条到给定<code>y</code>坐标的垂线</td>\n</tr>\n<tr>\n<td><code>A</code> <code>a</code></td>\n<td><code>rx ry x-axis-rotation large-arc sweep x y</code></td>\n<td>圆弧曲线命令有7个参数，依次表示<code>x</code>方向半径、<code>y</code>方向半径、旋转角度、大圆标识、顺逆时针标识、目标点<code>x</code>、目标点<code>y</code>。大圆标识和顺逆时针以<code>0</code>和<code>1</code>表示。<code>0</code>表示小圆、逆时针</td>\n</tr>\n<tr>\n<td><code>Q</code> <code>q</code></td>\n<td><code>x1 y1 x y</code></td>\n<td>绘制一条从当前点到<code>x, y</code>控制点为<code>x1, y1</code>的二次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>T</code> <code>t</code></td>\n<td><code>x y</code></td>\n<td>绘制一条从当前点到<code>x</code>,<code>y</code>的光滑二次贝塞尔曲线，控制点为前一个<code>Q</code>命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。</td>\n</tr>\n<tr>\n<td><code>C</code> <code>c</code></td>\n<td><code>x1 y1 x2 y2 x y</code></td>\n<td>绘制一条从当前点到 <code>x</code>,<code>y</code>控制点为<code>x1,y1</code> <code>x2,y2</code>的三次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>S</code> <code>s</code></td>\n<td><code>x2 y2 x y</code></td>\n<td>绘制一条从当前点到<code>x,y</code>的光滑三次贝塞尔曲线。第一个控制点为前一个<code>C</code>命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。</td>\n</tr>\n</tbody></table>\n<p>路径的填充同样可以使用 <code>fill-rule</code> 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。</p>\n<h2 id=\"八、渐变\"><a href=\"#八、渐变\" class=\"headerlink\" title=\"八、渐变\"></a>八、渐变</h2><h3 id=\"1-线性渐变\"><a href=\"#1-线性渐变\" class=\"headerlink\" title=\"1. 线性渐变\"></a>1. 线性渐变</h3><p>线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。</p>\n<p>线性渐变使用<code>linearGradient</code>元素表示：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">linearGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;linear&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#ffcc00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0099cc;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">linearGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#linear);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg\" alt=\"img\"></p>\n<p><code>stop</code>元素有两个必要属性：<code>offset</code>和<code>stop-color</code>。<code>offset</code>属性用来指定在哪个点的颜色应该等于<code>stop-color</code>。<code>offset</code>的取值范围0%-100%。</p>\n<p><code>stop</code>元素的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>offset</code></td>\n<td>必需，取值范围 <code>0%-100%</code></td>\n</tr>\n<tr>\n<td><code>stop-color</code></td>\n<td>必需，对应 <code>offset</code> 位置点的颜色</td>\n</tr>\n<tr>\n<td><code>stop-opacity</code></td>\n<td>对应 <code>offset</code> 位置点的不透明度</td>\n</tr>\n</tbody></table>\n<p><code>linearGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>x1</code>,<code>y1</code></td>\n<td>渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右</td>\n</tr>\n<tr>\n<td><code>x2</code>,<code>y2</code></td>\n<td>渐变的终点位置，使用百分比表示</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td>如果设置的<code>offset</code>不能覆盖整个对象，该怎么填充。<code>pad</code>: 起点或终点颜色会扩展到对象边缘。<code>repeat</code>: 渐变重复起点到终点的过程。<code>reflect</code>: 渐变按终点-起点-终点的排列重复。</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-径向渐变\"><a href=\"#2-径向渐变\" class=\"headerlink\" title=\"2. 径向渐变\"></a>2. 径向渐变</h3><p>径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">radialGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;radial&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> &gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#f00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0f0;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#00f;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">radialGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#radial);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\t<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg\" alt=\"img\"></p>\n<p><code>radialGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cx</code>,<code>cy</code>,<code>r</code></td>\n<td>定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为<code>50%</code></td>\n</tr>\n<tr>\n<td><code>fx</code>,<code>fy</code></td>\n<td><code>0%</code>点所处的圆路径的圆心，默认和<code>cx</code>,<code>cy</code>一样</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td><code>pad</code>,<code>repeat</code>,<code>reflect</code> 三个值，用来解决绘制范围没有到达图形边缘的情况。</td>\n</tr>\n</tbody></table>\n<h2 id=\"九、文本\"><a href=\"#九、文本\" class=\"headerlink\" title=\"九、文本\"></a>九、文本</h2><h3 id=\"1-相关术语\"><a href=\"#1-相关术语\" class=\"headerlink\" title=\"1. 相关术语\"></a>1. 相关术语</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符</td>\n<td><code>XML</code>中，字符是指带有一个数字值得一个或多个字节，数字值与<code>Unidode</code>标准对应</td>\n</tr>\n<tr>\n<td>符号</td>\n<td>字符的视觉呈现。每个字符可以有多种视觉呈现</td>\n</tr>\n<tr>\n<td>字体</td>\n<td>代表某个字符集合的一组符号</td>\n</tr>\n<tr>\n<td>基线</td>\n<td>字体中所有符号以基线对齐</td>\n</tr>\n<tr>\n<td>上坡度</td>\n<td>基线到字体中最高字符的顶部距离</td>\n</tr>\n<tr>\n<td>下坡度</td>\n<td>基线到最深字符底部的距离</td>\n</tr>\n<tr>\n<td>大写字母高度、<code>x</code>高度</td>\n<td>大写字母高度是指基线上大写字母的高度，<code>x</code>高度是基线到小写字母<code>x</code>顶部的高度</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-文本元素的基本属性\"><a href=\"#2-文本元素的基本属性\" class=\"headerlink\" title=\"2. 文本元素的基本属性\"></a>2. 文本元素的基本属性</h3><p><code>text</code> 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>font-family</code></td>\n<td>以空格分割的一系列字体名称或通用字体名称</td>\n</tr>\n<tr>\n<td><code>font-size</code></td>\n<td>如果有多行文本，则 <code>font-size</code> 为平行的两条基线的距离</td>\n</tr>\n<tr>\n<td><code>font-weight</code></td>\n<td>两个值：<code>bold</code>(粗体)和<code>nromal</code>(默认)</td>\n</tr>\n<tr>\n<td><code>font-style</code></td>\n<td>常用的两个值:<code>italic</code>(斜体)和<code>normal</code></td>\n</tr>\n<tr>\n<td><code>text-decoration</code></td>\n<td>可能的值:<code>none</code>,<code>underline</code>(下划线),<code>overline</code>(上划线),<code>line-through</code>(删除线)</td>\n</tr>\n<tr>\n<td><code>word-spacing</code></td>\n<td>单词之间的距离</td>\n</tr>\n<tr>\n<td><code>letter-spacing</code></td>\n<td>字母之间的间距</td>\n</tr>\n<tr>\n<td><code>text-anchor</code></td>\n<td>对齐方式：<code>start</code>,<code>middle</code>,<code>end</code></td>\n</tr>\n<tr>\n<td><code>textLength</code></td>\n<td>设置文本的长度</td>\n</tr>\n<tr>\n<td><code>lengthAdjust</code></td>\n<td>在指定了<code>textLength</code>时，可以通过<code>lengthAdjust</code>属性设置字符的调整方式，值为 <code>spacing</code>(默认)时,只调整字符的间距。当值为<code>spacingAndGlyphs</code>时，同时调整字符间距和字符本身的大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-tspan元素\"><a href=\"#3-tspan元素\" class=\"headerlink\" title=\"3. tspan元素\"></a>3. tspan元素</h3><p><code>text</code> 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入<code>tspan</code> 元素。<code>tspan</code> 元素与<code>html</code>的<code>span</code>元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。</p>\n<p><code>tspan</code>元素除大小，颜色等表现样式之外，还可以设置以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dx</code>,<code>dy</code></td>\n<td><code>x</code>和<code>y</code>方向的偏移</td>\n</tr>\n<tr>\n<td><code>x</code>,<code>y</code></td>\n<td>对<code>tspan</code>进行绝对定位</td>\n</tr>\n<tr>\n<td><code>rotate</code></td>\n<td>旋转字符，可以同时设置多个值，这些值会依次作用在<code>tspan</code>包裹的字母上</td>\n</tr>\n<tr>\n<td><code>baseline-shift</code></td>\n<td>与<code>dy</code>属性设置上下标相比，这个属性更方便，当为<code>super</code>时，会上标。<code>sub</code> 时为下标。仅仅在所在的<code>tspan</code>内有效</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-纵向文本\"><a href=\"#4-纵向文本\" class=\"headerlink\" title=\"4. 纵向文本\"></a>4. 纵向文本</h3><p>文本一般从左到右排列，如果需要上下排列，则需要使用<code>writing-mode</code>属性。</p>\n<p>设置<code>writing-mode</code>属性值为<code>tb</code>(top to bottom)，可以将文本上下排列。</p>\n<h2 id=\"5-文本路径\"><a href=\"#5-文本路径\" class=\"headerlink\" title=\"5. 文本路径\"></a>5. 文本路径</h2><p>如果要使得文本沿着某条路径排列，则需要使用<code>textPath</code>元素。需要将文本放在<code>textPath</code>元素内部，然后使用<code>textPath</code>元素的<code>xlink:href</code>属性引用一个定义好的<code>path</code>元素。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,50)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,100)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span> <span class=\"hljs-attr\">startOffset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">text-anchor</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg\" alt=\"img\"></p>\n<p><code>startOffset</code>属性用来指定文本的起点，当设置为<code>50%</code>，并且设置<code>text-anchor</code>为<code>middle</code>时，文本会被定为在<code>path</code>的中间。</p>\n"},{"title":"react学习笔记","keywords":"react","_content":"## 一、react的基本使用\n\n\n\n#### 1.react的安装：\n\n安装命令： npm i react react-dom\n\n- react包是核心，提供创建元素、组建等功能\n- react-dom包提供DOM相关功能\n\n#### 2.react的使用\n\n- 引入react和react-dom\n- 创建react元素\n  - const title = react.createElement('h1', null, 'hello react')\n  - 第一个参数：创建的元素名称\n  - 第二个参数： 元素的属性\n  - 第三个和以后的参数： 元素的子节点\n- 渲染react元素到页面中\n  - ReactDom.render(title, document.querySelector('#app') )\n  - 第一个参数：要渲染的元素\n  - 第二个参数：DOM对象，用于指定渲染到页面中的位置\n\n## 二、react脚手架的使用\n\n#### 1.使用react脚手架初始化项目\n\n- 命令：npx create-react-app my-app\n\n#### 2.npx命令介绍\n\n目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令\n\n## 三、JSX语法的基本使用\n\n#### 1.使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\n  const title = <h1>hello JSX<h1>\n  ```\n\n- 使用ReactDOM.render()方法渲染元素到页面中\n\n```react\n  ReactDOM.render(title, document.querySelector('#root'))\n  ```\n\n#### 2.为什么脚手架中可以使用JSX语法\n\ncreate-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译\n\n#### 3.注意点\n\n- 元素的属性名使用驼峰命名法\n- 特殊属性名： class -> className, for -> htmlFor, table index -> tabIndex\n- 没有子节点的React元素可以用/>结束\n- 推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱\n\n## 四、JSX中使用javascript表达式\n\n- 数据存储在js中\n\n- 语法： { javascript表达式 }\n\n```react\n  const name = 'jack'\n  const div = (\n  \t<div>hello {name}</div>\n  )\n  ```\n\n- 注意点\n\n  - 单大括号中可以使用任意的JavaScript表达式\n  - JSX自身也是JS表达式，可以在单大括号中使用\n  - js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中\n  - 不能在{}中出现语句（如if/for语句等 ）\n\n## 五、JSX的条件渲染\n\n- 场景：loading效果\n\n- 条件渲染：根据条件渲染特定的JSX结构\n\n- 可以使用if/else或三元运算符或逻辑于运算符来实现\n\n```react\n  const isLoading = false\n  const loadData = () => {\n    return isLoading ?  (<div>加载中...</div>) : (<div>加载完成</div>)\n  }\n  const title = (\n    <div>{loadData()}</div>\n  )\n  ```\n\n## 六、JSX的列表渲染\n\n- 如果要渲染一组数据，应该使用数组的map方法\n\n- 渲染列表时应该添加key属性，key属性的值应该要保证唯一\n\n- 尽量避免使用索引作为key\n\n```react\n  const songs = [\n    {id: 1, name: '痴心绝对'},\n    {id: 2, name: '童话'},\n    {id: 3, name: '演员'},\n  ]\n  const title = (\n    <ul>\n      {songs.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  )\n  ```\n\n## 七、JSX的样式处理\n\n1. 行内样式\n2. 类名\n\n```react\nimport './index.css'\nconst name = 'kobe'\n\nconst title = (\n  <h1 className=\"title\" style={{color: 'red', backgroundColor: 'blue'}}>\n    我是{name}\n  </h1>\n)\n```\n\n## 八、react组件的两种创建方式\n\n#### 1.使用函数创建组件\n\n- 使用JS中的函数创建的组件叫做函数组件\n\n- 函数组件必须有返回值\n\n- 组件名称必须以大写字母开头，react据此区分组件和普通的react元素\n\n- 使用函数名作为组件标签名\n\n```react\n  function Hello() {\n  \treturn(\n  \t\t<div>这是我的第一个函数组件</div>\n  \t)\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 2.使用类创建组件\n\n- 类组件：使用ES6的class创建的组件\n\n- 约定1：类名称必须以大写字母开头\n\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性\n\n- 约定3：类组件必须提供render（）方法\n\n- 约定4：render（）方法必须有返回值，表示该组件的结构\n\n```react\n  class Hello extends React.Component {\n  \trender() {\n  \t\treturn <div>我是类组件<div>\n  \t}\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 3.抽离为独立的js模块\n\n1. 创建Hello.js\n\n2. 在Hello.js中导入react\n\n3. 创建组件（函数或类组件）\n\n4. 在Hello.js中到处该组件\n\n5. 在index.js中导入Hello组件\n\n6. 渲染组件\n\n```react\n  // Hello.js\n  import React from 'react'\n  class Hello extends React.Component {\n    render() {\n      return <div>我是Hello组件</div>\n    }\n  }\n  // index.js\n  import Hello from './Hello'\n  ReactDOM.render(<Hello/>, root)\n```\n\n## 九、react事件处理\n\n- react事件绑定语法与DOM事件语法相似\n\n- 语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () => {} }\n\n- 注意：react事件才用驼峰命名法\n\n- 类组件中绑定事件\n\n```react\n  class App extends React.Component {\n    handleClick() {\n      console.log('click')\n    }\n  \trender() {\n      return <button onClick={this.handleClick}>点击</button>\n    }\n  }\n  ```\n\n- 函数组件中绑定事件\n\n```react\n  function App () {\n    handleClick() {\n      console.log('click')\n    }\n    return <button onClick={handleClick}>点击</button>\n  }\n  ```\n\n- 事件对象\n\n  - 可以通过事件处理程序的参数获取到事件对象\n\n  - react中的事件对象叫做：合成事件（对象）\n\n  - 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题\n\n  ```react\n    class Hello extends React.Component {\n      handleClick(e) {\n        e.preventDefault()\n      }\n      render() {\n        return <a onClick={this.handleClick} href=\"http://www.baidu.com\">百度一下</a>\n      }\n    }\n    ```\n\n## 十、有状态组件和无状态组件\n\n- 函数组件又叫做无状态组件，类组件又叫做有状态组件\n- 状态（state）即数据\n- 函数组件没有自己的状态，只负责数据展示（静）\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n## 十一、组件中的state和setState\n\n#### 1.state的基本使用\n\n- 状态即数据\n\n- 状态是私有的，只能在组件内部使用\n\n- 通过this.state来获取状态\n\n```react\n  class Hello extends React.Component {\n    // constructor() {\n    //  super(); //\n    //  this.state = {\n    //    count: 1\n    // }\n    // }\n    // 简写\n    state = {\n  \t\tcount: 1\n    }\n    render() {\n      return <h2>计数器： {this.state.count}</h2>\n    }\n  }\n  ```\n\n#### 2.setState()修改状态\n\n- 状态是可变的\n\n- 语法：this.setState({要修改的数据})\n\n- 注意：不要直接修改state的值\n\n- setState()作用：修改state、更新UI\n\n```react\n  this.setState({\n    count: this.state.count + 1\n  })\n  ```\n\n\n## 十二、事件绑定this指向\n\n1. 利用箭头函数改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tstate = {\n         count: 1\n       }\n     \trender() {\n         return (\n         \t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={() => this.handleClick()}>+1</button>\n           </div>\n         )\n       }\n     \thandleClick() {\n         this.setState({\n           count: this.state.count + 1\n         })\n       }\n     }\n     ```\n\n2. 利用bind改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick() {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n3. class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick = () => {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n## 十三、表单处理\n\n#### 1.受控组件（常用）\n\n其值收到react控制的表单元素\n\n实现一个受控组件（类似于vue中的v-model）：\n\n1.表单value绑定state中的状态\n\n2.监听表单的change事件，修改state中的状态\n\n```react\nclass Hello extends React.Component {\n\tstate = {\n    text: ''\n  }\n\trender() {\n    return <input type=\"text\" value={this.state.text} onClick={ this.inputChange }></input>\n  }\n\tinputChange = e => {\n    this.setState({\n      text: e.target.value\n    })\n\t}\n}\n```\n\n#### 2.非受控组件（不常用）\n\n- 通过React.createRef()方法创建ref对象\n\n```react\n  constructor() {\n    super()\n    this.txtRef = React.createRef()\n  }\n  ```\n\n  \n\n- 表单使用ref对象\n\n```react\n  render() {\n    return (\n    \t<div>\n      \t<input type=\"text\" ref={ this.txtRef }></input>\n        <button onClick={ this.getValue }>获取value</button>\n      </div>\n    )\n  }\n  ```\n\n  \n\n- 通过ref对象获取表单的值\n\n```react\n  getValue = () => {\n  \tconsole.log(this.txtRef.current.value)\n  }\n  ```\n\n## 十四、组件通讯\n\n#### 1.组件的props\n\n- props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据\n\n- 接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）\n\n```react\n   // 1.函数组件props\n  const Hello = props => {\n    return (\n      <h2>func props: { props.name }</h2>\n    )\n  }\n  // 2.类组件props\n  class Hello extends React.Component {\n    render() {\n      return (\n        <h2>class props: { this.props.name }</h2>\n      )\n    }\n  }\n  \n  ReactDOM.render(<Hello name=\"component props\" />, document.querySelector('#root'))\n  ```\n\n- 特点：\n\n  - 可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）\n  - props只读属性，只能读取属性的值，无法修改对象\n  - ⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props\n\n#### 2.父组件传递数据给子组件\n\n```react\nclass Parent extends React.Component {\n  state = {\n    name: 'kobe'\n  }\n  render() {\n    return (\n      <div>\n        父组件\n        <Child name={ this.state.name }></Child>\n        </div>\n    )\n  }\n}\nclass Child extends React.Component {\n  render() {\n    return (\n      <div>父组件传递给子组件的数据: { this.props.name}</div>\n    )\n  }\n}\nReactDOM.render(\n  <Parent/>,\n  document.querySelector(\"#root\")\n);\n```\n\n#### 3.子组件传递数据给父组件\n\n思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件\n\n```react\nclass Father extends React.Component {\n  state = {\n    childMsg: ''\n  }\n  render() {\n\t\treturn (\n    \t<div>\n      \t<h2>子组件传递的数据: { this.state.childMsg }</h2>\n        <Child getMsg={ this.getChildMsg }></Child>\n      </div>\n    )\n  }\n\tgetChildMsg(childMsg) {\n\t\tthis.setState({\n      childMsg:  childMsg\n    })\n  }\n}\nclass Son extends React.Component {\n\tstate = {\n\t\tchildMsg: 'child'\n  }\n\trender() {\n\t\treturn (\n    \t<button onClick={ this.emitMsg }></button>\n    )\n  }\n\temitMsg = () => {\n\t\tthis.props.getMsg(this.state.childMsg)\n  }\n}\n```\n\n注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错\n\n#### 4.兄弟组件通讯\n\n- 将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态\n\n- 父组件：提供共享状态、提供操作共享状态的方法\n\n- 子组件：通过props获取共享状态和操作共享状态\n\n```react\n  class Parent extends React.Component {\n    // 状态提升\n    state = {\n      count: 1\n    }\n    render() {\n      return (\n        <div>\n          <Child1 count={ this.state.count }></Child1>\n          <Child2 increment = { this.increment}></Child2>\n        </div>\n      )\n    }\n    // 提供修改状态的方法\n    increment = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n  }\n  \n  const Child1 = props => {\n    return (\n      <h2>计数器: { props.count }</h2>\n    )\n  }\n  \n  const Child2 = props => {\n    const increment = () => {\n      props.increment()\n    }\n    return (\n      <button onClick={ increment }>+1</button>\n    )\n  \n  }\n    ReactDOM.render(\n      <Parent/>,\n      document.querySelector(\"#root\")\n    )\n  ```\n\n\n#### 5.组件树传递数据\n\n- Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。\n\n- 使用 context, 我们可以避免通过中间元素传递 props：\n\n```react\n  // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n  // 为当前的 theme 创建一个 context（“light”为默认值）。\n  const ThemeContext = React.createContext('light');\n  class App extends React.Component {\n    render() {\n      // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n      // 无论多深，任何组件都能读取这个值。\n      // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n  }\n  \n  // 中间的组件再也不必指明往下传递 theme 了。\n  function Toolbar() {\n    return (\n      <div>\n        <ThemedButton />\n      </div>\n    );\n  }\n  \n  class ThemedButton extends React.Component {\n    // 指定 contextType 读取当前的 theme context。\n    // React 会往上找到最近的 theme Provider，然后使用它的值。\n    // 在这个例子中，当前的 theme 值为 “dark”。\n    static contextType = ThemeContext;\n    render() {\n      return <Button theme={this.context} />;\n    }\n  }\n  ```\n\n- 使用方法：\n\n  - 1.React.createContext方法创建context\n\n  ```react\n    const MyContext = React.createContext(defaultValue)\n    // 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n    // 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效\n    // or\n    const { Provider, Consumer } = React.creactContext()\n    ```\n\n  - 2.使用Context.Provider提供数据\n\n  ```react\n    <MyContext.Provider value={/* 某个值 */} />\n    // or\n    <Provider value={} />\n    // 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n    \n    // Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n    \n    // 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n    \n    \n    ```\n\n  - value提供为对象时注意事项：\n\n  - 因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 `value` 属性总是被赋值为新的对象：\n\n  ```react\n    class App extends React.Component {\n      render() {\n        return (\n          <MyContext.Provider value={{something: 'something'}}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 为了防止这种情况，将 value 状态提升到父节点的 state 里：\n\n  ```react\n    class App extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          value: {something: 'something'},\n        };\n      }\n    \n      render() {\n        return (\n          <MyContext.Provider value={this.state.value}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 3.消费数据\n\n    - 方式1：Class.contextType\n\n    ```react\n       // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\n      class MyClass extends React.Component {\n        static contextType = MyContext;\n        render() {\n          let value = this.context;\n          /* 基于这个值进行渲染工作 */\n        }\n      }\n      ```\n\n    - 方式2：Context.Consumer\n\n    ```react\n      // 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。\n      \n      // 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。\n      <MyContext.Consumer>\n        {value => /* 基于 context 值进行渲染*/}\n      </MyContext.Consumer>\n      // or \n      <Consumer>\n      \t{value => /* 基于 context 值进行渲染*/}\n      </Consumer>\n      ```\n\n      \n\n","source":"_posts/react.md","raw":"---\ntitle: react学习笔记\ntag: react\nkeywords: react\ncategories: 前端框架\n---\n## 一、react的基本使用\n\n\n\n#### 1.react的安装：\n\n安装命令： npm i react react-dom\n\n- react包是核心，提供创建元素、组建等功能\n- react-dom包提供DOM相关功能\n\n#### 2.react的使用\n\n- 引入react和react-dom\n- 创建react元素\n  - const title = react.createElement('h1', null, 'hello react')\n  - 第一个参数：创建的元素名称\n  - 第二个参数： 元素的属性\n  - 第三个和以后的参数： 元素的子节点\n- 渲染react元素到页面中\n  - ReactDom.render(title, document.querySelector('#app') )\n  - 第一个参数：要渲染的元素\n  - 第二个参数：DOM对象，用于指定渲染到页面中的位置\n\n## 二、react脚手架的使用\n\n#### 1.使用react脚手架初始化项目\n\n- 命令：npx create-react-app my-app\n\n#### 2.npx命令介绍\n\n目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令\n\n## 三、JSX语法的基本使用\n\n#### 1.使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\n  const title = <h1>hello JSX<h1>\n  ```\n\n- 使用ReactDOM.render()方法渲染元素到页面中\n\n```react\n  ReactDOM.render(title, document.querySelector('#root'))\n  ```\n\n#### 2.为什么脚手架中可以使用JSX语法\n\ncreate-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译\n\n#### 3.注意点\n\n- 元素的属性名使用驼峰命名法\n- 特殊属性名： class -> className, for -> htmlFor, table index -> tabIndex\n- 没有子节点的React元素可以用/>结束\n- 推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱\n\n## 四、JSX中使用javascript表达式\n\n- 数据存储在js中\n\n- 语法： { javascript表达式 }\n\n```react\n  const name = 'jack'\n  const div = (\n  \t<div>hello {name}</div>\n  )\n  ```\n\n- 注意点\n\n  - 单大括号中可以使用任意的JavaScript表达式\n  - JSX自身也是JS表达式，可以在单大括号中使用\n  - js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中\n  - 不能在{}中出现语句（如if/for语句等 ）\n\n## 五、JSX的条件渲染\n\n- 场景：loading效果\n\n- 条件渲染：根据条件渲染特定的JSX结构\n\n- 可以使用if/else或三元运算符或逻辑于运算符来实现\n\n```react\n  const isLoading = false\n  const loadData = () => {\n    return isLoading ?  (<div>加载中...</div>) : (<div>加载完成</div>)\n  }\n  const title = (\n    <div>{loadData()}</div>\n  )\n  ```\n\n## 六、JSX的列表渲染\n\n- 如果要渲染一组数据，应该使用数组的map方法\n\n- 渲染列表时应该添加key属性，key属性的值应该要保证唯一\n\n- 尽量避免使用索引作为key\n\n```react\n  const songs = [\n    {id: 1, name: '痴心绝对'},\n    {id: 2, name: '童话'},\n    {id: 3, name: '演员'},\n  ]\n  const title = (\n    <ul>\n      {songs.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  )\n  ```\n\n## 七、JSX的样式处理\n\n1. 行内样式\n2. 类名\n\n```react\nimport './index.css'\nconst name = 'kobe'\n\nconst title = (\n  <h1 className=\"title\" style={{color: 'red', backgroundColor: 'blue'}}>\n    我是{name}\n  </h1>\n)\n```\n\n## 八、react组件的两种创建方式\n\n#### 1.使用函数创建组件\n\n- 使用JS中的函数创建的组件叫做函数组件\n\n- 函数组件必须有返回值\n\n- 组件名称必须以大写字母开头，react据此区分组件和普通的react元素\n\n- 使用函数名作为组件标签名\n\n```react\n  function Hello() {\n  \treturn(\n  \t\t<div>这是我的第一个函数组件</div>\n  \t)\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 2.使用类创建组件\n\n- 类组件：使用ES6的class创建的组件\n\n- 约定1：类名称必须以大写字母开头\n\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性\n\n- 约定3：类组件必须提供render（）方法\n\n- 约定4：render（）方法必须有返回值，表示该组件的结构\n\n```react\n  class Hello extends React.Component {\n  \trender() {\n  \t\treturn <div>我是类组件<div>\n  \t}\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 3.抽离为独立的js模块\n\n1. 创建Hello.js\n\n2. 在Hello.js中导入react\n\n3. 创建组件（函数或类组件）\n\n4. 在Hello.js中到处该组件\n\n5. 在index.js中导入Hello组件\n\n6. 渲染组件\n\n```react\n  // Hello.js\n  import React from 'react'\n  class Hello extends React.Component {\n    render() {\n      return <div>我是Hello组件</div>\n    }\n  }\n  // index.js\n  import Hello from './Hello'\n  ReactDOM.render(<Hello/>, root)\n```\n\n## 九、react事件处理\n\n- react事件绑定语法与DOM事件语法相似\n\n- 语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () => {} }\n\n- 注意：react事件才用驼峰命名法\n\n- 类组件中绑定事件\n\n```react\n  class App extends React.Component {\n    handleClick() {\n      console.log('click')\n    }\n  \trender() {\n      return <button onClick={this.handleClick}>点击</button>\n    }\n  }\n  ```\n\n- 函数组件中绑定事件\n\n```react\n  function App () {\n    handleClick() {\n      console.log('click')\n    }\n    return <button onClick={handleClick}>点击</button>\n  }\n  ```\n\n- 事件对象\n\n  - 可以通过事件处理程序的参数获取到事件对象\n\n  - react中的事件对象叫做：合成事件（对象）\n\n  - 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题\n\n  ```react\n    class Hello extends React.Component {\n      handleClick(e) {\n        e.preventDefault()\n      }\n      render() {\n        return <a onClick={this.handleClick} href=\"http://www.baidu.com\">百度一下</a>\n      }\n    }\n    ```\n\n## 十、有状态组件和无状态组件\n\n- 函数组件又叫做无状态组件，类组件又叫做有状态组件\n- 状态（state）即数据\n- 函数组件没有自己的状态，只负责数据展示（静）\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n## 十一、组件中的state和setState\n\n#### 1.state的基本使用\n\n- 状态即数据\n\n- 状态是私有的，只能在组件内部使用\n\n- 通过this.state来获取状态\n\n```react\n  class Hello extends React.Component {\n    // constructor() {\n    //  super(); //\n    //  this.state = {\n    //    count: 1\n    // }\n    // }\n    // 简写\n    state = {\n  \t\tcount: 1\n    }\n    render() {\n      return <h2>计数器： {this.state.count}</h2>\n    }\n  }\n  ```\n\n#### 2.setState()修改状态\n\n- 状态是可变的\n\n- 语法：this.setState({要修改的数据})\n\n- 注意：不要直接修改state的值\n\n- setState()作用：修改state、更新UI\n\n```react\n  this.setState({\n    count: this.state.count + 1\n  })\n  ```\n\n\n## 十二、事件绑定this指向\n\n1. 利用箭头函数改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tstate = {\n         count: 1\n       }\n     \trender() {\n         return (\n         \t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={() => this.handleClick()}>+1</button>\n           </div>\n         )\n       }\n     \thandleClick() {\n         this.setState({\n           count: this.state.count + 1\n         })\n       }\n     }\n     ```\n\n2. 利用bind改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick() {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n3. class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick = () => {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n## 十三、表单处理\n\n#### 1.受控组件（常用）\n\n其值收到react控制的表单元素\n\n实现一个受控组件（类似于vue中的v-model）：\n\n1.表单value绑定state中的状态\n\n2.监听表单的change事件，修改state中的状态\n\n```react\nclass Hello extends React.Component {\n\tstate = {\n    text: ''\n  }\n\trender() {\n    return <input type=\"text\" value={this.state.text} onClick={ this.inputChange }></input>\n  }\n\tinputChange = e => {\n    this.setState({\n      text: e.target.value\n    })\n\t}\n}\n```\n\n#### 2.非受控组件（不常用）\n\n- 通过React.createRef()方法创建ref对象\n\n```react\n  constructor() {\n    super()\n    this.txtRef = React.createRef()\n  }\n  ```\n\n  \n\n- 表单使用ref对象\n\n```react\n  render() {\n    return (\n    \t<div>\n      \t<input type=\"text\" ref={ this.txtRef }></input>\n        <button onClick={ this.getValue }>获取value</button>\n      </div>\n    )\n  }\n  ```\n\n  \n\n- 通过ref对象获取表单的值\n\n```react\n  getValue = () => {\n  \tconsole.log(this.txtRef.current.value)\n  }\n  ```\n\n## 十四、组件通讯\n\n#### 1.组件的props\n\n- props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据\n\n- 接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）\n\n```react\n   // 1.函数组件props\n  const Hello = props => {\n    return (\n      <h2>func props: { props.name }</h2>\n    )\n  }\n  // 2.类组件props\n  class Hello extends React.Component {\n    render() {\n      return (\n        <h2>class props: { this.props.name }</h2>\n      )\n    }\n  }\n  \n  ReactDOM.render(<Hello name=\"component props\" />, document.querySelector('#root'))\n  ```\n\n- 特点：\n\n  - 可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）\n  - props只读属性，只能读取属性的值，无法修改对象\n  - ⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props\n\n#### 2.父组件传递数据给子组件\n\n```react\nclass Parent extends React.Component {\n  state = {\n    name: 'kobe'\n  }\n  render() {\n    return (\n      <div>\n        父组件\n        <Child name={ this.state.name }></Child>\n        </div>\n    )\n  }\n}\nclass Child extends React.Component {\n  render() {\n    return (\n      <div>父组件传递给子组件的数据: { this.props.name}</div>\n    )\n  }\n}\nReactDOM.render(\n  <Parent/>,\n  document.querySelector(\"#root\")\n);\n```\n\n#### 3.子组件传递数据给父组件\n\n思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件\n\n```react\nclass Father extends React.Component {\n  state = {\n    childMsg: ''\n  }\n  render() {\n\t\treturn (\n    \t<div>\n      \t<h2>子组件传递的数据: { this.state.childMsg }</h2>\n        <Child getMsg={ this.getChildMsg }></Child>\n      </div>\n    )\n  }\n\tgetChildMsg(childMsg) {\n\t\tthis.setState({\n      childMsg:  childMsg\n    })\n  }\n}\nclass Son extends React.Component {\n\tstate = {\n\t\tchildMsg: 'child'\n  }\n\trender() {\n\t\treturn (\n    \t<button onClick={ this.emitMsg }></button>\n    )\n  }\n\temitMsg = () => {\n\t\tthis.props.getMsg(this.state.childMsg)\n  }\n}\n```\n\n注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错\n\n#### 4.兄弟组件通讯\n\n- 将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态\n\n- 父组件：提供共享状态、提供操作共享状态的方法\n\n- 子组件：通过props获取共享状态和操作共享状态\n\n```react\n  class Parent extends React.Component {\n    // 状态提升\n    state = {\n      count: 1\n    }\n    render() {\n      return (\n        <div>\n          <Child1 count={ this.state.count }></Child1>\n          <Child2 increment = { this.increment}></Child2>\n        </div>\n      )\n    }\n    // 提供修改状态的方法\n    increment = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n  }\n  \n  const Child1 = props => {\n    return (\n      <h2>计数器: { props.count }</h2>\n    )\n  }\n  \n  const Child2 = props => {\n    const increment = () => {\n      props.increment()\n    }\n    return (\n      <button onClick={ increment }>+1</button>\n    )\n  \n  }\n    ReactDOM.render(\n      <Parent/>,\n      document.querySelector(\"#root\")\n    )\n  ```\n\n\n#### 5.组件树传递数据\n\n- Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。\n\n- 使用 context, 我们可以避免通过中间元素传递 props：\n\n```react\n  // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n  // 为当前的 theme 创建一个 context（“light”为默认值）。\n  const ThemeContext = React.createContext('light');\n  class App extends React.Component {\n    render() {\n      // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n      // 无论多深，任何组件都能读取这个值。\n      // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n  }\n  \n  // 中间的组件再也不必指明往下传递 theme 了。\n  function Toolbar() {\n    return (\n      <div>\n        <ThemedButton />\n      </div>\n    );\n  }\n  \n  class ThemedButton extends React.Component {\n    // 指定 contextType 读取当前的 theme context。\n    // React 会往上找到最近的 theme Provider，然后使用它的值。\n    // 在这个例子中，当前的 theme 值为 “dark”。\n    static contextType = ThemeContext;\n    render() {\n      return <Button theme={this.context} />;\n    }\n  }\n  ```\n\n- 使用方法：\n\n  - 1.React.createContext方法创建context\n\n  ```react\n    const MyContext = React.createContext(defaultValue)\n    // 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n    // 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效\n    // or\n    const { Provider, Consumer } = React.creactContext()\n    ```\n\n  - 2.使用Context.Provider提供数据\n\n  ```react\n    <MyContext.Provider value={/* 某个值 */} />\n    // or\n    <Provider value={} />\n    // 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n    \n    // Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n    \n    // 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n    \n    \n    ```\n\n  - value提供为对象时注意事项：\n\n  - 因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 `value` 属性总是被赋值为新的对象：\n\n  ```react\n    class App extends React.Component {\n      render() {\n        return (\n          <MyContext.Provider value={{something: 'something'}}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 为了防止这种情况，将 value 状态提升到父节点的 state 里：\n\n  ```react\n    class App extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          value: {something: 'something'},\n        };\n      }\n    \n      render() {\n        return (\n          <MyContext.Provider value={this.state.value}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 3.消费数据\n\n    - 方式1：Class.contextType\n\n    ```react\n       // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\n      class MyClass extends React.Component {\n        static contextType = MyContext;\n        render() {\n          let value = this.context;\n          /* 基于这个值进行渲染工作 */\n        }\n      }\n      ```\n\n    - 方式2：Context.Consumer\n\n    ```react\n      // 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。\n      \n      // 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。\n      <MyContext.Consumer>\n        {value => /* 基于 context 值进行渲染*/}\n      </MyContext.Consumer>\n      // or \n      <Consumer>\n      \t{value => /* 基于 context 值进行渲染*/}\n      </Consumer>\n      ```\n\n      \n\n","slug":"react","published":1,"date":"2021-08-25T01:38:07.000Z","updated":"2021-10-14T01:22:47.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl3mvbinx001018uqb0a89ymn","content":"<h2 id=\"一、react的基本使用\"><a href=\"#一、react的基本使用\" class=\"headerlink\" title=\"一、react的基本使用\"></a>一、react的基本使用</h2><h4 id=\"1-react的安装：\"><a href=\"#1-react的安装：\" class=\"headerlink\" title=\"1.react的安装：\"></a>1.react的安装：</h4><p>安装命令： npm i react react-dom</p>\n<ul>\n<li>react包是核心，提供创建元素、组建等功能</li>\n<li>react-dom包提供DOM相关功能</li>\n</ul>\n<h4 id=\"2-react的使用\"><a href=\"#2-react的使用\" class=\"headerlink\" title=\"2.react的使用\"></a>2.react的使用</h4><ul>\n<li>引入react和react-dom</li>\n<li>创建react元素<ul>\n<li>const title = react.createElement(‘h1’, null, ‘hello react’)</li>\n<li>第一个参数：创建的元素名称</li>\n<li>第二个参数： 元素的属性</li>\n<li>第三个和以后的参数： 元素的子节点</li>\n</ul>\n</li>\n<li>渲染react元素到页面中<ul>\n<li>ReactDom.render(title, document.querySelector(‘#app’) )</li>\n<li>第一个参数：要渲染的元素</li>\n<li>第二个参数：DOM对象，用于指定渲染到页面中的位置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、react脚手架的使用\"><a href=\"#二、react脚手架的使用\" class=\"headerlink\" title=\"二、react脚手架的使用\"></a>二、react脚手架的使用</h2><h4 id=\"1-使用react脚手架初始化项目\"><a href=\"#1-使用react脚手架初始化项目\" class=\"headerlink\" title=\"1.使用react脚手架初始化项目\"></a>1.使用react脚手架初始化项目</h4><ul>\n<li>命令：npx create-react-app my-app</li>\n</ul>\n<h4 id=\"2-npx命令介绍\"><a href=\"#2-npx命令介绍\" class=\"headerlink\" title=\"2.npx命令介绍\"></a>2.npx命令介绍</h4><p>目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令</p>\n<h2 id=\"三、JSX语法的基本使用\"><a href=\"#三、JSX语法的基本使用\" class=\"headerlink\" title=\"三、JSX语法的基本使用\"></a>三、JSX语法的基本使用</h2><h4 id=\"1-使用步骤\"><a href=\"#1-使用步骤\" class=\"headerlink\" title=\"1.使用步骤\"></a>1.使用步骤</h4><ul>\n<li>使用JSX语法创建react元素</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const title = &lt;h1&gt;hello JSX&lt;h1&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>使用ReactDOM.render()方法渲染元素到页面中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">ReactDOM.render(title, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-为什么脚手架中可以使用JSX语法\"><a href=\"#2-为什么脚手架中可以使用JSX语法\" class=\"headerlink\" title=\"2.为什么脚手架中可以使用JSX语法\"></a>2.为什么脚手架中可以使用JSX语法</h4><p>create-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译</p>\n<h4 id=\"3-注意点\"><a href=\"#3-注意点\" class=\"headerlink\" title=\"3.注意点\"></a>3.注意点</h4><ul>\n<li>元素的属性名使用驼峰命名法</li>\n<li>特殊属性名： class -&gt; className, for -&gt; htmlFor, table index -&gt; tabIndex</li>\n<li>没有子节点的React元素可以用/&gt;结束</li>\n<li>推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱</li>\n</ul>\n<h2 id=\"四、JSX中使用javascript表达式\"><a href=\"#四、JSX中使用javascript表达式\" class=\"headerlink\" title=\"四、JSX中使用javascript表达式\"></a>四、JSX中使用javascript表达式</h2><ul>\n<li><p>数据存储在js中</p>\n</li>\n<li><p>语法： { javascript表达式 }</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const name = &#x27;jack&#x27;<br>const div = (<br>\t&lt;div&gt;hello &#123;name&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意点</p>\n<ul>\n<li>单大括号中可以使用任意的JavaScript表达式</li>\n<li>JSX自身也是JS表达式，可以在单大括号中使用</li>\n<li>js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中</li>\n<li>不能在{}中出现语句（如if/for语句等 ）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五、JSX的条件渲染\"><a href=\"#五、JSX的条件渲染\" class=\"headerlink\" title=\"五、JSX的条件渲染\"></a>五、JSX的条件渲染</h2><ul>\n<li><p>场景：loading效果</p>\n</li>\n<li><p>条件渲染：根据条件渲染特定的JSX结构</p>\n</li>\n<li><p>可以使用if/else或三元运算符或逻辑于运算符来实现</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const isLoading = false<br>const loadData = () =&gt; &#123;<br>  return isLoading ?  (&lt;div&gt;加载中...&lt;/div&gt;) : (&lt;div&gt;加载完成&lt;/div&gt;)<br>&#125;<br>const title = (<br>  &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、JSX的列表渲染\"><a href=\"#六、JSX的列表渲染\" class=\"headerlink\" title=\"六、JSX的列表渲染\"></a>六、JSX的列表渲染</h2><ul>\n<li><p>如果要渲染一组数据，应该使用数组的map方法</p>\n</li>\n<li><p>渲染列表时应该添加key属性，key属性的值应该要保证唯一</p>\n</li>\n<li><p>尽量避免使用索引作为key</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const songs = [<br>  &#123;id: 1, name: &#x27;痴心绝对&#x27;&#125;,<br>  &#123;id: 2, name: &#x27;童话&#x27;&#125;,<br>  &#123;id: 3, name: &#x27;演员&#x27;&#125;,<br>]<br>const title = (<br>  &lt;ul&gt;<br>    &#123;songs.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;<br>  &lt;/ul&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、JSX的样式处理\"><a href=\"#七、JSX的样式处理\" class=\"headerlink\" title=\"七、JSX的样式处理\"></a>七、JSX的样式处理</h2><ol>\n<li>行内样式</li>\n<li>类名</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#x27;./index.css&#x27;<br>const name = &#x27;kobe&#x27;<br><br>const title = (<br>  &lt;h1 className=&quot;title&quot; style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;blue&#x27;&#125;&#125;&gt;<br>    我是&#123;name&#125;<br>  &lt;/h1&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、react组件的两种创建方式\"><a href=\"#八、react组件的两种创建方式\" class=\"headerlink\" title=\"八、react组件的两种创建方式\"></a>八、react组件的两种创建方式</h2><h4 id=\"1-使用函数创建组件\"><a href=\"#1-使用函数创建组件\" class=\"headerlink\" title=\"1.使用函数创建组件\"></a>1.使用函数创建组件</h4><ul>\n<li><p>使用JS中的函数创建的组件叫做函数组件</p>\n</li>\n<li><p>函数组件必须有返回值</p>\n</li>\n<li><p>组件名称必须以大写字母开头，react据此区分组件和普通的react元素</p>\n</li>\n<li><p>使用函数名作为组件标签名</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function Hello() &#123;<br>\treturn(<br>\t\t&lt;div&gt;这是我的第一个函数组件&lt;/div&gt;<br>\t)<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用类创建组件\"><a href=\"#2-使用类创建组件\" class=\"headerlink\" title=\"2.使用类创建组件\"></a>2.使用类创建组件</h4><ul>\n<li><p>类组件：使用ES6的class创建的组件</p>\n</li>\n<li><p>约定1：类名称必须以大写字母开头</p>\n</li>\n<li><p>约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性</p>\n</li>\n<li><p>约定3：类组件必须提供render（）方法</p>\n</li>\n<li><p>约定4：render（）方法必须有返回值，表示该组件的结构</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\trender() &#123;<br>\t\treturn &lt;div&gt;我是类组件&lt;div&gt;<br>\t&#125;<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-抽离为独立的js模块\"><a href=\"#3-抽离为独立的js模块\" class=\"headerlink\" title=\"3.抽离为独立的js模块\"></a>3.抽离为独立的js模块</h4><ol>\n<li><p>创建Hello.js</p>\n</li>\n<li><p>在Hello.js中导入react</p>\n</li>\n<li><p>创建组件（函数或类组件）</p>\n</li>\n<li><p>在Hello.js中到处该组件</p>\n</li>\n<li><p>在index.js中导入Hello组件</p>\n</li>\n<li><p>渲染组件</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Hello.js<br>import React from &#x27;react&#x27;<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return &lt;div&gt;我是Hello组件&lt;/div&gt;<br>  &#125;<br>&#125;<br>// index.js<br>import Hello from &#x27;./Hello&#x27;<br>ReactDOM.render(&lt;Hello/&gt;, root)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、react事件处理\"><a href=\"#九、react事件处理\" class=\"headerlink\" title=\"九、react事件处理\"></a>九、react事件处理</h2><ul>\n<li><p>react事件绑定语法与DOM事件语法相似</p>\n</li>\n<li><p>语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () =&gt; {} }</p>\n</li>\n<li><p>注意：react事件才用驼峰命名法</p>\n</li>\n<li><p>类组件中绑定事件</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>\trender() &#123;<br>    return &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>函数组件中绑定事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function App () &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>  return &lt;button onClick=&#123;handleClick&#125;&gt;点击&lt;/button&gt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件对象</p>\n<ul>\n<li><p>可以通过事件处理程序的参数获取到事件对象</p>\n</li>\n<li><p>react中的事件对象叫做：合成事件（对象）</p>\n</li>\n<li><p>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  handleClick(e) &#123;<br>    e.preventDefault()<br>  &#125;<br>  render() &#123;<br>    return &lt;a onClick=&#123;this.handleClick&#125; href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"十、有状态组件和无状态组件\"><a href=\"#十、有状态组件和无状态组件\" class=\"headerlink\" title=\"十、有状态组件和无状态组件\"></a>十、有状态组件和无状态组件</h2><ul>\n<li>函数组件又叫做无状态组件，类组件又叫做有状态组件</li>\n<li>状态（state）即数据</li>\n<li>函数组件没有自己的状态，只负责数据展示（静）</li>\n<li>类组件有自己的状态，负责更新UI，让页面动起来</li>\n</ul>\n<h2 id=\"十一、组件中的state和setState\"><a href=\"#十一、组件中的state和setState\" class=\"headerlink\" title=\"十一、组件中的state和setState\"></a>十一、组件中的state和setState</h2><h4 id=\"1-state的基本使用\"><a href=\"#1-state的基本使用\" class=\"headerlink\" title=\"1.state的基本使用\"></a>1.state的基本使用</h4><ul>\n<li><p>状态即数据</p>\n</li>\n<li><p>状态是私有的，只能在组件内部使用</p>\n</li>\n<li><p>通过this.state来获取状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  // constructor() &#123;<br>  //  super(); //<br>  //  this.state = &#123;<br>  //    count: 1<br>  // &#125;<br>  // &#125;<br>  // 简写<br>  state = &#123;<br>\t\tcount: 1<br>  &#125;<br>  render() &#123;<br>    return &lt;h2&gt;计数器： &#123;this.state.count&#125;&lt;/h2&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-setState-修改状态\"><a href=\"#2-setState-修改状态\" class=\"headerlink\" title=\"2.setState()修改状态\"></a>2.setState()修改状态</h4><ul>\n<li><p>状态是可变的</p>\n</li>\n<li><p>语法：this.setState({要修改的数据})</p>\n</li>\n<li><p>注意：不要直接修改state的值</p>\n</li>\n<li><p>setState()作用：修改state、更新UI</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">this.setState(&#123;<br>  count: this.state.count + 1<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"十二、事件绑定this指向\"><a href=\"#十二、事件绑定this指向\" class=\"headerlink\" title=\"十二、事件绑定this指向\"></a>十二、事件绑定this指向</h2><ol>\n<li>利用箭头函数改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    count: 1<br>  &#125;<br>\trender() &#123;<br>    return (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;+1&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\thandleClick() &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>利用bind改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick() &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick = () =&gt; &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、表单处理\"><a href=\"#十三、表单处理\" class=\"headerlink\" title=\"十三、表单处理\"></a>十三、表单处理</h2><h4 id=\"1-受控组件（常用）\"><a href=\"#1-受控组件（常用）\" class=\"headerlink\" title=\"1.受控组件（常用）\"></a>1.受控组件（常用）</h4><p>其值收到react控制的表单元素</p>\n<p>实现一个受控组件（类似于vue中的v-model）：</p>\n<p>1.表单value绑定state中的状态</p>\n<p>2.监听表单的change事件，修改state中的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    text: &#x27;&#x27;<br>  &#125;<br>\trender() &#123;<br>    return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onClick=&#123; this.inputChange &#125;&gt;&lt;/input&gt;<br>  &#125;<br>\tinputChange = e =&gt; &#123;<br>    this.setState(&#123;<br>      text: e.target.value<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-非受控组件（不常用）\"><a href=\"#2-非受控组件（不常用）\" class=\"headerlink\" title=\"2.非受控组件（不常用）\"></a>2.非受控组件（不常用）</h4><ul>\n<li>通过React.createRef()方法创建ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">constructor() &#123;<br>  super()<br>  this.txtRef = React.createRef()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>表单使用ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">render() &#123;<br>  return (<br>  \t&lt;div&gt;<br>    \t&lt;input type=&quot;text&quot; ref=&#123; this.txtRef &#125;&gt;&lt;/input&gt;<br>      &lt;button onClick=&#123; this.getValue &#125;&gt;获取value&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过ref对象获取表单的值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">getValue = () =&gt; &#123;<br>\tconsole.log(this.txtRef.current.value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、组件通讯\"><a href=\"#十四、组件通讯\" class=\"headerlink\" title=\"十四、组件通讯\"></a>十四、组件通讯</h2><h4 id=\"1-组件的props\"><a href=\"#1-组件的props\" class=\"headerlink\" title=\"1.组件的props\"></a>1.组件的props</h4><ul>\n<li><p>props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据</p>\n</li>\n<li><p>接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 1.函数组件props<br>const Hello = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;func props: &#123; props.name &#125;&lt;/h2&gt;<br>  )<br>&#125;<br>// 2.类组件props<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;h2&gt;class props: &#123; this.props.name &#125;&lt;/h2&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(&lt;Hello name=&quot;component props&quot; /&gt;, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>特点：</p>\n<ul>\n<li>可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）</li>\n<li>props只读属性，只能读取属性的值，无法修改对象</li>\n<li>⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-父组件传递数据给子组件\"><a href=\"#2-父组件传递数据给子组件\" class=\"headerlink\" title=\"2.父组件传递数据给子组件\"></a>2.父组件传递数据给子组件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  state = &#123;<br>    name: &#x27;kobe&#x27;<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        父组件<br>        &lt;Child name=&#123; this.state.name &#125;&gt;&lt;/Child&gt;<br>        &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>class Child extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;父组件传递给子组件的数据: &#123; this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;Parent/&gt;,<br>  document.querySelector(&quot;#root&quot;)<br>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-子组件传递数据给父组件\"><a href=\"#3-子组件传递数据给父组件\" class=\"headerlink\" title=\"3.子组件传递数据给父组件\"></a>3.子组件传递数据给父组件</h4><p>思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Father extends React.Component &#123;<br>  state = &#123;<br>    childMsg: &#x27;&#x27;<br>  &#125;<br>  render() &#123;<br>\t\treturn (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;子组件传递的数据: &#123; this.state.childMsg &#125;&lt;/h2&gt;<br>        &lt;Child getMsg=&#123; this.getChildMsg &#125;&gt;&lt;/Child&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\tgetChildMsg(childMsg) &#123;<br>\t\tthis.setState(&#123;<br>      childMsg:  childMsg<br>    &#125;)<br>  &#125;<br>&#125;<br>class Son extends React.Component &#123;<br>\tstate = &#123;<br>\t\tchildMsg: &#x27;child&#x27;<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>    \t&lt;button onClick=&#123; this.emitMsg &#125;&gt;&lt;/button&gt;<br>    )<br>  &#125;<br>\temitMsg = () =&gt; &#123;<br>\t\tthis.props.getMsg(this.state.childMsg)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错</p>\n<h4 id=\"4-兄弟组件通讯\"><a href=\"#4-兄弟组件通讯\" class=\"headerlink\" title=\"4.兄弟组件通讯\"></a>4.兄弟组件通讯</h4><ul>\n<li><p>将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态</p>\n</li>\n<li><p>父组件：提供共享状态、提供操作共享状态的方法</p>\n</li>\n<li><p>子组件：通过props获取共享状态和操作共享状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  // 状态提升<br>  state = &#123;<br>    count: 1<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;Child1 count=&#123; this.state.count &#125;&gt;&lt;/Child1&gt;<br>        &lt;Child2 increment = &#123; this.increment&#125;&gt;&lt;/Child2&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>  // 提供修改状态的方法<br>  increment = () =&gt; &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br><br>const Child1 = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;计数器: &#123; props.count &#125;&lt;/h2&gt;<br>  )<br>&#125;<br><br>const Child2 = props =&gt; &#123;<br>  const increment = () =&gt; &#123;<br>    props.increment()<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123; increment &#125;&gt;+1&lt;/button&gt;<br>  )<br><br>&#125;<br>  ReactDOM.render(<br>    &lt;Parent/&gt;,<br>    document.querySelector(&quot;#root&quot;)<br>  )<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"5-组件树传递数据\"><a href=\"#5-组件树传递数据\" class=\"headerlink\" title=\"5.组件树传递数据\"></a>5.组件树传递数据</h4><ul>\n<li><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>\n</li>\n<li><p>使用 context, 我们可以避免通过中间元素传递 props：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。<br>// 为当前的 theme 创建一个 context（“light”为默认值）。<br>const ThemeContext = React.createContext(&#x27;light&#x27;);<br>class App extends React.Component &#123;<br>  render() &#123;<br>    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。<br>    // 无论多深，任何组件都能读取这个值。<br>    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。<br>    return (<br>      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/ThemeContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br><br>// 中间的组件再也不必指明往下传递 theme 了。<br>function Toolbar() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;ThemedButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br>class ThemedButton extends React.Component &#123;<br>  // 指定 contextType 读取当前的 theme context。<br>  // React 会往上找到最近的 theme Provider，然后使用它的值。<br>  // 在这个例子中，当前的 theme 值为 “dark”。<br>  static contextType = ThemeContext;<br>  render() &#123;<br>    return &lt;Button theme=&#123;this.context&#125; /&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用方法：</p>\n<ul>\n<li>1.React.createContext方法创建context</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const MyContext = React.createContext(defaultValue)<br>// 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。<br>// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效<br>// or<br>const &#123; Provider, Consumer &#125; = React.creactContext()<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>2.使用Context.Provider提供数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125; /&gt;<br>// or<br>&lt;Provider value=&#123;&#125; /&gt;<br>// 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。<br><br>// Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。<br><br>// 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。<br><br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>value提供为对象时注意事项：</p>\n</li>\n<li><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;&#123;something: &#x27;something&#x27;&#125;&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>为了防止这种情况，将 value 状态提升到父节点的 state 里：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props);<br>    this.state = &#123;<br>      value: &#123;something: &#x27;something&#x27;&#125;,<br>    &#125;;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;this.state.value&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>3.消费数据</p>\n<ul>\n<li>方式1：Class.contextType</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。<br>class MyClass extends React.Component &#123;<br>  static contextType = MyContext;<br>  render() &#123;<br>    let value = this.context;<br>    /* 基于这个值进行渲染工作 */<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>方式2：Context.Consumer</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。<br><br>// 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。<br>&lt;MyContext.Consumer&gt;<br>  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/MyContext.Consumer&gt;<br>// or <br>&lt;Consumer&gt;<br>\t&#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/Consumer&gt;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":12108,"excerpt":"","more":"<h2 id=\"一、react的基本使用\"><a href=\"#一、react的基本使用\" class=\"headerlink\" title=\"一、react的基本使用\"></a>一、react的基本使用</h2><h4 id=\"1-react的安装：\"><a href=\"#1-react的安装：\" class=\"headerlink\" title=\"1.react的安装：\"></a>1.react的安装：</h4><p>安装命令： npm i react react-dom</p>\n<ul>\n<li>react包是核心，提供创建元素、组建等功能</li>\n<li>react-dom包提供DOM相关功能</li>\n</ul>\n<h4 id=\"2-react的使用\"><a href=\"#2-react的使用\" class=\"headerlink\" title=\"2.react的使用\"></a>2.react的使用</h4><ul>\n<li>引入react和react-dom</li>\n<li>创建react元素<ul>\n<li>const title = react.createElement(‘h1’, null, ‘hello react’)</li>\n<li>第一个参数：创建的元素名称</li>\n<li>第二个参数： 元素的属性</li>\n<li>第三个和以后的参数： 元素的子节点</li>\n</ul>\n</li>\n<li>渲染react元素到页面中<ul>\n<li>ReactDom.render(title, document.querySelector(‘#app’) )</li>\n<li>第一个参数：要渲染的元素</li>\n<li>第二个参数：DOM对象，用于指定渲染到页面中的位置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、react脚手架的使用\"><a href=\"#二、react脚手架的使用\" class=\"headerlink\" title=\"二、react脚手架的使用\"></a>二、react脚手架的使用</h2><h4 id=\"1-使用react脚手架初始化项目\"><a href=\"#1-使用react脚手架初始化项目\" class=\"headerlink\" title=\"1.使用react脚手架初始化项目\"></a>1.使用react脚手架初始化项目</h4><ul>\n<li>命令：npx create-react-app my-app</li>\n</ul>\n<h4 id=\"2-npx命令介绍\"><a href=\"#2-npx命令介绍\" class=\"headerlink\" title=\"2.npx命令介绍\"></a>2.npx命令介绍</h4><p>目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令</p>\n<h2 id=\"三、JSX语法的基本使用\"><a href=\"#三、JSX语法的基本使用\" class=\"headerlink\" title=\"三、JSX语法的基本使用\"></a>三、JSX语法的基本使用</h2><h4 id=\"1-使用步骤\"><a href=\"#1-使用步骤\" class=\"headerlink\" title=\"1.使用步骤\"></a>1.使用步骤</h4><ul>\n<li>使用JSX语法创建react元素</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const title = &lt;h1&gt;hello JSX&lt;h1&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>使用ReactDOM.render()方法渲染元素到页面中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">ReactDOM.render(title, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-为什么脚手架中可以使用JSX语法\"><a href=\"#2-为什么脚手架中可以使用JSX语法\" class=\"headerlink\" title=\"2.为什么脚手架中可以使用JSX语法\"></a>2.为什么脚手架中可以使用JSX语法</h4><p>create-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译</p>\n<h4 id=\"3-注意点\"><a href=\"#3-注意点\" class=\"headerlink\" title=\"3.注意点\"></a>3.注意点</h4><ul>\n<li>元素的属性名使用驼峰命名法</li>\n<li>特殊属性名： class -&gt; className, for -&gt; htmlFor, table index -&gt; tabIndex</li>\n<li>没有子节点的React元素可以用/&gt;结束</li>\n<li>推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱</li>\n</ul>\n<h2 id=\"四、JSX中使用javascript表达式\"><a href=\"#四、JSX中使用javascript表达式\" class=\"headerlink\" title=\"四、JSX中使用javascript表达式\"></a>四、JSX中使用javascript表达式</h2><ul>\n<li><p>数据存储在js中</p>\n</li>\n<li><p>语法： { javascript表达式 }</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const name = &#x27;jack&#x27;<br>const div = (<br>\t&lt;div&gt;hello &#123;name&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意点</p>\n<ul>\n<li>单大括号中可以使用任意的JavaScript表达式</li>\n<li>JSX自身也是JS表达式，可以在单大括号中使用</li>\n<li>js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中</li>\n<li>不能在{}中出现语句（如if/for语句等 ）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五、JSX的条件渲染\"><a href=\"#五、JSX的条件渲染\" class=\"headerlink\" title=\"五、JSX的条件渲染\"></a>五、JSX的条件渲染</h2><ul>\n<li><p>场景：loading效果</p>\n</li>\n<li><p>条件渲染：根据条件渲染特定的JSX结构</p>\n</li>\n<li><p>可以使用if/else或三元运算符或逻辑于运算符来实现</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const isLoading = false<br>const loadData = () =&gt; &#123;<br>  return isLoading ?  (&lt;div&gt;加载中...&lt;/div&gt;) : (&lt;div&gt;加载完成&lt;/div&gt;)<br>&#125;<br>const title = (<br>  &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、JSX的列表渲染\"><a href=\"#六、JSX的列表渲染\" class=\"headerlink\" title=\"六、JSX的列表渲染\"></a>六、JSX的列表渲染</h2><ul>\n<li><p>如果要渲染一组数据，应该使用数组的map方法</p>\n</li>\n<li><p>渲染列表时应该添加key属性，key属性的值应该要保证唯一</p>\n</li>\n<li><p>尽量避免使用索引作为key</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const songs = [<br>  &#123;id: 1, name: &#x27;痴心绝对&#x27;&#125;,<br>  &#123;id: 2, name: &#x27;童话&#x27;&#125;,<br>  &#123;id: 3, name: &#x27;演员&#x27;&#125;,<br>]<br>const title = (<br>  &lt;ul&gt;<br>    &#123;songs.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;<br>  &lt;/ul&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、JSX的样式处理\"><a href=\"#七、JSX的样式处理\" class=\"headerlink\" title=\"七、JSX的样式处理\"></a>七、JSX的样式处理</h2><ol>\n<li>行内样式</li>\n<li>类名</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#x27;./index.css&#x27;<br>const name = &#x27;kobe&#x27;<br><br>const title = (<br>  &lt;h1 className=&quot;title&quot; style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;blue&#x27;&#125;&#125;&gt;<br>    我是&#123;name&#125;<br>  &lt;/h1&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、react组件的两种创建方式\"><a href=\"#八、react组件的两种创建方式\" class=\"headerlink\" title=\"八、react组件的两种创建方式\"></a>八、react组件的两种创建方式</h2><h4 id=\"1-使用函数创建组件\"><a href=\"#1-使用函数创建组件\" class=\"headerlink\" title=\"1.使用函数创建组件\"></a>1.使用函数创建组件</h4><ul>\n<li><p>使用JS中的函数创建的组件叫做函数组件</p>\n</li>\n<li><p>函数组件必须有返回值</p>\n</li>\n<li><p>组件名称必须以大写字母开头，react据此区分组件和普通的react元素</p>\n</li>\n<li><p>使用函数名作为组件标签名</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function Hello() &#123;<br>\treturn(<br>\t\t&lt;div&gt;这是我的第一个函数组件&lt;/div&gt;<br>\t)<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用类创建组件\"><a href=\"#2-使用类创建组件\" class=\"headerlink\" title=\"2.使用类创建组件\"></a>2.使用类创建组件</h4><ul>\n<li><p>类组件：使用ES6的class创建的组件</p>\n</li>\n<li><p>约定1：类名称必须以大写字母开头</p>\n</li>\n<li><p>约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性</p>\n</li>\n<li><p>约定3：类组件必须提供render（）方法</p>\n</li>\n<li><p>约定4：render（）方法必须有返回值，表示该组件的结构</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\trender() &#123;<br>\t\treturn &lt;div&gt;我是类组件&lt;div&gt;<br>\t&#125;<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-抽离为独立的js模块\"><a href=\"#3-抽离为独立的js模块\" class=\"headerlink\" title=\"3.抽离为独立的js模块\"></a>3.抽离为独立的js模块</h4><ol>\n<li><p>创建Hello.js</p>\n</li>\n<li><p>在Hello.js中导入react</p>\n</li>\n<li><p>创建组件（函数或类组件）</p>\n</li>\n<li><p>在Hello.js中到处该组件</p>\n</li>\n<li><p>在index.js中导入Hello组件</p>\n</li>\n<li><p>渲染组件</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Hello.js<br>import React from &#x27;react&#x27;<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return &lt;div&gt;我是Hello组件&lt;/div&gt;<br>  &#125;<br>&#125;<br>// index.js<br>import Hello from &#x27;./Hello&#x27;<br>ReactDOM.render(&lt;Hello/&gt;, root)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、react事件处理\"><a href=\"#九、react事件处理\" class=\"headerlink\" title=\"九、react事件处理\"></a>九、react事件处理</h2><ul>\n<li><p>react事件绑定语法与DOM事件语法相似</p>\n</li>\n<li><p>语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () =&gt; {} }</p>\n</li>\n<li><p>注意：react事件才用驼峰命名法</p>\n</li>\n<li><p>类组件中绑定事件</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>\trender() &#123;<br>    return &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>函数组件中绑定事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function App () &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>  return &lt;button onClick=&#123;handleClick&#125;&gt;点击&lt;/button&gt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件对象</p>\n<ul>\n<li><p>可以通过事件处理程序的参数获取到事件对象</p>\n</li>\n<li><p>react中的事件对象叫做：合成事件（对象）</p>\n</li>\n<li><p>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  handleClick(e) &#123;<br>    e.preventDefault()<br>  &#125;<br>  render() &#123;<br>    return &lt;a onClick=&#123;this.handleClick&#125; href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"十、有状态组件和无状态组件\"><a href=\"#十、有状态组件和无状态组件\" class=\"headerlink\" title=\"十、有状态组件和无状态组件\"></a>十、有状态组件和无状态组件</h2><ul>\n<li>函数组件又叫做无状态组件，类组件又叫做有状态组件</li>\n<li>状态（state）即数据</li>\n<li>函数组件没有自己的状态，只负责数据展示（静）</li>\n<li>类组件有自己的状态，负责更新UI，让页面动起来</li>\n</ul>\n<h2 id=\"十一、组件中的state和setState\"><a href=\"#十一、组件中的state和setState\" class=\"headerlink\" title=\"十一、组件中的state和setState\"></a>十一、组件中的state和setState</h2><h4 id=\"1-state的基本使用\"><a href=\"#1-state的基本使用\" class=\"headerlink\" title=\"1.state的基本使用\"></a>1.state的基本使用</h4><ul>\n<li><p>状态即数据</p>\n</li>\n<li><p>状态是私有的，只能在组件内部使用</p>\n</li>\n<li><p>通过this.state来获取状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  // constructor() &#123;<br>  //  super(); //<br>  //  this.state = &#123;<br>  //    count: 1<br>  // &#125;<br>  // &#125;<br>  // 简写<br>  state = &#123;<br>\t\tcount: 1<br>  &#125;<br>  render() &#123;<br>    return &lt;h2&gt;计数器： &#123;this.state.count&#125;&lt;/h2&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-setState-修改状态\"><a href=\"#2-setState-修改状态\" class=\"headerlink\" title=\"2.setState()修改状态\"></a>2.setState()修改状态</h4><ul>\n<li><p>状态是可变的</p>\n</li>\n<li><p>语法：this.setState({要修改的数据})</p>\n</li>\n<li><p>注意：不要直接修改state的值</p>\n</li>\n<li><p>setState()作用：修改state、更新UI</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">this.setState(&#123;<br>  count: this.state.count + 1<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"十二、事件绑定this指向\"><a href=\"#十二、事件绑定this指向\" class=\"headerlink\" title=\"十二、事件绑定this指向\"></a>十二、事件绑定this指向</h2><ol>\n<li>利用箭头函数改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    count: 1<br>  &#125;<br>\trender() &#123;<br>    return (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;+1&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\thandleClick() &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>利用bind改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick() &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick = () =&gt; &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、表单处理\"><a href=\"#十三、表单处理\" class=\"headerlink\" title=\"十三、表单处理\"></a>十三、表单处理</h2><h4 id=\"1-受控组件（常用）\"><a href=\"#1-受控组件（常用）\" class=\"headerlink\" title=\"1.受控组件（常用）\"></a>1.受控组件（常用）</h4><p>其值收到react控制的表单元素</p>\n<p>实现一个受控组件（类似于vue中的v-model）：</p>\n<p>1.表单value绑定state中的状态</p>\n<p>2.监听表单的change事件，修改state中的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    text: &#x27;&#x27;<br>  &#125;<br>\trender() &#123;<br>    return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onClick=&#123; this.inputChange &#125;&gt;&lt;/input&gt;<br>  &#125;<br>\tinputChange = e =&gt; &#123;<br>    this.setState(&#123;<br>      text: e.target.value<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-非受控组件（不常用）\"><a href=\"#2-非受控组件（不常用）\" class=\"headerlink\" title=\"2.非受控组件（不常用）\"></a>2.非受控组件（不常用）</h4><ul>\n<li>通过React.createRef()方法创建ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">constructor() &#123;<br>  super()<br>  this.txtRef = React.createRef()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>表单使用ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">render() &#123;<br>  return (<br>  \t&lt;div&gt;<br>    \t&lt;input type=&quot;text&quot; ref=&#123; this.txtRef &#125;&gt;&lt;/input&gt;<br>      &lt;button onClick=&#123; this.getValue &#125;&gt;获取value&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过ref对象获取表单的值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">getValue = () =&gt; &#123;<br>\tconsole.log(this.txtRef.current.value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、组件通讯\"><a href=\"#十四、组件通讯\" class=\"headerlink\" title=\"十四、组件通讯\"></a>十四、组件通讯</h2><h4 id=\"1-组件的props\"><a href=\"#1-组件的props\" class=\"headerlink\" title=\"1.组件的props\"></a>1.组件的props</h4><ul>\n<li><p>props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据</p>\n</li>\n<li><p>接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 1.函数组件props<br>const Hello = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;func props: &#123; props.name &#125;&lt;/h2&gt;<br>  )<br>&#125;<br>// 2.类组件props<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;h2&gt;class props: &#123; this.props.name &#125;&lt;/h2&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(&lt;Hello name=&quot;component props&quot; /&gt;, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>特点：</p>\n<ul>\n<li>可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）</li>\n<li>props只读属性，只能读取属性的值，无法修改对象</li>\n<li>⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-父组件传递数据给子组件\"><a href=\"#2-父组件传递数据给子组件\" class=\"headerlink\" title=\"2.父组件传递数据给子组件\"></a>2.父组件传递数据给子组件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  state = &#123;<br>    name: &#x27;kobe&#x27;<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        父组件<br>        &lt;Child name=&#123; this.state.name &#125;&gt;&lt;/Child&gt;<br>        &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>class Child extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;父组件传递给子组件的数据: &#123; this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;Parent/&gt;,<br>  document.querySelector(&quot;#root&quot;)<br>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-子组件传递数据给父组件\"><a href=\"#3-子组件传递数据给父组件\" class=\"headerlink\" title=\"3.子组件传递数据给父组件\"></a>3.子组件传递数据给父组件</h4><p>思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Father extends React.Component &#123;<br>  state = &#123;<br>    childMsg: &#x27;&#x27;<br>  &#125;<br>  render() &#123;<br>\t\treturn (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;子组件传递的数据: &#123; this.state.childMsg &#125;&lt;/h2&gt;<br>        &lt;Child getMsg=&#123; this.getChildMsg &#125;&gt;&lt;/Child&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\tgetChildMsg(childMsg) &#123;<br>\t\tthis.setState(&#123;<br>      childMsg:  childMsg<br>    &#125;)<br>  &#125;<br>&#125;<br>class Son extends React.Component &#123;<br>\tstate = &#123;<br>\t\tchildMsg: &#x27;child&#x27;<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>    \t&lt;button onClick=&#123; this.emitMsg &#125;&gt;&lt;/button&gt;<br>    )<br>  &#125;<br>\temitMsg = () =&gt; &#123;<br>\t\tthis.props.getMsg(this.state.childMsg)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错</p>\n<h4 id=\"4-兄弟组件通讯\"><a href=\"#4-兄弟组件通讯\" class=\"headerlink\" title=\"4.兄弟组件通讯\"></a>4.兄弟组件通讯</h4><ul>\n<li><p>将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态</p>\n</li>\n<li><p>父组件：提供共享状态、提供操作共享状态的方法</p>\n</li>\n<li><p>子组件：通过props获取共享状态和操作共享状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  // 状态提升<br>  state = &#123;<br>    count: 1<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;Child1 count=&#123; this.state.count &#125;&gt;&lt;/Child1&gt;<br>        &lt;Child2 increment = &#123; this.increment&#125;&gt;&lt;/Child2&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>  // 提供修改状态的方法<br>  increment = () =&gt; &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br><br>const Child1 = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;计数器: &#123; props.count &#125;&lt;/h2&gt;<br>  )<br>&#125;<br><br>const Child2 = props =&gt; &#123;<br>  const increment = () =&gt; &#123;<br>    props.increment()<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123; increment &#125;&gt;+1&lt;/button&gt;<br>  )<br><br>&#125;<br>  ReactDOM.render(<br>    &lt;Parent/&gt;,<br>    document.querySelector(&quot;#root&quot;)<br>  )<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"5-组件树传递数据\"><a href=\"#5-组件树传递数据\" class=\"headerlink\" title=\"5.组件树传递数据\"></a>5.组件树传递数据</h4><ul>\n<li><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>\n</li>\n<li><p>使用 context, 我们可以避免通过中间元素传递 props：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。<br>// 为当前的 theme 创建一个 context（“light”为默认值）。<br>const ThemeContext = React.createContext(&#x27;light&#x27;);<br>class App extends React.Component &#123;<br>  render() &#123;<br>    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。<br>    // 无论多深，任何组件都能读取这个值。<br>    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。<br>    return (<br>      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/ThemeContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br><br>// 中间的组件再也不必指明往下传递 theme 了。<br>function Toolbar() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;ThemedButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br>class ThemedButton extends React.Component &#123;<br>  // 指定 contextType 读取当前的 theme context。<br>  // React 会往上找到最近的 theme Provider，然后使用它的值。<br>  // 在这个例子中，当前的 theme 值为 “dark”。<br>  static contextType = ThemeContext;<br>  render() &#123;<br>    return &lt;Button theme=&#123;this.context&#125; /&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用方法：</p>\n<ul>\n<li>1.React.createContext方法创建context</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const MyContext = React.createContext(defaultValue)<br>// 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。<br>// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效<br>// or<br>const &#123; Provider, Consumer &#125; = React.creactContext()<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>2.使用Context.Provider提供数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125; /&gt;<br>// or<br>&lt;Provider value=&#123;&#125; /&gt;<br>// 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。<br><br>// Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。<br><br>// 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。<br><br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>value提供为对象时注意事项：</p>\n</li>\n<li><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;&#123;something: &#x27;something&#x27;&#125;&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>为了防止这种情况，将 value 状态提升到父节点的 state 里：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props);<br>    this.state = &#123;<br>      value: &#123;something: &#x27;something&#x27;&#125;,<br>    &#125;;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;this.state.value&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>3.消费数据</p>\n<ul>\n<li>方式1：Class.contextType</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。<br>class MyClass extends React.Component &#123;<br>  static contextType = MyContext;<br>  render() &#123;<br>    let value = this.context;<br>    /* 基于这个值进行渲染工作 */<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>方式2：Context.Consumer</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。<br><br>// 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。<br>&lt;MyContext.Consumer&gt;<br>  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/MyContext.Consumer&gt;<br>// or <br>&lt;Consumer&gt;<br>\t&#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/Consumer&gt;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl3mvbine000118uqfi719xqn","category_id":"cl3mvbinl000418uq2j3v10zq","_id":"cl3mvbins000g18uqgchtdu1l"},{"post_id":"cl3mvbinj000318uqhn6r4zy2","category_id":"cl3mvbinq000c18uq3jhqetgq","_id":"cl3mvbins000k18uq58b585g9"},{"post_id":"cl3mvbino000718uq18dm6vcl","category_id":"cl3mvbins000h18uq1e3dehpo","_id":"cl3mvbint000o18uq0jme79s7"},{"post_id":"cl3mvbinp000918uq2nd1fjpf","category_id":"cl3mvbins000l18uqcxwf3407","_id":"cl3mvbinu000t18uq76l7hkf4"},{"post_id":"cl3mvbinq000b18uqeztkeqzj","category_id":"cl3mvbinq000c18uq3jhqetgq","_id":"cl3mvbinv000w18uq0xgn2xc2"},{"post_id":"cl3mvbinr000f18uq4hnv8sot","category_id":"cl3mvbins000l18uqcxwf3407","_id":"cl3mvbinv000y18uqe7xt4hkq"},{"post_id":"cl3mvbinw000z18uq37yv8pwn","category_id":"cl3mvbinq000c18uq3jhqetgq","_id":"cl3mvbio0001318uqgog70tgs"},{"post_id":"cl3mvbinx001018uqb0a89ymn","category_id":"cl3mvbinz001218uq1rws5h48","_id":"cl3mvbio0001618uqcle52bc7"}],"PostTag":[{"post_id":"cl3mvbine000118uqfi719xqn","tag_id":"cl3mvbinn000518uqbjvl86p5","_id":"cl3mvbinr000e18uqf1a54eby"},{"post_id":"cl3mvbinj000318uqhn6r4zy2","tag_id":"cl3mvbinq000d18uq4249balv","_id":"cl3mvbins000j18uq7ej14bka"},{"post_id":"cl3mvbino000718uq18dm6vcl","tag_id":"cl3mvbins000i18uqbiqra2kw","_id":"cl3mvbint000n18uq2cas4b2d"},{"post_id":"cl3mvbinp000918uq2nd1fjpf","tag_id":"cl3mvbins000m18uq0noc14o1","_id":"cl3mvbinu000r18uq7lms4qm6"},{"post_id":"cl3mvbinq000b18uqeztkeqzj","tag_id":"cl3mvbint000q18uq4ncbe1zh","_id":"cl3mvbinv000v18uq9xrebfiu"},{"post_id":"cl3mvbinr000f18uq4hnv8sot","tag_id":"cl3mvbinv000u18uqg62u03aq","_id":"cl3mvbinv000x18uqe8hxd4e4"},{"post_id":"cl3mvbinw000z18uq37yv8pwn","tag_id":"cl3mvbiny001118uqhxy794nh","_id":"cl3mvbio0001518uq79r84bci"},{"post_id":"cl3mvbinx001018uqb0a89ymn","tag_id":"cl3mvbio0001418uqh7kkhisa","_id":"cl3mvbio0001718uqfzkj4sz3"}],"Tag":[{"name":"h5与ue4","_id":"cl3mvbinn000518uqbjvl86p5"},{"name":"echarts","_id":"cl3mvbinq000d18uq4249balv"},{"name":"jenkins","_id":"cl3mvbins000i18uqbiqra2kw"},{"name":"浏览器渲染","_id":"cl3mvbins000m18uq0noc14o1"},{"name":"d3js","_id":"cl3mvbint000q18uq4ncbe1zh"},{"name":"浏览器的进程和线程","_id":"cl3mvbinv000u18uqg62u03aq"},{"name":"svg","_id":"cl3mvbiny001118uqhxy794nh"},{"name":"react","_id":"cl3mvbio0001418uqh7kkhisa"}]}}