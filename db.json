{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"70f5bd2f821ccb8c3693db3cdc79aeb83384c263","modified":1675321785652},{"_id":"source/_posts/d3.md","hash":"5b2ce760d36ab67d16c2771e5f2fea102021fae2","modified":1634175521000},{"_id":"source/_posts/CommonJS和ESModule的区别.md","hash":"979f1a0e6f7787fc6ea435e18bd54aec29a02fb4","modified":1675237219010},{"_id":"source/_posts/echarts.md","hash":"059c379416e2e5e044d66181ec797652efba9043","modified":1634174676537},{"_id":"source/_posts/react.md","hash":"f67e6336fb5ae333db43b5392bd6ffdd82d1611e","modified":1634174567096},{"_id":"source/_posts/js高级.md","hash":"adbcfa6f6a4b5d10ad495879c2d8db446426c1e6","modified":1667286833122},{"_id":"source/_posts/svg.md","hash":"076ade0f068720fd93ae5efff7552bb639ac96cc","modified":1634007704120},{"_id":"source/_posts/搭建jenkins.md","hash":"dab80db49c2acd4bbf186a0733d5f556943c422e","modified":1644477686000},{"_id":"source/_posts/设计模式.md","hash":"ca3f68b5de7b61643e4e88049b3228211f820737","modified":1675321828370},{"_id":"source/_posts/h5与ue4通讯.md","hash":"c5562e3be23fdbcb155d7c035216e355a9bdfbeb","modified":1634549897537},{"_id":"source/about/index.md","hash":"64e5c8f7a85a56901fc9933819166691c4b9405b","modified":1633947611008},{"_id":"source/contact/index.md","hash":"a35f736aafe98684cf3656a769dcb58cf08602d9","modified":1633967103582},{"_id":"source/_posts/浏览器进程和线程.md","hash":"2eff2c952258da4166657c63b87b298eae3aaa5b","modified":1648046676804},{"_id":"source/categories/index.md","hash":"4f7d18516ccfef716cde6a0bbacbfdd026bca636","modified":1633967054888},{"_id":"source/tags/index.md","hash":"2174b6bda01163c45fd2e4451484f9a27a8c9d5c","modified":1633967131503},{"_id":"source/404/index.md","hash":"f856d43418c22a2e0acda0dc8dfc338c5f591fb4","modified":1633947728096},{"_id":"source/_posts/.DS_Store","hash":"327685590938232c93fa28d73e16cdc6eb46ab42","modified":1675236944178},{"_id":"source/_posts/浏览器缓存机制和缓存策略.md","hash":"258e36a7d8df27e2b7c328c456ad3fab156a4679","modified":1667464547338},{"_id":"source/_posts/浏览器页面的渲染过程.md","hash":"48b48bf9b5c8933b5e2fe5110b2c790fd6268e78","modified":1645462020322},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1653560635208},{"_id":"themes/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1653560635208},{"_id":"themes/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/package.json","hash":"980a730164d9f145a3271ed64d7122b7cee6d590","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1653560635210},{"_id":"themes/hexo-theme-fluid/_config.yml","hash":"0943745be04f7af08e3ba7fcdcb105c8f90b9956","modified":1667464677000},{"_id":"themes/hexo-theme-fluid/layout/about.ejs","hash":"23e5db06cfdc1cb26503204f074db58647adfbf3","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/layout.ejs","hash":"1452acee33611685b199c50e1bd4ecddbf6424e3","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/index.ejs","hash":"952d3f27cd7a245848fa1c4a1f5c8912500c2ee1","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/links.ejs","hash":"edcbef65037759c3a7b3539f2edcd72b082267e9","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/post.ejs","hash":"3a812de943457c0c544832daa1957420883aca96","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1653560635209},{"_id":"themes/hexo-theme-fluid/layout/page.ejs","hash":"a4a6b184bd91d9fe090da28891e74afc3b71c7fd","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1653560635215},{"_id":"themes/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/layout/_partials/head.ejs","hash":"eb2c46aa2508ea65d6e5c397c4bc20d05761d754","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"3d8912b68fcf51c38f6e1c5dd2bd74657bb3b7fb","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1653560635217},{"_id":"themes/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/layout/_partials/header.ejs","hash":"536eedc03faae3b35dc69abd478634d453061a0a","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1653560635225},{"_id":"themes/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1653560635223},{"_id":"themes/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1653560635225},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/source/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1653560635224},{"_id":"themes/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1653560635223},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1653560635211},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1653560635212},{"_id":"themes/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"57358e2164284f33f3bc81d5f602c620aeab942f","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"ef56f0903762a7a2c853417dfa6b0463440295e0","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"129a8b19ab26efd02ff1806ff4012376d2cd3497","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"c80bdc171aa53eb7205dcdc77764cec87a1dafd6","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"cb78296da15c7a8a6957cff2129294cc4815513b","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"54933c294d9b469a76a5ed36328e778ed740158f","modified":1653560635216},{"_id":"themes/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1653560635213},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"359cbcb0e222c23c8a0c5a99034a8a51f667a9ce","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1653560635214},{"_id":"themes/hexo-theme-fluid/source/css/_variables/base.styl","hash":"2465f604eea63b14cd2b0cc142769d963a0193a0","modified":1653560635222},{"_id":"themes/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1653560635218},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"5f4a17a20ddbf18c8ea6c66638b764905e4386b3","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"e24cd1186aae10bf897eed9cfd5278247b6300eb","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"e6e48d6ba2951ce4abc2876600f85eef64095338","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"078e5496a1852952ce4ee49016e86b9f70d31908","modified":1653560635221},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"696e429284bda7ae0fffe62ca84cb01a9243ecf0","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1653560635219},{"_id":"themes/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1653560635220},{"_id":"themes/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1653560635223},{"_id":"public/search.xml","hash":"1aac1ecd2757ad67578c9898155331d0ec173877","modified":1675321840488},{"_id":"public/local-search.xml","hash":"8534edef13af6e72e2ca49cbc56913215fd0c441","modified":1675321840488},{"_id":"public/about/index.html","hash":"008eaf571862076c0a164d8175119417c17a44c3","modified":1675321840488},{"_id":"public/contact/index.html","hash":"762ddeb67c057e0e0107b78d874afdd9c4d67e1b","modified":1675321840488},{"_id":"public/categories/index.html","hash":"498ef4e4dd65b9f3aebe0b639101d9da6c9a2331","modified":1675321840488},{"_id":"public/tags/index.html","hash":"997c0d76e050e85d5ee7809e9f16c5f0f28e37b1","modified":1675321840488},{"_id":"public/404/index.html","hash":"21f025cfc81e9c4a1378c8aa25aa8400c1ec1f51","modified":1675321840488},{"_id":"public/categories/前端可视化库/index.html","hash":"f9c7dfa7f441afbe0d14c0a2b2b43e354b9c2e82","modified":1675321840488},{"_id":"public/categories/h5与ue4/index.html","hash":"02c1096884acdf923773266aa8925d0521403f54","modified":1675321840488},{"_id":"public/categories/前端工程化/index.html","hash":"85cac27fcdd530cd978f5b2cb0e1e2f182c74de7","modified":1675321840488},{"_id":"public/categories/Javascript/index.html","hash":"4f7321eb917bbd909b64e6ee7df0a4dc99ea3b28","modified":1675321840488},{"_id":"public/categories/自动化部署/index.html","hash":"b34213f08d9d73d1e00f46db5dae3dc5b2f7461e","modified":1675321840488},{"_id":"public/categories/前端框架/index.html","hash":"04cf7dbab8b413168e5c7f546b8e2a7382342992","modified":1675321840488},{"_id":"public/categories/浏览器相关知识/index.html","hash":"9bd88290ec905918d95506ec43d66fc061bfa5db","modified":1675321840488},{"_id":"public/categories/设计模式/index.html","hash":"6d618c548ad3bdf1e06a5bc6c574fa8c46bb060a","modified":1675321840488},{"_id":"public/archives/index.html","hash":"503363d066911af060be275efb4501f7945dde31","modified":1675321840488},{"_id":"public/archives/2021/index.html","hash":"be60314e236003a41a22b13debf983897d357b8d","modified":1675321840488},{"_id":"public/archives/page/2/index.html","hash":"bb25cf6d7fb4ec362954c9adb77cf8cdb4eb6562","modified":1675321840488},{"_id":"public/archives/2021/07/index.html","hash":"b1cdbd471c5d8304a0f8c4da174ed1f1bb915a7a","modified":1675321840488},{"_id":"public/archives/2021/09/index.html","hash":"5cc66f4202dc93df44e1159d5b781de8c2a8809b","modified":1675321840488},{"_id":"public/archives/2021/10/index.html","hash":"64524da40bdbf69fc8d4e1950e43aebc1b4bb988","modified":1675321840488},{"_id":"public/archives/2022/02/index.html","hash":"999573c9c644201d867a39177c4221231c2a0f8e","modified":1675321840488},{"_id":"public/archives/2022/index.html","hash":"3f482447afe56284672fa844b27058789bdc7e0e","modified":1675321840488},{"_id":"public/archives/2022/03/index.html","hash":"791a195e4149c13b3b5b14f4548be775ff71fa23","modified":1675321840488},{"_id":"public/archives/2021/08/index.html","hash":"460b5d56f8196ad715e14d80f3acb1c0a55a5954","modified":1675321840488},{"_id":"public/archives/2022/11/index.html","hash":"14e280ae4dfb4d2d5331baf03c00111e24ad6938","modified":1675321840488},{"_id":"public/archives/2022/12/index.html","hash":"97f76e36785c5dc5a16301928b4f2ef33ba24ba1","modified":1675321840488},{"_id":"public/archives/2023/index.html","hash":"875d880951200a5774b238c6eb7f1b46838868ee","modified":1675321840488},{"_id":"public/archives/2023/02/index.html","hash":"996062f4de1e0a29da6ac376585d9ac5a965722f","modified":1675321840488},{"_id":"public/tags/echarts/index.html","hash":"70fe2194de3d835628dedad466f6135b4e4af9c4","modified":1675321840488},{"_id":"public/tags/JS模块化/index.html","hash":"15c69e0c083b594a05feb09d78bcaa05762ade92","modified":1675321840488},{"_id":"public/tags/Javascript/index.html","hash":"a594019b0c873844d3f8ce693032298fa9ba696c","modified":1675321840488},{"_id":"public/tags/jenkins/index.html","hash":"1b811ad2bec0fa2f269f84728419760686a5a419","modified":1675321840488},{"_id":"public/tags/react/index.html","hash":"2e4cb1045d8a9ef804e58757f2c6c5e1b41b69a3","modified":1675321840488},{"_id":"public/tags/svg/index.html","hash":"b6a9ddb2b137f1c9cee461e18966bef5a96aecb8","modified":1675321840488},{"_id":"public/tags/浏览器的进程和线程/index.html","hash":"b6243c1fac23f8a11e16fb808d46e341032f6d8d","modified":1675321840488},{"_id":"public/tags/设计模式/index.html","hash":"9dc697d103fdfcd42c2f6603675c588270ed0bcd","modified":1675321840488},{"_id":"public/tags/浏览器缓存机制和缓存策略/index.html","hash":"bcab34eb5bf5393ac078dcde56aca467fc2ac860","modified":1675321840488},{"_id":"public/tags/h5与ue4/index.html","hash":"8404855091848f24fa57127bce146c53b1790fe0","modified":1675321840488},{"_id":"public/tags/浏览器渲染/index.html","hash":"026ee7965b65f596cb4d49a1d53997c37221cf5a","modified":1675321840488},{"_id":"public/tags/d3js/index.html","hash":"49a89e96ed9f01a9c69937a6586ceeb8550f852c","modified":1675321840488},{"_id":"public/page/2/index.html","hash":"60129b491b444fbb40d82b1f4c221e9247053431","modified":1675321840488},{"_id":"public/404.html","hash":"b37a8463d68c4e9a46522306b78761bee721e1ba","modified":1675321840488},{"_id":"public/2023/02/01/commonjs-he-esmodule-de-qu-bie/index.html","hash":"9789e59601b503e04028f3ed0699c484d6d96107","modified":1675321840488},{"_id":"public/2022/12/06/she-ji-mo-shi/index.html","hash":"a28be8e585290a602e204905b79710b1b3757974","modified":1675321840488},{"_id":"public/2022/11/03/liu-lan-qi-huan-cun-ji-zhi-he-huan-cun-ce-lue/index.html","hash":"9b0c1078d724b555991acfd37750a6ee33f01617","modified":1675321840488},{"_id":"public/2022/03/23/liu-lan-qi-jin-cheng-he-xian-cheng/index.html","hash":"a91041cad549d9b936487540702b3452d46863f8","modified":1675321840488},{"_id":"public/2022/11/01/js-gao-ji/index.html","hash":"c0ce8c7172a7e1faf8165ed805e073cdeec9e051","modified":1675321840488},{"_id":"public/2022/02/22/liu-lan-qi-ye-mian-de-xuan-ran-guo-cheng/index.html","hash":"02ba8d0ee1308bb7e3ecfe5299fae904503640f2","modified":1675321840488},{"_id":"public/2022/02/10/da-jian-jenkins/index.html","hash":"cf9ff19cfe261a288ec8bb5c957632e3779e5d9e","modified":1675321840488},{"_id":"public/2021/09/22/svg/index.html","hash":"d309888e13d01641d1a20015ab55c2defb6da3f8","modified":1675321840488},{"_id":"public/2021/10/18/h5-yu-ue4-tong-xun/index.html","hash":"84169d9af380f5b1c3d7c441888798c4a9efb14d","modified":1675321840488},{"_id":"public/2021/08/25/react/index.html","hash":"b1f16bb7000cc5b01a76828601e7dcf42c9507bc","modified":1675321840488},{"_id":"public/2021/07/17/echarts/index.html","hash":"8de03fd74c1b9ef0606f42c4310e8975c31e1eaf","modified":1675321840488},{"_id":"public/2021/07/14/d3/index.html","hash":"4bd6b00a7032dc752b281476c0a61702208ec41d","modified":1675321840488},{"_id":"public/index.html","hash":"cd9934bcbcadc1c417c7503d4ef078e29a7c4165","modified":1675321840488},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1675321840488},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1675321840488},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1675321840488},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1675321840488},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1675321840488},{"_id":"public/css/gitalk.css","hash":"2234d7496740d11b5b53aaaef9155dcb2c6f3f73","modified":1675321840488},{"_id":"public/css/highlight-dark.css","hash":"5ab9082a6fd29f7f8ffad02a606967bb841a2ab4","modified":1675321840488},{"_id":"public/css/highlight.css","hash":"54b718c687ce8460e10d501c1eb53a8098942c1e","modified":1675321840488},{"_id":"public/js/boot.js","hash":"4288142bbc88feaab612041501128dcc742736d5","modified":1675321840488},{"_id":"public/js/img-lazyload.js","hash":"ac2ff1b8443cba055fa8f51e206392c19f627322","modified":1675321840488},{"_id":"public/js/events.js","hash":"c97f83cf37b1bb0761a33d9d78e10ae3b5a72c60","modified":1675321840488},{"_id":"public/js/leancloud.js","hash":"a102abbdd0102f0ff6524c870359c1af2a7b6c9c","modified":1675321840488},{"_id":"public/js/local-search.js","hash":"93c0e4266bde2af8aad7ecf2550c4354fb756375","modified":1675321840488},{"_id":"public/js/plugins.js","hash":"02fbe3be6741a1506b4838a63562614e9de7cd0a","modified":1675321840488},{"_id":"public/js/utils.js","hash":"a663a634bf0f32ec29490d8d69f9337a46ad565c","modified":1675321840488},{"_id":"public/js/color-schema.js","hash":"7af74b80ed6ad2ec5679128878b0348a45837a96","modified":1675321840488},{"_id":"public/css/main.css","hash":"9c75eb04ef33afcabbaf044fa5d90227e35429d7","modified":1675321840488},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1675321840488}],"Category":[{"name":"前端可视化库","_id":"cldmrd9ks0004i024d3fr7mug"},{"name":"h5与ue4","_id":"cldmrd9ku0009i02437ragvvd"},{"name":"前端工程化","_id":"cldmrd9kx000hi024gfpp0gmo"},{"name":"Javascript","_id":"cldmrd9kz000mi024fqekh1u2"},{"name":"自动化部署","_id":"cldmrd9l1000si02406nyg36b"},{"name":"前端框架","_id":"cldmrd9l3000zi024d22411pz"},{"name":"浏览器相关知识","_id":"cldmrd9l40014i02464zx585e"},{"name":"设计模式","_id":"cldmrd9l40019i02459i52q7z"}],"Data":[],"Page":[{"title":"有关于我","date":"2021-10-11T10:17:45.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 有关于我\ndate: 2021-10-11 18:17:45\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2021-10-11T10:20:11.008Z","path":"about/index.html","comments":1,"_id":"cldmrd9kk0000i0240qov1xoe","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"联系小的","date":"2021-10-11T10:20:51.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: 联系小的\ndate: 2021-10-11 18:20:51\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2021-10-11T15:45:03.582Z","path":"contact/index.html","comments":1,"_id":"cldmrd9kp0002i024h4bl4x0r","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"categories","date":"2021-10-11T10:43:03.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-10-11 18:43:03\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2021-10-11T15:44:14.888Z","path":"categories/index.html","comments":1,"_id":"cldmrd9kt0006i024hqnc4ut0","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"🏷️标签","date":"2021-10-11T10:20:39.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 🏷️标签\ndate: 2021-10-11 18:20:39\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2021-10-11T15:45:31.503Z","path":"tags/index.html","comments":1,"_id":"cldmrd9kt0007i024eoffdqyz","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"404","date":"2018-09-30T09:25:30.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2018-09-30 17:25:30\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---\n","updated":"2021-10-11T10:22:08.096Z","path":"404/index.html","comments":1,"_id":"cldmrd9ku0008i024bi9b2xwo","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"echarts学习笔记","keywords":"echarts","_content":"### 一、柱状图（type为bar）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.xAxis和yAxis\n\ntype为category时，需要指定data\n\ntype为value时，data在series中指定\n\n#### 3.常见效果\n\n- 标记：最大值、最小值、平均值\n\n  ```javascript\n  markPoint：{\n    data: [\n      {\n        type: 'max'，\n        name: '最大值'\n      },\n      {\n        type: 'min',\n        name: '最小值'\n      }\n    ]\n  },\n    markLine: {\n      data: [\n        {\n          type: 'average'，\n          name: '平均值'\n        }\n      ]\n    }\n  ```\n\n\n- 显示：\n\n  label：数值显示\n\n  barWidth： 柱宽度\n\n  横向柱状图：xAxis和yAxis配置互换\n\n### 二、通用配置\n\n- title标题\n  - 文字样式：textStyle\n  - 标题边框：borderWidth、borderColor、borderRadius\n  - 标题位置：left、top、right、bottom\n- tooltip提示框组件\n  - 触发类型：trigger\n    - item\n    - axis\n  - 触发时机：triggerOn\n    - mouseover\n    - click\n  - 格式化：formatter\n    - 字符串模板\n    - 回调函数（参数：arg）\n- toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）\n  - feature（显示工具栏按钮）\n    - savaAsImage（导出图片）\n    - dataView（数据视图）\n    - dataZoom（数据区域缩放）\n    - restore（重置）\n    - magicType（动态类型切换）：如magicType： { type: ['bar', 'line']}\n- legend图例（用于筛选系列，需要和series配合使用）\n  - legend中的data是一个数组\n  - legend中的data的值需要和series数组中某组数据的name值一致\n\n### 三、折线图（type为line）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.常用效果\n\n- 标记：最大值、最小值、平均值、标注区间\n  - markPoint\n  - markLine\n  - markArea\n- 线条控制：平滑、风格\n  - smooth、lineStyle \n- 填充风格\n  - areaStyle\n- 紧挨y轴边缘（设置在xAxis）\n  - boundaryGap\n- 缩放：脱离0值比例\n  - scale：true\n- 堆叠图\n  - stack：all\n  - 可以和areaStyle配合使用\n\n### 四、散点图（type为scatter）\n\n#### 1.数据格式\n\n二维数组\n\n#### 2.基本的散点图\n\n- x轴和y轴type都是value\n- x轴和y轴的数据，是一个二维数组\n- type为scatter\n\n#### 3.常用效果\n\n- 气泡图效果\n  - 散点大小不同：symbolSize\n  - 散点的颜色不同：itemStyle.color\n- 涟漪动画效果\n  - type: effectScatter\n  - showEffectOn: 'emphasis' 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）\n  - rippleEffect: { scale: 10} 散点涟漪效果的范围\n\n### 五、直角坐标系的常用配置\n\n直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）\n\n- grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）\n  - 显示gird\n    - show\n  - grid的边框\n    - borderWidth、borderColor\n  - grid的位置和大小\n    - left\n    - top\n    - right\n    - bottom\n- axis坐标轴（分为x轴和y轴）\n  - 坐标轴类型type\n    - value：数值周，自动会从目标数据中读取数据\n    - category：类目轴，该类型必须通过data设置类目数据\n  - 显示位置position\n    - xAxis：可取值为top或bottom\n    - yAxis：可取值为left或right\n- 区域缩放dataZoom\n  - dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器\n  - 类型type\n    - slider：滑块控制缩放\n    - inside：内置，依靠鼠标滚轮或者双指缩放\n  - 指明产生作用的轴\n    - xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可\n    - yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可\n  - 指明初始状态的缩放情况\n    - start：数据窗口范围的起始百分比\n    - end：数据窗口范围的结束百分比\n\n### 六、饼图（type为pie）\n\n#### 1.数据格式\n\njson数据：data: [{name: '京东'，value: '9000'}]\n\n#### 2.基本的饼图\n\n- 数据是json数据格式\n- type为pie\n- 无须配置xAxis和yAxis\n\n#### 3.饼图常见效果\n\n- 显示数值\n  - lable.formatter\n- 圆环\n  - 设置两个半径 radius：['50%', '70%'] 分别是内半径和外半径\n- 南丁格尔图\n  - roseType：'radius'\n- 选中效果\n  - 选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）\n  - 选中偏移量 selectOffset：30\n\n### 七、地图（type：map）\n\n#### 1.矢量地图的实现步骤\n\n- Echarts最基本的代码结构\n  - 引入js文件\n  - 带宽高的DOM容器\n  - init初始化对象\n  - setOption设置option\n- 准备中国的矢量地图json文件（http://datav.aliyun.com/tools/atlas/index.html#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5）\n- 使用ajax获取json\n  - $.get('json/map/china.json', function(chinaJson){})\n- 往echarts全局对象注册地图的json数据\n  - echarts.registerMap('chinaMap', chinaJson)\n- 在geo下设置\n  - type:'map'\n  - map:'chinaMap'\n\n#### 2.常用配置\n\n- 缩放拖动\n  - roam：true\n- 名称显示\n  - label\n- 初始缩放比例\n  - zoom：2（2倍）\n- 地图中心点\n  - center\n\n#### 3.常见效果\n\n- 不同城市颜色不同（如空气质量）\n\n  1. 显示基本的中国地图\n\n  2. 城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ''}]的格式，其中name属性必须和省份名一致）\n\n  3. 将series下的数据与geo关联起来\n\n     设置type: 'map'，geoIndex:0\n\n  4. 结合visualMap配合使用\n\n     visualMap: {min: 0, max: 40, range: { color: ['white', 'red']}}\n\n- 地图和散点图结合\n\n  1. 给series下配置散点图对象\n\n  2. 准备好散点数据，设置给新对象的data（二维数组，地图坐标）\n\n  3. 配置新对象的type为effectScatter\n\n  4. 让散点图使用地图坐标系统\n\n     coordinateSystem: 'geo'\n\n  5. 让涟漪的效果更加明显\n\n     rippleEffect：{ scale：10 }\n\n### 八、雷达图（type：radar）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 定义各个维度的最大值（在radar属性下）\n  - indicator：[{name: '易用性', max: 100]}]\n- 准备具体产品的数据\n  - 在series下设置data：[{name: '华为手机', value: [80, 80, 90, 95, 85]}\n- 设置图表类型\n  - 在series下设置type：radar\n\n#### 2.常用配置\n\n- 显示数值:\n  - label\n- 区域面积（阴影）\n  - areaStyle\n- 绘制类型\n  - shape: 'circle' 默认值 polygon\n\n### 九、仪表盘（type：guage）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 准备数据，设置给series下的data\n  - data: [{value: 97}]\n- 图标类型\n  - 在series下设置type：guage\n\n#### 2.常用效果\n\n- 数值范围\n  - max\n  - min\n- 多个指针\n  - 增加series下data数组中的元素\n- 多个指针颜色差异\n  - itemStyle\n\n### 十、主题\n\n#### 1.内置主题\n\n- echarts中默认内置了两套主题：light、dark\n\n- 在初始化对象方法中init中可以指明\n\n  var chart = echarts.init(dom, 'light')\n\n  var chart = echarts.init(dom, 'dark')\n\n#### 2.自定义主题\n\n- 1.在官网主题编辑器中编辑主题\n- 2.下载主题js文件\n- 3.引入主题js文件\n- 4.在init方法中使用主题\n\n### 十一、调色盘\n\n#### 1.它是一组颜色，图形、系列会自动从其中选择颜色\n\n- 主题调色盘（主题js文件中全局注册的color）\n\n- 全局调色盘\n\n  options：{\n\n  ​\tcolor： ['red', 'green', 'blue']\n\n  }\n\n- 局部调色盘\n\n  series: [{\n\n  ​\ttype: 'bar',\n\n  ​\tcolor: ['red', 'green', 'blue']\n\n  }]\n\n#### 2.调色盘的作用遵循就近原则\n\n#### 3.颜色渐变\n\n- 线性渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'linear',\n        x: 0, // 在图元中的初始x位置\n        y: 0, // 在图元中的初始y位置\n        x2: 0,\n        y2: 1, // 1代表到底部，0.5在中间\n          colorStops: [{\n            offset: 0, color: 'red' // 0%处的颜色 \n          },{\n            offset: 1, color: 'blue' // 100%处的颜色\n          }]\n    }\n  }\n  ```\n\n- 径向渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'radial',\n        x: 0.5, \n        y: 0.5,\n        r: 0.5, // 扩散的半径\n          colorStops: [{\n            offset: 0, color: 'red'\n          }, {\n            offset: 1, color: 'blue'\n          }]\n    }\n  }\n  ```\n\n### 十二、样式\n\n- 直接样式\n  - itemStyle、textStyle、lineStyle、areaStyle、label\n- 高亮样式\n  - 在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label\n- 优先级高，会覆盖主题中、调色盘的效果\n\n### 十三、自适应\n\n当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化\n\n- 1.监听窗口大小变化事件\n\n- 2.在事件处理函数中调用echarts实例对象的resize方法即可\n\n  window.onresize = myChart.resize\n\n### 十四、加载动画\n\necharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可\n\n- 显示加载动画\n\n  mCharts.showLoading()\n\n- 隐藏加载动画\n\n  mCharts.hideLoading()\n\n### 十五、增量动画\n\n- 增量动画的实现方式\n  - mCharts.setOption\n    - 所有数据的更新都通过setOption实现\n    - 不用考虑数据到底产生了哪些变化\n    - echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化\n    - 新旧option的关系并不是相互覆盖的关系，而是相互整合的关系\n    - 我们在设置新的option的时候，只需要考虑到变化的部分就可以\n\n### 十六、动画配置项\n\n- 开启动画\n\n  - animation：true\n\n- 动画时长\n\n  - animationDuration：5000\n\n  ```javascript\n    animationDuration： function（arg） {\n      // 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组\n      return arg * 10\n    }\n    ```\n\n- 缓动动画\n\n  - animationEasing: 'bounceOut'\n\n- 动画阈值\n\n  - animationThreshold： 8\n  - 单中形式的元素数量大于这个阈值会关闭动画\n\n### 十七、全局Echarts对象常用方法\n\n- init方法\n\n  - 初始化Echarts实例对象\n  - 使用主题（第二个参数）\n\n- registerTheme方法\n\n  - 注册主题\n  - 只有注册过的主题，才能在init方法中使用该主题\n\n- registerMap方法\n\n  - 注册地图数据\n\n    ```javascript\n      $.get('json/map/china.json', function(ChinaJson) {\n        echarts.registerMap('china', chinaJson)\n      })\n      ```\n\n  - geo组件使用地图数据\n\n    ```javascript\n      var option = {\n        geo: {\n          type: 'map',\n          map: 'china'\n        }\n      }\n      ```\n\n- connect方法\n\n  - 一个页面中可以有多个独立的图表\n  - 每一个图表对应一个Echarts实例对象\n  - connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组\n    - 保存图片的自动拼接（saveAsImage）\n    - 刷新按钮\n    - 重置按钮\n    - 提示框联动、图例选择、数据范围修改等等\n\n### 十八、echartsInstance实例常用方法\n\n- setOption方法\n\n  - 设置或修改图表实例的配置项以及数据\n  - 多次调用setOption方法\n    - 合并新旧配置\n    - 增量动画\n\n- resize方法\n\n  - 重新计算和绘制图表\n  - 一般和window对象的resize事件结合使用\n    - window.onresize = mEcharts.resize\n\n- on\\off方法\n\n  - 绑定或者解绑事件处理函数\n  - 鼠标事件\n    - 常见事件：click、dbclick、mousedown、mousemove、mouseup等\n  - Echarts事件\n    - 常见事件：legendselectchanged、datazoom、pieselectchanged、ma'pselectchanged\n\n- dispatchAction\n\n  - 触发某些行为\n\n  - 使用代码模拟用户的行为\n\n  ```javascript\n    mCharts.dispatchAction({\n      type: 'hightlight', // 事件类型\n      seriesIndex: 0, // 图表索引(系列)\n      dataIndex: 1 // 图表中哪一项高亮\n    })\n    ```\n\n- clear\n\n  - 清空当前实例，会移除实例中所有的组件和图表\n  - 清空之后可以再次setOption\n\n- dispose方法\n\n  - 销毁实例\n  - 销毁后实例无法再被使用\n\n### 十九、websocket的基本使用\n\n- 后端\n\n  - 安装包\n\n    - npm i ws\n\n  - 创建对象\n\n    ```javascript\n      const webSocket = require('ws')\n      const wss = new WebSocket.server({\n        port: '8080'\n      })\n      ```\n\n  - 监听事件\n\n    - 连接事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n        })\n        ```\n\n    - 接受数据事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n          client.on('message', msg => {\n            console.log('客户端发送数据过来了')\n          })\n        })\n        ```\n\n    - 发送数据\n\n      - client.send('hello socket from back-end')\n\n- 前端\n\n  - 创建对象\n\n    ```javascript\n      const ws = new WebSocket('ws://localhost:8080')\n      ```\n\n  - 监听事件\n\n    - 连接成功事件\n      - ws.onopen = () => {}\n    - 接受数据事件\n      - ws.onmessage = msg => {}\n    - 关闭连接事件\n      - ws.onclose = () => {}\n\n  - 发送数据\n\n    - ws.send","source":"_posts/echarts.md","raw":"---\ntitle: echarts学习笔记\ntag: echarts\nkeywords: echarts\ncategories: 前端可视化库\n---\n### 一、柱状图（type为bar）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.xAxis和yAxis\n\ntype为category时，需要指定data\n\ntype为value时，data在series中指定\n\n#### 3.常见效果\n\n- 标记：最大值、最小值、平均值\n\n  ```javascript\n  markPoint：{\n    data: [\n      {\n        type: 'max'，\n        name: '最大值'\n      },\n      {\n        type: 'min',\n        name: '最小值'\n      }\n    ]\n  },\n    markLine: {\n      data: [\n        {\n          type: 'average'，\n          name: '平均值'\n        }\n      ]\n    }\n  ```\n\n\n- 显示：\n\n  label：数值显示\n\n  barWidth： 柱宽度\n\n  横向柱状图：xAxis和yAxis配置互换\n\n### 二、通用配置\n\n- title标题\n  - 文字样式：textStyle\n  - 标题边框：borderWidth、borderColor、borderRadius\n  - 标题位置：left、top、right、bottom\n- tooltip提示框组件\n  - 触发类型：trigger\n    - item\n    - axis\n  - 触发时机：triggerOn\n    - mouseover\n    - click\n  - 格式化：formatter\n    - 字符串模板\n    - 回调函数（参数：arg）\n- toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）\n  - feature（显示工具栏按钮）\n    - savaAsImage（导出图片）\n    - dataView（数据视图）\n    - dataZoom（数据区域缩放）\n    - restore（重置）\n    - magicType（动态类型切换）：如magicType： { type: ['bar', 'line']}\n- legend图例（用于筛选系列，需要和series配合使用）\n  - legend中的data是一个数组\n  - legend中的data的值需要和series数组中某组数据的name值一致\n\n### 三、折线图（type为line）\n\n#### 1.数据格式\n\n一维数组\n\n#### 2.常用效果\n\n- 标记：最大值、最小值、平均值、标注区间\n  - markPoint\n  - markLine\n  - markArea\n- 线条控制：平滑、风格\n  - smooth、lineStyle \n- 填充风格\n  - areaStyle\n- 紧挨y轴边缘（设置在xAxis）\n  - boundaryGap\n- 缩放：脱离0值比例\n  - scale：true\n- 堆叠图\n  - stack：all\n  - 可以和areaStyle配合使用\n\n### 四、散点图（type为scatter）\n\n#### 1.数据格式\n\n二维数组\n\n#### 2.基本的散点图\n\n- x轴和y轴type都是value\n- x轴和y轴的数据，是一个二维数组\n- type为scatter\n\n#### 3.常用效果\n\n- 气泡图效果\n  - 散点大小不同：symbolSize\n  - 散点的颜色不同：itemStyle.color\n- 涟漪动画效果\n  - type: effectScatter\n  - showEffectOn: 'emphasis' 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）\n  - rippleEffect: { scale: 10} 散点涟漪效果的范围\n\n### 五、直角坐标系的常用配置\n\n直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）\n\n- grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）\n  - 显示gird\n    - show\n  - grid的边框\n    - borderWidth、borderColor\n  - grid的位置和大小\n    - left\n    - top\n    - right\n    - bottom\n- axis坐标轴（分为x轴和y轴）\n  - 坐标轴类型type\n    - value：数值周，自动会从目标数据中读取数据\n    - category：类目轴，该类型必须通过data设置类目数据\n  - 显示位置position\n    - xAxis：可取值为top或bottom\n    - yAxis：可取值为left或right\n- 区域缩放dataZoom\n  - dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器\n  - 类型type\n    - slider：滑块控制缩放\n    - inside：内置，依靠鼠标滚轮或者双指缩放\n  - 指明产生作用的轴\n    - xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可\n    - yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可\n  - 指明初始状态的缩放情况\n    - start：数据窗口范围的起始百分比\n    - end：数据窗口范围的结束百分比\n\n### 六、饼图（type为pie）\n\n#### 1.数据格式\n\njson数据：data: [{name: '京东'，value: '9000'}]\n\n#### 2.基本的饼图\n\n- 数据是json数据格式\n- type为pie\n- 无须配置xAxis和yAxis\n\n#### 3.饼图常见效果\n\n- 显示数值\n  - lable.formatter\n- 圆环\n  - 设置两个半径 radius：['50%', '70%'] 分别是内半径和外半径\n- 南丁格尔图\n  - roseType：'radius'\n- 选中效果\n  - 选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）\n  - 选中偏移量 selectOffset：30\n\n### 七、地图（type：map）\n\n#### 1.矢量地图的实现步骤\n\n- Echarts最基本的代码结构\n  - 引入js文件\n  - 带宽高的DOM容器\n  - init初始化对象\n  - setOption设置option\n- 准备中国的矢量地图json文件（http://datav.aliyun.com/tools/atlas/index.html#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5）\n- 使用ajax获取json\n  - $.get('json/map/china.json', function(chinaJson){})\n- 往echarts全局对象注册地图的json数据\n  - echarts.registerMap('chinaMap', chinaJson)\n- 在geo下设置\n  - type:'map'\n  - map:'chinaMap'\n\n#### 2.常用配置\n\n- 缩放拖动\n  - roam：true\n- 名称显示\n  - label\n- 初始缩放比例\n  - zoom：2（2倍）\n- 地图中心点\n  - center\n\n#### 3.常见效果\n\n- 不同城市颜色不同（如空气质量）\n\n  1. 显示基本的中国地图\n\n  2. 城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ''}]的格式，其中name属性必须和省份名一致）\n\n  3. 将series下的数据与geo关联起来\n\n     设置type: 'map'，geoIndex:0\n\n  4. 结合visualMap配合使用\n\n     visualMap: {min: 0, max: 40, range: { color: ['white', 'red']}}\n\n- 地图和散点图结合\n\n  1. 给series下配置散点图对象\n\n  2. 准备好散点数据，设置给新对象的data（二维数组，地图坐标）\n\n  3. 配置新对象的type为effectScatter\n\n  4. 让散点图使用地图坐标系统\n\n     coordinateSystem: 'geo'\n\n  5. 让涟漪的效果更加明显\n\n     rippleEffect：{ scale：10 }\n\n### 八、雷达图（type：radar）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 定义各个维度的最大值（在radar属性下）\n  - indicator：[{name: '易用性', max: 100]}]\n- 准备具体产品的数据\n  - 在series下设置data：[{name: '华为手机', value: [80, 80, 90, 95, 85]}\n- 设置图表类型\n  - 在series下设置type：radar\n\n#### 2.常用配置\n\n- 显示数值:\n  - label\n- 区域面积（阴影）\n  - areaStyle\n- 绘制类型\n  - shape: 'circle' 默认值 polygon\n\n### 九、仪表盘（type：guage）\n\n#### 1.实现步骤\n\n- echarts最基本的代码结构\n- 准备数据，设置给series下的data\n  - data: [{value: 97}]\n- 图标类型\n  - 在series下设置type：guage\n\n#### 2.常用效果\n\n- 数值范围\n  - max\n  - min\n- 多个指针\n  - 增加series下data数组中的元素\n- 多个指针颜色差异\n  - itemStyle\n\n### 十、主题\n\n#### 1.内置主题\n\n- echarts中默认内置了两套主题：light、dark\n\n- 在初始化对象方法中init中可以指明\n\n  var chart = echarts.init(dom, 'light')\n\n  var chart = echarts.init(dom, 'dark')\n\n#### 2.自定义主题\n\n- 1.在官网主题编辑器中编辑主题\n- 2.下载主题js文件\n- 3.引入主题js文件\n- 4.在init方法中使用主题\n\n### 十一、调色盘\n\n#### 1.它是一组颜色，图形、系列会自动从其中选择颜色\n\n- 主题调色盘（主题js文件中全局注册的color）\n\n- 全局调色盘\n\n  options：{\n\n  ​\tcolor： ['red', 'green', 'blue']\n\n  }\n\n- 局部调色盘\n\n  series: [{\n\n  ​\ttype: 'bar',\n\n  ​\tcolor: ['red', 'green', 'blue']\n\n  }]\n\n#### 2.调色盘的作用遵循就近原则\n\n#### 3.颜色渐变\n\n- 线性渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'linear',\n        x: 0, // 在图元中的初始x位置\n        y: 0, // 在图元中的初始y位置\n        x2: 0,\n        y2: 1, // 1代表到底部，0.5在中间\n          colorStops: [{\n            offset: 0, color: 'red' // 0%处的颜色 \n          },{\n            offset: 1, color: 'blue' // 100%处的颜色\n          }]\n    }\n  }\n  ```\n\n- 径向渐变\n\n  ```javascript\n  itemStyle: {\n    color: {\n      type: 'radial',\n        x: 0.5, \n        y: 0.5,\n        r: 0.5, // 扩散的半径\n          colorStops: [{\n            offset: 0, color: 'red'\n          }, {\n            offset: 1, color: 'blue'\n          }]\n    }\n  }\n  ```\n\n### 十二、样式\n\n- 直接样式\n  - itemStyle、textStyle、lineStyle、areaStyle、label\n- 高亮样式\n  - 在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label\n- 优先级高，会覆盖主题中、调色盘的效果\n\n### 十三、自适应\n\n当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化\n\n- 1.监听窗口大小变化事件\n\n- 2.在事件处理函数中调用echarts实例对象的resize方法即可\n\n  window.onresize = myChart.resize\n\n### 十四、加载动画\n\necharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可\n\n- 显示加载动画\n\n  mCharts.showLoading()\n\n- 隐藏加载动画\n\n  mCharts.hideLoading()\n\n### 十五、增量动画\n\n- 增量动画的实现方式\n  - mCharts.setOption\n    - 所有数据的更新都通过setOption实现\n    - 不用考虑数据到底产生了哪些变化\n    - echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化\n    - 新旧option的关系并不是相互覆盖的关系，而是相互整合的关系\n    - 我们在设置新的option的时候，只需要考虑到变化的部分就可以\n\n### 十六、动画配置项\n\n- 开启动画\n\n  - animation：true\n\n- 动画时长\n\n  - animationDuration：5000\n\n  ```javascript\n    animationDuration： function（arg） {\n      // 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组\n      return arg * 10\n    }\n    ```\n\n- 缓动动画\n\n  - animationEasing: 'bounceOut'\n\n- 动画阈值\n\n  - animationThreshold： 8\n  - 单中形式的元素数量大于这个阈值会关闭动画\n\n### 十七、全局Echarts对象常用方法\n\n- init方法\n\n  - 初始化Echarts实例对象\n  - 使用主题（第二个参数）\n\n- registerTheme方法\n\n  - 注册主题\n  - 只有注册过的主题，才能在init方法中使用该主题\n\n- registerMap方法\n\n  - 注册地图数据\n\n    ```javascript\n      $.get('json/map/china.json', function(ChinaJson) {\n        echarts.registerMap('china', chinaJson)\n      })\n      ```\n\n  - geo组件使用地图数据\n\n    ```javascript\n      var option = {\n        geo: {\n          type: 'map',\n          map: 'china'\n        }\n      }\n      ```\n\n- connect方法\n\n  - 一个页面中可以有多个独立的图表\n  - 每一个图表对应一个Echarts实例对象\n  - connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组\n    - 保存图片的自动拼接（saveAsImage）\n    - 刷新按钮\n    - 重置按钮\n    - 提示框联动、图例选择、数据范围修改等等\n\n### 十八、echartsInstance实例常用方法\n\n- setOption方法\n\n  - 设置或修改图表实例的配置项以及数据\n  - 多次调用setOption方法\n    - 合并新旧配置\n    - 增量动画\n\n- resize方法\n\n  - 重新计算和绘制图表\n  - 一般和window对象的resize事件结合使用\n    - window.onresize = mEcharts.resize\n\n- on\\off方法\n\n  - 绑定或者解绑事件处理函数\n  - 鼠标事件\n    - 常见事件：click、dbclick、mousedown、mousemove、mouseup等\n  - Echarts事件\n    - 常见事件：legendselectchanged、datazoom、pieselectchanged、ma'pselectchanged\n\n- dispatchAction\n\n  - 触发某些行为\n\n  - 使用代码模拟用户的行为\n\n  ```javascript\n    mCharts.dispatchAction({\n      type: 'hightlight', // 事件类型\n      seriesIndex: 0, // 图表索引(系列)\n      dataIndex: 1 // 图表中哪一项高亮\n    })\n    ```\n\n- clear\n\n  - 清空当前实例，会移除实例中所有的组件和图表\n  - 清空之后可以再次setOption\n\n- dispose方法\n\n  - 销毁实例\n  - 销毁后实例无法再被使用\n\n### 十九、websocket的基本使用\n\n- 后端\n\n  - 安装包\n\n    - npm i ws\n\n  - 创建对象\n\n    ```javascript\n      const webSocket = require('ws')\n      const wss = new WebSocket.server({\n        port: '8080'\n      })\n      ```\n\n  - 监听事件\n\n    - 连接事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n        })\n        ```\n\n    - 接受数据事件\n\n      ```javascript\n        wss.on('connection', client => {\n          console.log('有客户端连接')\n          client.on('message', msg => {\n            console.log('客户端发送数据过来了')\n          })\n        })\n        ```\n\n    - 发送数据\n\n      - client.send('hello socket from back-end')\n\n- 前端\n\n  - 创建对象\n\n    ```javascript\n      const ws = new WebSocket('ws://localhost:8080')\n      ```\n\n  - 监听事件\n\n    - 连接成功事件\n      - ws.onopen = () => {}\n    - 接受数据事件\n      - ws.onmessage = msg => {}\n    - 关闭连接事件\n      - ws.onclose = () => {}\n\n  - 发送数据\n\n    - ws.send","slug":"echarts","published":1,"date":"2021-07-17T08:49:18.000Z","updated":"2021-10-14T01:24:36.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9km0001i0242i0980ao","content":"<h3 id=\"一、柱状图（type为bar）\"><a href=\"#一、柱状图（type为bar）\" class=\"headerlink\" title=\"一、柱状图（type为bar）\"></a>一、柱状图（type为bar）</h3><h4 id=\"1-数据格式\"><a href=\"#1-数据格式\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-xAxis和yAxis\"><a href=\"#2-xAxis和yAxis\" class=\"headerlink\" title=\"2.xAxis和yAxis\"></a>2.xAxis和yAxis</h4><p>type为category时，需要指定data</p>\n<p>type为value时，data在series中指定</p>\n<h4 id=\"3-常见效果\"><a href=\"#3-常见效果\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>标记：最大值、最小值、平均值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">markPoint：&#123;<br>  <span class=\"hljs-attr\">data</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;max&#x27;</span>，<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最大值&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;min&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最小值&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br>  <span class=\"hljs-attr\">markLine</span>: &#123;<br>    <span class=\"hljs-attr\">data</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;average&#x27;</span>，<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;平均值&#x27;</span><br>      &#125;<br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>显示：</p>\n<p>label：数值显示</p>\n<p>barWidth： 柱宽度</p>\n<p>横向柱状图：xAxis和yAxis配置互换</p>\n</li>\n</ul>\n<h3 id=\"二、通用配置\"><a href=\"#二、通用配置\" class=\"headerlink\" title=\"二、通用配置\"></a>二、通用配置</h3><ul>\n<li>title标题<ul>\n<li>文字样式：textStyle</li>\n<li>标题边框：borderWidth、borderColor、borderRadius</li>\n<li>标题位置：left、top、right、bottom</li>\n</ul>\n</li>\n<li>tooltip提示框组件<ul>\n<li>触发类型：trigger<ul>\n<li>item</li>\n<li>axis</li>\n</ul>\n</li>\n<li>触发时机：triggerOn<ul>\n<li>mouseover</li>\n<li>click</li>\n</ul>\n</li>\n<li>格式化：formatter<ul>\n<li>字符串模板</li>\n<li>回调函数（参数：arg）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）<ul>\n<li>feature（显示工具栏按钮）<ul>\n<li>savaAsImage（导出图片）</li>\n<li>dataView（数据视图）</li>\n<li>dataZoom（数据区域缩放）</li>\n<li>restore（重置）</li>\n<li>magicType（动态类型切换）：如magicType： { type: [‘bar’, ‘line’]}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>legend图例（用于筛选系列，需要和series配合使用）<ul>\n<li>legend中的data是一个数组</li>\n<li>legend中的data的值需要和series数组中某组数据的name值一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、折线图（type为line）\"><a href=\"#三、折线图（type为line）\" class=\"headerlink\" title=\"三、折线图（type为line）\"></a>三、折线图（type为line）</h3><h4 id=\"1-数据格式-1\"><a href=\"#1-数据格式-1\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-常用效果\"><a href=\"#2-常用效果\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>标记：最大值、最小值、平均值、标注区间<ul>\n<li>markPoint</li>\n<li>markLine</li>\n<li>markArea</li>\n</ul>\n</li>\n<li>线条控制：平滑、风格<ul>\n<li>smooth、lineStyle </li>\n</ul>\n</li>\n<li>填充风格<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>紧挨y轴边缘（设置在xAxis）<ul>\n<li>boundaryGap</li>\n</ul>\n</li>\n<li>缩放：脱离0值比例<ul>\n<li>scale：true</li>\n</ul>\n</li>\n<li>堆叠图<ul>\n<li>stack：all</li>\n<li>可以和areaStyle配合使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、散点图（type为scatter）\"><a href=\"#四、散点图（type为scatter）\" class=\"headerlink\" title=\"四、散点图（type为scatter）\"></a>四、散点图（type为scatter）</h3><h4 id=\"1-数据格式-2\"><a href=\"#1-数据格式-2\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>二维数组</p>\n<h4 id=\"2-基本的散点图\"><a href=\"#2-基本的散点图\" class=\"headerlink\" title=\"2.基本的散点图\"></a>2.基本的散点图</h4><ul>\n<li>x轴和y轴type都是value</li>\n<li>x轴和y轴的数据，是一个二维数组</li>\n<li>type为scatter</li>\n</ul>\n<h4 id=\"3-常用效果\"><a href=\"#3-常用效果\" class=\"headerlink\" title=\"3.常用效果\"></a>3.常用效果</h4><ul>\n<li>气泡图效果<ul>\n<li>散点大小不同：symbolSize</li>\n<li>散点的颜色不同：itemStyle.color</li>\n</ul>\n</li>\n<li>涟漪动画效果<ul>\n<li>type: effectScatter</li>\n<li>showEffectOn: ‘emphasis’ 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）</li>\n<li>rippleEffect: { scale: 10} 散点涟漪效果的范围</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、直角坐标系的常用配置\"><a href=\"#五、直角坐标系的常用配置\" class=\"headerlink\" title=\"五、直角坐标系的常用配置\"></a>五、直角坐标系的常用配置</h3><p>直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）</p>\n<ul>\n<li>grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）<ul>\n<li>显示gird<ul>\n<li>show</li>\n</ul>\n</li>\n<li>grid的边框<ul>\n<li>borderWidth、borderColor</li>\n</ul>\n</li>\n<li>grid的位置和大小<ul>\n<li>left</li>\n<li>top</li>\n<li>right</li>\n<li>bottom</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>axis坐标轴（分为x轴和y轴）<ul>\n<li>坐标轴类型type<ul>\n<li>value：数值周，自动会从目标数据中读取数据</li>\n<li>category：类目轴，该类型必须通过data设置类目数据</li>\n</ul>\n</li>\n<li>显示位置position<ul>\n<li>xAxis：可取值为top或bottom</li>\n<li>yAxis：可取值为left或right</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>区域缩放dataZoom<ul>\n<li>dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器</li>\n<li>类型type<ul>\n<li>slider：滑块控制缩放</li>\n<li>inside：内置，依靠鼠标滚轮或者双指缩放</li>\n</ul>\n</li>\n<li>指明产生作用的轴<ul>\n<li>xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可</li>\n<li>yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可</li>\n</ul>\n</li>\n<li>指明初始状态的缩放情况<ul>\n<li>start：数据窗口范围的起始百分比</li>\n<li>end：数据窗口范围的结束百分比</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"六、饼图（type为pie）\"><a href=\"#六、饼图（type为pie）\" class=\"headerlink\" title=\"六、饼图（type为pie）\"></a>六、饼图（type为pie）</h3><h4 id=\"1-数据格式-3\"><a href=\"#1-数据格式-3\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>json数据：data: [{name: ‘京东’，value: ‘9000’}]</p>\n<h4 id=\"2-基本的饼图\"><a href=\"#2-基本的饼图\" class=\"headerlink\" title=\"2.基本的饼图\"></a>2.基本的饼图</h4><ul>\n<li>数据是json数据格式</li>\n<li>type为pie</li>\n<li>无须配置xAxis和yAxis</li>\n</ul>\n<h4 id=\"3-饼图常见效果\"><a href=\"#3-饼图常见效果\" class=\"headerlink\" title=\"3.饼图常见效果\"></a>3.饼图常见效果</h4><ul>\n<li>显示数值<ul>\n<li>lable.formatter</li>\n</ul>\n</li>\n<li>圆环<ul>\n<li>设置两个半径 radius：[‘50%’, ‘70%’] 分别是内半径和外半径</li>\n</ul>\n</li>\n<li>南丁格尔图<ul>\n<li>roseType：’radius’</li>\n</ul>\n</li>\n<li>选中效果<ul>\n<li>选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）</li>\n<li>选中偏移量 selectOffset：30</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、地图（type：map）\"><a href=\"#七、地图（type：map）\" class=\"headerlink\" title=\"七、地图（type：map）\"></a>七、地图（type：map）</h3><h4 id=\"1-矢量地图的实现步骤\"><a href=\"#1-矢量地图的实现步骤\" class=\"headerlink\" title=\"1.矢量地图的实现步骤\"></a>1.矢量地图的实现步骤</h4><ul>\n<li>Echarts最基本的代码结构<ul>\n<li>引入js文件</li>\n<li>带宽高的DOM容器</li>\n<li>init初始化对象</li>\n<li>setOption设置option</li>\n</ul>\n</li>\n<li>准备中国的矢量地图json文件（<a href=\"http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5%EF%BC%89\">http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5）</a></li>\n<li>使用ajax获取json<ul>\n<li>$.get(‘json/map/china.json’, function(chinaJson){})</li>\n</ul>\n</li>\n<li>往echarts全局对象注册地图的json数据<ul>\n<li>echarts.registerMap(‘chinaMap’, chinaJson)</li>\n</ul>\n</li>\n<li>在geo下设置<ul>\n<li>type:’map’</li>\n<li>map:’chinaMap’</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置\"><a href=\"#2-常用配置\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>缩放拖动<ul>\n<li>roam：true</li>\n</ul>\n</li>\n<li>名称显示<ul>\n<li>label</li>\n</ul>\n</li>\n<li>初始缩放比例<ul>\n<li>zoom：2（2倍）</li>\n</ul>\n</li>\n<li>地图中心点<ul>\n<li>center</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-常见效果-1\"><a href=\"#3-常见效果-1\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>不同城市颜色不同（如空气质量）</p>\n<ol>\n<li><p>显示基本的中国地图</p>\n</li>\n<li><p>城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ‘’}]的格式，其中name属性必须和省份名一致）</p>\n</li>\n<li><p>将series下的数据与geo关联起来</p>\n<p>设置type: ‘map’，geoIndex:0</p>\n</li>\n<li><p>结合visualMap配合使用</p>\n<p>visualMap: {min: 0, max: 40, range: { color: [‘white’, ‘red’]}}</p>\n</li>\n</ol>\n</li>\n<li><p>地图和散点图结合</p>\n<ol>\n<li><p>给series下配置散点图对象</p>\n</li>\n<li><p>准备好散点数据，设置给新对象的data（二维数组，地图坐标）</p>\n</li>\n<li><p>配置新对象的type为effectScatter</p>\n</li>\n<li><p>让散点图使用地图坐标系统</p>\n<p>coordinateSystem: ‘geo’</p>\n</li>\n<li><p>让涟漪的效果更加明显</p>\n<p>rippleEffect：{ scale：10 }</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"八、雷达图（type：radar）\"><a href=\"#八、雷达图（type：radar）\" class=\"headerlink\" title=\"八、雷达图（type：radar）\"></a>八、雷达图（type：radar）</h3><h4 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>定义各个维度的最大值（在radar属性下）<ul>\n<li>indicator：[{name: ‘易用性’, max: 100]}]</li>\n</ul>\n</li>\n<li>准备具体产品的数据<ul>\n<li>在series下设置data：[{name: ‘华为手机’, value: [80, 80, 90, 95, 85]}</li>\n</ul>\n</li>\n<li>设置图表类型<ul>\n<li>在series下设置type：radar</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置-1\"><a href=\"#2-常用配置-1\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>显示数值:<ul>\n<li>label</li>\n</ul>\n</li>\n<li>区域面积（阴影）<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>绘制类型<ul>\n<li>shape: ‘circle’ 默认值 polygon</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"九、仪表盘（type：guage）\"><a href=\"#九、仪表盘（type：guage）\" class=\"headerlink\" title=\"九、仪表盘（type：guage）\"></a>九、仪表盘（type：guage）</h3><h4 id=\"1-实现步骤-1\"><a href=\"#1-实现步骤-1\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>准备数据，设置给series下的data<ul>\n<li>data: [{value: 97}]</li>\n</ul>\n</li>\n<li>图标类型<ul>\n<li>在series下设置type：guage</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用效果-1\"><a href=\"#2-常用效果-1\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>数值范围<ul>\n<li>max</li>\n<li>min</li>\n</ul>\n</li>\n<li>多个指针<ul>\n<li>增加series下data数组中的元素</li>\n</ul>\n</li>\n<li>多个指针颜色差异<ul>\n<li>itemStyle</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十、主题\"><a href=\"#十、主题\" class=\"headerlink\" title=\"十、主题\"></a>十、主题</h3><h4 id=\"1-内置主题\"><a href=\"#1-内置主题\" class=\"headerlink\" title=\"1.内置主题\"></a>1.内置主题</h4><ul>\n<li><p>echarts中默认内置了两套主题：light、dark</p>\n</li>\n<li><p>在初始化对象方法中init中可以指明</p>\n<p>var chart = echarts.init(dom, ‘light’)</p>\n<p>var chart = echarts.init(dom, ‘dark’)</p>\n</li>\n</ul>\n<h4 id=\"2-自定义主题\"><a href=\"#2-自定义主题\" class=\"headerlink\" title=\"2.自定义主题\"></a>2.自定义主题</h4><ul>\n<li>1.在官网主题编辑器中编辑主题</li>\n<li>2.下载主题js文件</li>\n<li>3.引入主题js文件</li>\n<li>4.在init方法中使用主题</li>\n</ul>\n<h3 id=\"十一、调色盘\"><a href=\"#十一、调色盘\" class=\"headerlink\" title=\"十一、调色盘\"></a>十一、调色盘</h3><h4 id=\"1-它是一组颜色，图形、系列会自动从其中选择颜色\"><a href=\"#1-它是一组颜色，图形、系列会自动从其中选择颜色\" class=\"headerlink\" title=\"1.它是一组颜色，图形、系列会自动从其中选择颜色\"></a>1.它是一组颜色，图形、系列会自动从其中选择颜色</h4><ul>\n<li><p>主题调色盘（主题js文件中全局注册的color）</p>\n</li>\n<li><p>全局调色盘</p>\n<p>options：{</p>\n<p>​    color： [‘red’, ‘green’, ‘blue’]</p>\n<p>}</p>\n</li>\n<li><p>局部调色盘</p>\n<p>series: [{</p>\n<p>​    type: ‘bar’,</p>\n<p>​    color: [‘red’, ‘green’, ‘blue’]</p>\n<p>}]</p>\n</li>\n</ul>\n<h4 id=\"2-调色盘的作用遵循就近原则\"><a href=\"#2-调色盘的作用遵循就近原则\" class=\"headerlink\" title=\"2.调色盘的作用遵循就近原则\"></a>2.调色盘的作用遵循就近原则</h4><h4 id=\"3-颜色渐变\"><a href=\"#3-颜色渐变\" class=\"headerlink\" title=\"3.颜色渐变\"></a>3.颜色渐变</h4><ul>\n<li><p>线性渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;linear&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始x位置</span><br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始y位置</span><br>      <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 1代表到底部，0.5在中间</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> <span class=\"hljs-comment\">// 0%处的颜色 </span><br>        &#125;,&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span> <span class=\"hljs-comment\">// 100%处的颜色</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>径向渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;radial&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.5</span>, <br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.5</span>,<br>      <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-comment\">// 扩散的半径</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span><br>        &#125;, &#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"十二、样式\"><a href=\"#十二、样式\" class=\"headerlink\" title=\"十二、样式\"></a>十二、样式</h3><ul>\n<li>直接样式<ul>\n<li>itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>高亮样式<ul>\n<li>在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>优先级高，会覆盖主题中、调色盘的效果</li>\n</ul>\n<h3 id=\"十三、自适应\"><a href=\"#十三、自适应\" class=\"headerlink\" title=\"十三、自适应\"></a>十三、自适应</h3><p>当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化</p>\n<ul>\n<li><p>1.监听窗口大小变化事件</p>\n</li>\n<li><p>2.在事件处理函数中调用echarts实例对象的resize方法即可</p>\n<p>window.onresize = myChart.resize</p>\n</li>\n</ul>\n<h3 id=\"十四、加载动画\"><a href=\"#十四、加载动画\" class=\"headerlink\" title=\"十四、加载动画\"></a>十四、加载动画</h3><p>echarts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可</p>\n<ul>\n<li><p>显示加载动画</p>\n<p>mCharts.showLoading()</p>\n</li>\n<li><p>隐藏加载动画</p>\n<p>mCharts.hideLoading()</p>\n</li>\n</ul>\n<h3 id=\"十五、增量动画\"><a href=\"#十五、增量动画\" class=\"headerlink\" title=\"十五、增量动画\"></a>十五、增量动画</h3><ul>\n<li>增量动画的实现方式<ul>\n<li>mCharts.setOption<ul>\n<li>所有数据的更新都通过setOption实现</li>\n<li>不用考虑数据到底产生了哪些变化</li>\n<li>echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化</li>\n<li>新旧option的关系并不是相互覆盖的关系，而是相互整合的关系</li>\n<li>我们在设置新的option的时候，只需要考虑到变化的部分就可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十六、动画配置项\"><a href=\"#十六、动画配置项\" class=\"headerlink\" title=\"十六、动画配置项\"></a>十六、动画配置项</h3><ul>\n<li><p>开启动画</p>\n<ul>\n<li>animation：true</li>\n</ul>\n</li>\n<li><p>动画时长</p>\n<ul>\n<li>animationDuration：5000</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">animationDuration： <span class=\"hljs-keyword\">function</span>（arg） &#123;<br>  <span class=\"hljs-comment\">// 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组</span><br>  <span class=\"hljs-keyword\">return</span> arg * <span class=\"hljs-number\">10</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>缓动动画</p>\n<ul>\n<li>animationEasing: ‘bounceOut’</li>\n</ul>\n</li>\n<li><p>动画阈值</p>\n<ul>\n<li>animationThreshold： 8</li>\n<li>单中形式的元素数量大于这个阈值会关闭动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十七、全局Echarts对象常用方法\"><a href=\"#十七、全局Echarts对象常用方法\" class=\"headerlink\" title=\"十七、全局Echarts对象常用方法\"></a>十七、全局Echarts对象常用方法</h3><ul>\n<li><p>init方法</p>\n<ul>\n<li>初始化Echarts实例对象</li>\n<li>使用主题（第二个参数）</li>\n</ul>\n</li>\n<li><p>registerTheme方法</p>\n<ul>\n<li>注册主题</li>\n<li>只有注册过的主题，才能在init方法中使用该主题</li>\n</ul>\n</li>\n<li><p>registerMap方法</p>\n<ul>\n<li><p>注册地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;json/map/china.json&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ChinaJson</span>) &#123;<br>  echarts.<span class=\"hljs-title function_\">registerMap</span>(<span class=\"hljs-string\">&#x27;china&#x27;</span>, chinaJson)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>geo组件使用地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> option = &#123;<br>  <span class=\"hljs-attr\">geo</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;map&#x27;</span>,<br>    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-string\">&#x27;china&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>connect方法</p>\n<ul>\n<li>一个页面中可以有多个独立的图表</li>\n<li>每一个图表对应一个Echarts实例对象</li>\n<li>connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组<ul>\n<li>保存图片的自动拼接（saveAsImage）</li>\n<li>刷新按钮</li>\n<li>重置按钮</li>\n<li>提示框联动、图例选择、数据范围修改等等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十八、echartsInstance实例常用方法\"><a href=\"#十八、echartsInstance实例常用方法\" class=\"headerlink\" title=\"十八、echartsInstance实例常用方法\"></a>十八、echartsInstance实例常用方法</h3><ul>\n<li><p>setOption方法</p>\n<ul>\n<li>设置或修改图表实例的配置项以及数据</li>\n<li>多次调用setOption方法<ul>\n<li>合并新旧配置</li>\n<li>增量动画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>resize方法</p>\n<ul>\n<li>重新计算和绘制图表</li>\n<li>一般和window对象的resize事件结合使用<ul>\n<li>window.onresize = mEcharts.resize</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>on\\off方法</p>\n<ul>\n<li>绑定或者解绑事件处理函数</li>\n<li>鼠标事件<ul>\n<li>常见事件：click、dbclick、mousedown、mousemove、mouseup等</li>\n</ul>\n</li>\n<li>Echarts事件<ul>\n<li>常见事件：legendselectchanged、datazoom、pieselectchanged、ma’pselectchanged</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>dispatchAction</p>\n<ul>\n<li><p>触发某些行为</p>\n</li>\n<li><p>使用代码模拟用户的行为</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">mCharts.<span class=\"hljs-title function_\">dispatchAction</span>(&#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;hightlight&#x27;</span>, <span class=\"hljs-comment\">// 事件类型</span><br>  <span class=\"hljs-attr\">seriesIndex</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 图表索引(系列)</span><br>  <span class=\"hljs-attr\">dataIndex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 图表中哪一项高亮</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>clear</p>\n<ul>\n<li>清空当前实例，会移除实例中所有的组件和图表</li>\n<li>清空之后可以再次setOption</li>\n</ul>\n</li>\n<li><p>dispose方法</p>\n<ul>\n<li>销毁实例</li>\n<li>销毁后实例无法再被使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十九、websocket的基本使用\"><a href=\"#十九、websocket的基本使用\" class=\"headerlink\" title=\"十九、websocket的基本使用\"></a>十九、websocket的基本使用</h3><ul>\n<li><p>后端</p>\n<ul>\n<li><p>安装包</p>\n<ul>\n<li>npm i ws</li>\n</ul>\n</li>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> webSocket = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ws&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>.<span class=\"hljs-title function_\">server</span>(&#123;<br>  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;8080&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li><p>连接事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>接受数据事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>  client.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">msg</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;客户端发送数据过来了&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>发送数据</p>\n<ul>\n<li>client.send(‘hello socket from back-end’)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端</p>\n<ul>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8080&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li>连接成功事件<ul>\n<li>ws.onopen = () =&gt; {}</li>\n</ul>\n</li>\n<li>接受数据事件<ul>\n<li>ws.onmessage = msg =&gt; {}</li>\n</ul>\n</li>\n<li>关闭连接事件<ul>\n<li>ws.onclose = () =&gt; {}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送数据</p>\n<ul>\n<li>ws.send</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":6380,"excerpt":"","more":"<h3 id=\"一、柱状图（type为bar）\"><a href=\"#一、柱状图（type为bar）\" class=\"headerlink\" title=\"一、柱状图（type为bar）\"></a>一、柱状图（type为bar）</h3><h4 id=\"1-数据格式\"><a href=\"#1-数据格式\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-xAxis和yAxis\"><a href=\"#2-xAxis和yAxis\" class=\"headerlink\" title=\"2.xAxis和yAxis\"></a>2.xAxis和yAxis</h4><p>type为category时，需要指定data</p>\n<p>type为value时，data在series中指定</p>\n<h4 id=\"3-常见效果\"><a href=\"#3-常见效果\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>标记：最大值、最小值、平均值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">markPoint：&#123;<br>  <span class=\"hljs-attr\">data</span>: [<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;max&#x27;</span>，<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最大值&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;min&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;最小值&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br>  <span class=\"hljs-attr\">markLine</span>: &#123;<br>    <span class=\"hljs-attr\">data</span>: [<br>      &#123;<br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;average&#x27;</span>，<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;平均值&#x27;</span><br>      &#125;<br>    ]<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>显示：</p>\n<p>label：数值显示</p>\n<p>barWidth： 柱宽度</p>\n<p>横向柱状图：xAxis和yAxis配置互换</p>\n</li>\n</ul>\n<h3 id=\"二、通用配置\"><a href=\"#二、通用配置\" class=\"headerlink\" title=\"二、通用配置\"></a>二、通用配置</h3><ul>\n<li>title标题<ul>\n<li>文字样式：textStyle</li>\n<li>标题边框：borderWidth、borderColor、borderRadius</li>\n<li>标题位置：left、top、right、bottom</li>\n</ul>\n</li>\n<li>tooltip提示框组件<ul>\n<li>触发类型：trigger<ul>\n<li>item</li>\n<li>axis</li>\n</ul>\n</li>\n<li>触发时机：triggerOn<ul>\n<li>mouseover</li>\n<li>click</li>\n</ul>\n</li>\n<li>格式化：formatter<ul>\n<li>字符串模板</li>\n<li>回调函数（参数：arg）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>toolbox工具栏（导出图片、数据视图、数据区域缩放、重置、动态类型切换五个工具）<ul>\n<li>feature（显示工具栏按钮）<ul>\n<li>savaAsImage（导出图片）</li>\n<li>dataView（数据视图）</li>\n<li>dataZoom（数据区域缩放）</li>\n<li>restore（重置）</li>\n<li>magicType（动态类型切换）：如magicType： { type: [‘bar’, ‘line’]}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>legend图例（用于筛选系列，需要和series配合使用）<ul>\n<li>legend中的data是一个数组</li>\n<li>legend中的data的值需要和series数组中某组数据的name值一致</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三、折线图（type为line）\"><a href=\"#三、折线图（type为line）\" class=\"headerlink\" title=\"三、折线图（type为line）\"></a>三、折线图（type为line）</h3><h4 id=\"1-数据格式-1\"><a href=\"#1-数据格式-1\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>一维数组</p>\n<h4 id=\"2-常用效果\"><a href=\"#2-常用效果\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>标记：最大值、最小值、平均值、标注区间<ul>\n<li>markPoint</li>\n<li>markLine</li>\n<li>markArea</li>\n</ul>\n</li>\n<li>线条控制：平滑、风格<ul>\n<li>smooth、lineStyle </li>\n</ul>\n</li>\n<li>填充风格<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>紧挨y轴边缘（设置在xAxis）<ul>\n<li>boundaryGap</li>\n</ul>\n</li>\n<li>缩放：脱离0值比例<ul>\n<li>scale：true</li>\n</ul>\n</li>\n<li>堆叠图<ul>\n<li>stack：all</li>\n<li>可以和areaStyle配合使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"四、散点图（type为scatter）\"><a href=\"#四、散点图（type为scatter）\" class=\"headerlink\" title=\"四、散点图（type为scatter）\"></a>四、散点图（type为scatter）</h3><h4 id=\"1-数据格式-2\"><a href=\"#1-数据格式-2\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>二维数组</p>\n<h4 id=\"2-基本的散点图\"><a href=\"#2-基本的散点图\" class=\"headerlink\" title=\"2.基本的散点图\"></a>2.基本的散点图</h4><ul>\n<li>x轴和y轴type都是value</li>\n<li>x轴和y轴的数据，是一个二维数组</li>\n<li>type为scatter</li>\n</ul>\n<h4 id=\"3-常用效果\"><a href=\"#3-常用效果\" class=\"headerlink\" title=\"3.常用效果\"></a>3.常用效果</h4><ul>\n<li>气泡图效果<ul>\n<li>散点大小不同：symbolSize</li>\n<li>散点的颜色不同：itemStyle.color</li>\n</ul>\n</li>\n<li>涟漪动画效果<ul>\n<li>type: effectScatter</li>\n<li>showEffectOn: ‘emphasis’ 鼠标移入时才显示涟漪效果，默认值是render（渲染就显示涟漪效果）</li>\n<li>rippleEffect: { scale: 10} 散点涟漪效果的范围</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"五、直角坐标系的常用配置\"><a href=\"#五、直角坐标系的常用配置\" class=\"headerlink\" title=\"五、直角坐标系的常用配置\"></a>五、直角坐标系的常用配置</h3><p>直角坐标系的图表：柱状图（bar）、折线图（line）、散点图（scatter）</p>\n<ul>\n<li>grid网格（控制直角坐标系的布局和大小，x轴和y轴就是在grid的基础上进行绘制的）<ul>\n<li>显示gird<ul>\n<li>show</li>\n</ul>\n</li>\n<li>grid的边框<ul>\n<li>borderWidth、borderColor</li>\n</ul>\n</li>\n<li>grid的位置和大小<ul>\n<li>left</li>\n<li>top</li>\n<li>right</li>\n<li>bottom</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>axis坐标轴（分为x轴和y轴）<ul>\n<li>坐标轴类型type<ul>\n<li>value：数值周，自动会从目标数据中读取数据</li>\n<li>category：类目轴，该类型必须通过data设置类目数据</li>\n</ul>\n</li>\n<li>显示位置position<ul>\n<li>xAxis：可取值为top或bottom</li>\n<li>yAxis：可取值为left或right</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>区域缩放dataZoom<ul>\n<li>dataZoom用于区域缩放，对数据范围过滤，x轴和y轴都可以拥有。dataZoom是一个数组，可以配置多个区域缩放器</li>\n<li>类型type<ul>\n<li>slider：滑块控制缩放</li>\n<li>inside：内置，依靠鼠标滚轮或者双指缩放</li>\n</ul>\n</li>\n<li>指明产生作用的轴<ul>\n<li>xAxisIndex：设置缩放组件控制的是哪个x轴，一般写0即可</li>\n<li>yAxisIndex：设置缩放组件控制的是哪个y轴，一般写0即可</li>\n</ul>\n</li>\n<li>指明初始状态的缩放情况<ul>\n<li>start：数据窗口范围的起始百分比</li>\n<li>end：数据窗口范围的结束百分比</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"六、饼图（type为pie）\"><a href=\"#六、饼图（type为pie）\" class=\"headerlink\" title=\"六、饼图（type为pie）\"></a>六、饼图（type为pie）</h3><h4 id=\"1-数据格式-3\"><a href=\"#1-数据格式-3\" class=\"headerlink\" title=\"1.数据格式\"></a>1.数据格式</h4><p>json数据：data: [{name: ‘京东’，value: ‘9000’}]</p>\n<h4 id=\"2-基本的饼图\"><a href=\"#2-基本的饼图\" class=\"headerlink\" title=\"2.基本的饼图\"></a>2.基本的饼图</h4><ul>\n<li>数据是json数据格式</li>\n<li>type为pie</li>\n<li>无须配置xAxis和yAxis</li>\n</ul>\n<h4 id=\"3-饼图常见效果\"><a href=\"#3-饼图常见效果\" class=\"headerlink\" title=\"3.饼图常见效果\"></a>3.饼图常见效果</h4><ul>\n<li>显示数值<ul>\n<li>lable.formatter</li>\n</ul>\n</li>\n<li>圆环<ul>\n<li>设置两个半径 radius：[‘50%’, ‘70%’] 分别是内半径和外半径</li>\n</ul>\n</li>\n<li>南丁格尔图<ul>\n<li>roseType：’radius’</li>\n</ul>\n</li>\n<li>选中效果<ul>\n<li>选中模式 selectMode：single（可选中单个）\\multiple（可选中多个）</li>\n<li>选中偏移量 selectOffset：30</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"七、地图（type：map）\"><a href=\"#七、地图（type：map）\" class=\"headerlink\" title=\"七、地图（type：map）\"></a>七、地图（type：map）</h3><h4 id=\"1-矢量地图的实现步骤\"><a href=\"#1-矢量地图的实现步骤\" class=\"headerlink\" title=\"1.矢量地图的实现步骤\"></a>1.矢量地图的实现步骤</h4><ul>\n<li>Echarts最基本的代码结构<ul>\n<li>引入js文件</li>\n<li>带宽高的DOM容器</li>\n<li>init初始化对象</li>\n<li>setOption设置option</li>\n</ul>\n</li>\n<li>准备中国的矢量地图json文件（<a href=\"http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5%EF%BC%89\">http://datav.aliyun.com/tools/atlas/index.html#&amp;lat=30.332329214580188&amp;lng=106.72278672066881&amp;zoom=3.5）</a></li>\n<li>使用ajax获取json<ul>\n<li>$.get(‘json/map/china.json’, function(chinaJson){})</li>\n</ul>\n</li>\n<li>往echarts全局对象注册地图的json数据<ul>\n<li>echarts.registerMap(‘chinaMap’, chinaJson)</li>\n</ul>\n</li>\n<li>在geo下设置<ul>\n<li>type:’map’</li>\n<li>map:’chinaMap’</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置\"><a href=\"#2-常用配置\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>缩放拖动<ul>\n<li>roam：true</li>\n</ul>\n</li>\n<li>名称显示<ul>\n<li>label</li>\n</ul>\n</li>\n<li>初始缩放比例<ul>\n<li>zoom：2（2倍）</li>\n</ul>\n</li>\n<li>地图中心点<ul>\n<li>center</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-常见效果-1\"><a href=\"#3-常见效果-1\" class=\"headerlink\" title=\"3.常见效果\"></a>3.常见效果</h4><ul>\n<li><p>不同城市颜色不同（如空气质量）</p>\n<ol>\n<li><p>显示基本的中国地图</p>\n</li>\n<li><p>城市的空气质量数据设置给series（此处的数据必须是[{name: cityName, value: ‘’}]的格式，其中name属性必须和省份名一致）</p>\n</li>\n<li><p>将series下的数据与geo关联起来</p>\n<p>设置type: ‘map’，geoIndex:0</p>\n</li>\n<li><p>结合visualMap配合使用</p>\n<p>visualMap: {min: 0, max: 40, range: { color: [‘white’, ‘red’]}}</p>\n</li>\n</ol>\n</li>\n<li><p>地图和散点图结合</p>\n<ol>\n<li><p>给series下配置散点图对象</p>\n</li>\n<li><p>准备好散点数据，设置给新对象的data（二维数组，地图坐标）</p>\n</li>\n<li><p>配置新对象的type为effectScatter</p>\n</li>\n<li><p>让散点图使用地图坐标系统</p>\n<p>coordinateSystem: ‘geo’</p>\n</li>\n<li><p>让涟漪的效果更加明显</p>\n<p>rippleEffect：{ scale：10 }</p>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"八、雷达图（type：radar）\"><a href=\"#八、雷达图（type：radar）\" class=\"headerlink\" title=\"八、雷达图（type：radar）\"></a>八、雷达图（type：radar）</h3><h4 id=\"1-实现步骤\"><a href=\"#1-实现步骤\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>定义各个维度的最大值（在radar属性下）<ul>\n<li>indicator：[{name: ‘易用性’, max: 100]}]</li>\n</ul>\n</li>\n<li>准备具体产品的数据<ul>\n<li>在series下设置data：[{name: ‘华为手机’, value: [80, 80, 90, 95, 85]}</li>\n</ul>\n</li>\n<li>设置图表类型<ul>\n<li>在series下设置type：radar</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用配置-1\"><a href=\"#2-常用配置-1\" class=\"headerlink\" title=\"2.常用配置\"></a>2.常用配置</h4><ul>\n<li>显示数值:<ul>\n<li>label</li>\n</ul>\n</li>\n<li>区域面积（阴影）<ul>\n<li>areaStyle</li>\n</ul>\n</li>\n<li>绘制类型<ul>\n<li>shape: ‘circle’ 默认值 polygon</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"九、仪表盘（type：guage）\"><a href=\"#九、仪表盘（type：guage）\" class=\"headerlink\" title=\"九、仪表盘（type：guage）\"></a>九、仪表盘（type：guage）</h3><h4 id=\"1-实现步骤-1\"><a href=\"#1-实现步骤-1\" class=\"headerlink\" title=\"1.实现步骤\"></a>1.实现步骤</h4><ul>\n<li>echarts最基本的代码结构</li>\n<li>准备数据，设置给series下的data<ul>\n<li>data: [{value: 97}]</li>\n</ul>\n</li>\n<li>图标类型<ul>\n<li>在series下设置type：guage</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-常用效果-1\"><a href=\"#2-常用效果-1\" class=\"headerlink\" title=\"2.常用效果\"></a>2.常用效果</h4><ul>\n<li>数值范围<ul>\n<li>max</li>\n<li>min</li>\n</ul>\n</li>\n<li>多个指针<ul>\n<li>增加series下data数组中的元素</li>\n</ul>\n</li>\n<li>多个指针颜色差异<ul>\n<li>itemStyle</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十、主题\"><a href=\"#十、主题\" class=\"headerlink\" title=\"十、主题\"></a>十、主题</h3><h4 id=\"1-内置主题\"><a href=\"#1-内置主题\" class=\"headerlink\" title=\"1.内置主题\"></a>1.内置主题</h4><ul>\n<li><p>echarts中默认内置了两套主题：light、dark</p>\n</li>\n<li><p>在初始化对象方法中init中可以指明</p>\n<p>var chart = echarts.init(dom, ‘light’)</p>\n<p>var chart = echarts.init(dom, ‘dark’)</p>\n</li>\n</ul>\n<h4 id=\"2-自定义主题\"><a href=\"#2-自定义主题\" class=\"headerlink\" title=\"2.自定义主题\"></a>2.自定义主题</h4><ul>\n<li>1.在官网主题编辑器中编辑主题</li>\n<li>2.下载主题js文件</li>\n<li>3.引入主题js文件</li>\n<li>4.在init方法中使用主题</li>\n</ul>\n<h3 id=\"十一、调色盘\"><a href=\"#十一、调色盘\" class=\"headerlink\" title=\"十一、调色盘\"></a>十一、调色盘</h3><h4 id=\"1-它是一组颜色，图形、系列会自动从其中选择颜色\"><a href=\"#1-它是一组颜色，图形、系列会自动从其中选择颜色\" class=\"headerlink\" title=\"1.它是一组颜色，图形、系列会自动从其中选择颜色\"></a>1.它是一组颜色，图形、系列会自动从其中选择颜色</h4><ul>\n<li><p>主题调色盘（主题js文件中全局注册的color）</p>\n</li>\n<li><p>全局调色盘</p>\n<p>options：{</p>\n<p>​    color： [‘red’, ‘green’, ‘blue’]</p>\n<p>}</p>\n</li>\n<li><p>局部调色盘</p>\n<p>series: [{</p>\n<p>​    type: ‘bar’,</p>\n<p>​    color: [‘red’, ‘green’, ‘blue’]</p>\n<p>}]</p>\n</li>\n</ul>\n<h4 id=\"2-调色盘的作用遵循就近原则\"><a href=\"#2-调色盘的作用遵循就近原则\" class=\"headerlink\" title=\"2.调色盘的作用遵循就近原则\"></a>2.调色盘的作用遵循就近原则</h4><h4 id=\"3-颜色渐变\"><a href=\"#3-颜色渐变\" class=\"headerlink\" title=\"3.颜色渐变\"></a>3.颜色渐变</h4><ul>\n<li><p>线性渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;linear&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始x位置</span><br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 在图元中的初始y位置</span><br>      <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-comment\">// 1代表到底部，0.5在中间</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span> <span class=\"hljs-comment\">// 0%处的颜色 </span><br>        &#125;,&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span> <span class=\"hljs-comment\">// 100%处的颜色</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>径向渐变</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-attr\">itemStyle</span>: &#123;<br>  <span class=\"hljs-attr\">color</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;radial&#x27;</span>,<br>      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.5</span>, <br>      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.5</span>,<br>      <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-comment\">// 扩散的半径</span><br>        <span class=\"hljs-attr\">colorStops</span>: [&#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;red&#x27;</span><br>        &#125;, &#123;<br>          <span class=\"hljs-attr\">offset</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&#x27;blue&#x27;</span><br>        &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"十二、样式\"><a href=\"#十二、样式\" class=\"headerlink\" title=\"十二、样式\"></a>十二、样式</h3><ul>\n<li>直接样式<ul>\n<li>itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>高亮样式<ul>\n<li>在emphasis中包裹itemStyle、textStyle、lineStyle、areaStyle、label</li>\n</ul>\n</li>\n<li>优先级高，会覆盖主题中、调色盘的效果</li>\n</ul>\n<h3 id=\"十三、自适应\"><a href=\"#十三、自适应\" class=\"headerlink\" title=\"十三、自适应\"></a>十三、自适应</h3><p>当浏览器的大小发生变化的时候，如果想让图表也能随之适配变化</p>\n<ul>\n<li><p>1.监听窗口大小变化事件</p>\n</li>\n<li><p>2.在事件处理函数中调用echarts实例对象的resize方法即可</p>\n<p>window.onresize = myChart.resize</p>\n</li>\n</ul>\n<h3 id=\"十四、加载动画\"><a href=\"#十四、加载动画\" class=\"headerlink\" title=\"十四、加载动画\"></a>十四、加载动画</h3><p>echarts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可</p>\n<ul>\n<li><p>显示加载动画</p>\n<p>mCharts.showLoading()</p>\n</li>\n<li><p>隐藏加载动画</p>\n<p>mCharts.hideLoading()</p>\n</li>\n</ul>\n<h3 id=\"十五、增量动画\"><a href=\"#十五、增量动画\" class=\"headerlink\" title=\"十五、增量动画\"></a>十五、增量动画</h3><ul>\n<li>增量动画的实现方式<ul>\n<li>mCharts.setOption<ul>\n<li>所有数据的更新都通过setOption实现</li>\n<li>不用考虑数据到底产生了哪些变化</li>\n<li>echarts会找到两组数据之间的差异然后通过合适的动画取实现数据的变化</li>\n<li>新旧option的关系并不是相互覆盖的关系，而是相互整合的关系</li>\n<li>我们在设置新的option的时候，只需要考虑到变化的部分就可以</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十六、动画配置项\"><a href=\"#十六、动画配置项\" class=\"headerlink\" title=\"十六、动画配置项\"></a>十六、动画配置项</h3><ul>\n<li><p>开启动画</p>\n<ul>\n<li>animation：true</li>\n</ul>\n</li>\n<li><p>动画时长</p>\n<ul>\n<li>animationDuration：5000</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">animationDuration： <span class=\"hljs-keyword\">function</span>（arg） &#123;<br>  <span class=\"hljs-comment\">// 这里的arg是所有需要动画效果的图元的索引，会根据不同形式的图元元素进行分组</span><br>  <span class=\"hljs-keyword\">return</span> arg * <span class=\"hljs-number\">10</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>缓动动画</p>\n<ul>\n<li>animationEasing: ‘bounceOut’</li>\n</ul>\n</li>\n<li><p>动画阈值</p>\n<ul>\n<li>animationThreshold： 8</li>\n<li>单中形式的元素数量大于这个阈值会关闭动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十七、全局Echarts对象常用方法\"><a href=\"#十七、全局Echarts对象常用方法\" class=\"headerlink\" title=\"十七、全局Echarts对象常用方法\"></a>十七、全局Echarts对象常用方法</h3><ul>\n<li><p>init方法</p>\n<ul>\n<li>初始化Echarts实例对象</li>\n<li>使用主题（第二个参数）</li>\n</ul>\n</li>\n<li><p>registerTheme方法</p>\n<ul>\n<li>注册主题</li>\n<li>只有注册过的主题，才能在init方法中使用该主题</li>\n</ul>\n</li>\n<li><p>registerMap方法</p>\n<ul>\n<li><p>注册地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;json/map/china.json&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ChinaJson</span>) &#123;<br>  echarts.<span class=\"hljs-title function_\">registerMap</span>(<span class=\"hljs-string\">&#x27;china&#x27;</span>, chinaJson)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>geo组件使用地图数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> option = &#123;<br>  <span class=\"hljs-attr\">geo</span>: &#123;<br>    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;map&#x27;</span>,<br>    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-string\">&#x27;china&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>connect方法</p>\n<ul>\n<li>一个页面中可以有多个独立的图表</li>\n<li>每一个图表对应一个Echarts实例对象</li>\n<li>connect可以实现多图关联，传入联动目标为Echarts实例对象，支持数组<ul>\n<li>保存图片的自动拼接（saveAsImage）</li>\n<li>刷新按钮</li>\n<li>重置按钮</li>\n<li>提示框联动、图例选择、数据范围修改等等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十八、echartsInstance实例常用方法\"><a href=\"#十八、echartsInstance实例常用方法\" class=\"headerlink\" title=\"十八、echartsInstance实例常用方法\"></a>十八、echartsInstance实例常用方法</h3><ul>\n<li><p>setOption方法</p>\n<ul>\n<li>设置或修改图表实例的配置项以及数据</li>\n<li>多次调用setOption方法<ul>\n<li>合并新旧配置</li>\n<li>增量动画</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>resize方法</p>\n<ul>\n<li>重新计算和绘制图表</li>\n<li>一般和window对象的resize事件结合使用<ul>\n<li>window.onresize = mEcharts.resize</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>on\\off方法</p>\n<ul>\n<li>绑定或者解绑事件处理函数</li>\n<li>鼠标事件<ul>\n<li>常见事件：click、dbclick、mousedown、mousemove、mouseup等</li>\n</ul>\n</li>\n<li>Echarts事件<ul>\n<li>常见事件：legendselectchanged、datazoom、pieselectchanged、ma’pselectchanged</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>dispatchAction</p>\n<ul>\n<li><p>触发某些行为</p>\n</li>\n<li><p>使用代码模拟用户的行为</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">mCharts.<span class=\"hljs-title function_\">dispatchAction</span>(&#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;hightlight&#x27;</span>, <span class=\"hljs-comment\">// 事件类型</span><br>  <span class=\"hljs-attr\">seriesIndex</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 图表索引(系列)</span><br>  <span class=\"hljs-attr\">dataIndex</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// 图表中哪一项高亮</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>clear</p>\n<ul>\n<li>清空当前实例，会移除实例中所有的组件和图表</li>\n<li>清空之后可以再次setOption</li>\n</ul>\n</li>\n<li><p>dispose方法</p>\n<ul>\n<li>销毁实例</li>\n<li>销毁后实例无法再被使用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"十九、websocket的基本使用\"><a href=\"#十九、websocket的基本使用\" class=\"headerlink\" title=\"十九、websocket的基本使用\"></a>十九、websocket的基本使用</h3><ul>\n<li><p>后端</p>\n<ul>\n<li><p>安装包</p>\n<ul>\n<li>npm i ws</li>\n</ul>\n</li>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> webSocket = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;ws&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> wss = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>.<span class=\"hljs-title function_\">server</span>(&#123;<br>  <span class=\"hljs-attr\">port</span>: <span class=\"hljs-string\">&#x27;8080&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li><p>连接事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>接受数据事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">wss.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;connection&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">client</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有客户端连接&#x27;</span>)<br>  client.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">msg</span> =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;客户端发送数据过来了&#x27;</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n<li><p>发送数据</p>\n<ul>\n<li>client.send(‘hello socket from back-end’)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前端</p>\n<ul>\n<li><p>创建对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:8080&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>监听事件</p>\n<ul>\n<li>连接成功事件<ul>\n<li>ws.onopen = () =&gt; {}</li>\n</ul>\n</li>\n<li>接受数据事件<ul>\n<li>ws.onmessage = msg =&gt; {}</li>\n</ul>\n</li>\n<li>关闭连接事件<ul>\n<li>ws.onclose = () =&gt; {}</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>发送数据</p>\n<ul>\n<li>ws.send</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"h5与ue4通讯","keywords":"h5与ue4通讯 js与h5交互 web与h5通讯","_content":"## 一、技术方案：\n\nUE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信\n\n注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作\n\n## 二、前端技术栈\n\nvue3+quasar+axios+vue-router\n\n注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1\n\n## 三、核心流程\n\n<!--ue4传数据给h5后续补充-->\n\n1. h5传数据给UE4\n\n   - 判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）\n\n    ```js\n     const ue = window.ue;\n     const isHasUE = typeof ue !== \"undefined\" && ue !== null ? true : false;\n     ```\n\n   - 调用UE中定义的挂载在ue对象中的对应方法\n\n    ```js\n     function MinimizeApp(trackdata) {\n       return function(callback) {\n         if (!isHasUE) {\n           console.log(\"ue initial faild! can't call function!~\");\n           return;\n         }\n          // 这里的webapi是和ue同事沟通统一的名称 \n         ue.webapi\n         \t// 这里的方法名要全部小写，需要和ue同事进行统一\n           .minimizeapp(JSON.stringify(trackdata))\n           .then(function(ret) {\n             // ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue\n             callback(ret);\n           })\n           .catch(function(error) {\n             console.log(error);\n           });\n       };\n     }\n     ```\n\n     \n\n## 四、问题及解决方案\n\n1. UE4加载web项目显示空白问题\n\n   - 问题产生原因：UE4中的Chromium内核不支持ES module\n\n   - UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：\n\n    ```\n     CEF 3.3071.1611.g4a19305\n     Chromium    59.0.3071.15\n     OS  Windows\n     WebKit  537.36 (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)\n     JavaScript  5.9.211.4\n     Flash   \n     User Agent  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15 Safari/537.36\n     Command Line    \"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe\" --browser-subprocess-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe\" --no-sandbox --product-version=\"Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15\" --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources\" --locales-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales\" --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling\n     Module Path D:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll\n     Cache Path  D:/***/Saved/webcache\n     ```\n\n   - 通过查询该浏览器版本支持的对应功能（查询网站：[查询浏览器支持的语法、API等](http://html5test.com/))发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。\n\n   - ![cef3-htm5test](/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png)\n\n   - 解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着**如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。**使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换\n\n    ```vue\n     transpileDependencies: ['quasar' ]\n     ```\n\n2. h5给ue4传输数组数据或对象失败问题\n\n   - 问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作\n   - 解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()","source":"_posts/h5与ue4通讯.md","raw":"---\ntitle: h5与ue4通讯\ntag: h5与ue4\nkeywords: h5与ue4通讯 js与h5交互 web与h5通讯\ncategories: h5与ue4\n---\n## 一、技术方案：\n\nUE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信\n\n注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作\n\n## 二、前端技术栈\n\nvue3+quasar+axios+vue-router\n\n注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1\n\n## 三、核心流程\n\n<!--ue4传数据给h5后续补充-->\n\n1. h5传数据给UE4\n\n   - 判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）\n\n    ```js\n     const ue = window.ue;\n     const isHasUE = typeof ue !== \"undefined\" && ue !== null ? true : false;\n     ```\n\n   - 调用UE中定义的挂载在ue对象中的对应方法\n\n    ```js\n     function MinimizeApp(trackdata) {\n       return function(callback) {\n         if (!isHasUE) {\n           console.log(\"ue initial faild! can't call function!~\");\n           return;\n         }\n          // 这里的webapi是和ue同事沟通统一的名称 \n         ue.webapi\n         \t// 这里的方法名要全部小写，需要和ue同事进行统一\n           .minimizeapp(JSON.stringify(trackdata))\n           .then(function(ret) {\n             // ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue\n             callback(ret);\n           })\n           .catch(function(error) {\n             console.log(error);\n           });\n       };\n     }\n     ```\n\n     \n\n## 四、问题及解决方案\n\n1. UE4加载web项目显示空白问题\n\n   - 问题产生原因：UE4中的Chromium内核不支持ES module\n\n   - UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：\n\n    ```\n     CEF 3.3071.1611.g4a19305\n     Chromium    59.0.3071.15\n     OS  Windows\n     WebKit  537.36 (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)\n     JavaScript  5.9.211.4\n     Flash   \n     User Agent  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15 Safari/537.36\n     Command Line    \"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe\" --browser-subprocess-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe\" --no-sandbox --product-version=\"Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15\" --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources\" --locales-dir-path=\"D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales\" --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling\n     Module Path D:\\Program Files\\Epic Games\\UE_4.26\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll\n     Cache Path  D:/***/Saved/webcache\n     ```\n\n   - 通过查询该浏览器版本支持的对应功能（查询网站：[查询浏览器支持的语法、API等](http://html5test.com/))发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。\n\n   - ![cef3-htm5test](/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png)\n\n   - 解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着**如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。**使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换\n\n    ```vue\n     transpileDependencies: ['quasar' ]\n     ```\n\n2. h5给ue4传输数组数据或对象失败问题\n\n   - 问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作\n   - 解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()","slug":"h5与ue4通讯","published":1,"date":"2021-10-18T06:42:32.034Z","updated":"2021-10-18T09:38:17.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9kq0003i024g7288bfo","content":"<h2 id=\"一、技术方案：\"><a href=\"#一、技术方案：\" class=\"headerlink\" title=\"一、技术方案：\"></a>一、技术方案：</h2><p>UE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信</p>\n<p>注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作</p>\n<h2 id=\"二、前端技术栈\"><a href=\"#二、前端技术栈\" class=\"headerlink\" title=\"二、前端技术栈\"></a>二、前端技术栈</h2><p>vue3+quasar+axios+vue-router</p>\n<p>注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1</p>\n<h2 id=\"三、核心流程\"><a href=\"#三、核心流程\" class=\"headerlink\" title=\"三、核心流程\"></a>三、核心流程</h2><!--ue4传数据给h5后续补充-->\n\n<ol>\n<li><p>h5传数据给UE4</p>\n<ul>\n<li>判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ue = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">ue</span>;<br><span class=\"hljs-keyword\">const</span> isHasUE = <span class=\"hljs-keyword\">typeof</span> ue !== <span class=\"hljs-string\">&quot;undefined&quot;</span> &amp;&amp; ue !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>调用UE中定义的挂载在ue对象中的对应方法</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MinimizeApp</span>(<span class=\"hljs-params\">trackdata</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!isHasUE) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ue initial faild! can&#x27;t call function!~&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>     <span class=\"hljs-comment\">// 这里的webapi是和ue同事沟通统一的名称 </span><br>    ue.<span class=\"hljs-property\">webapi</span><br>    \t<span class=\"hljs-comment\">// 这里的方法名要全部小写，需要和ue同事进行统一</span><br>      .<span class=\"hljs-title function_\">minimizeapp</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(trackdata))<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>) &#123;<br>        <span class=\"hljs-comment\">// ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue</span><br>        <span class=\"hljs-title function_\">callback</span>(ret);<br>      &#125;)<br>      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>      &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"四、问题及解决方案\"><a href=\"#四、问题及解决方案\" class=\"headerlink\" title=\"四、问题及解决方案\"></a>四、问题及解决方案</h2><ol>\n<li><p>UE4加载web项目显示空白问题</p>\n<ul>\n<li><p>问题产生原因：UE4中的Chromium内核不支持ES module</p>\n</li>\n<li><p>UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：</p>\n</li>\n</ul>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">CEF</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">1611</span>.g4a19305<br><span class=\"hljs-attribute\">Chromium</span>    <span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span><br><span class=\"hljs-attribute\">OS</span>  Windows<br><span class=\"hljs-attribute\">WebKit</span>  <span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)<br><span class=\"hljs-attribute\">JavaScript</span>  <span class=\"hljs-number\">5.9.211.4</span><br><span class=\"hljs-attribute\">Flash</span>   <br><span class=\"hljs-attribute\">User</span> Agent  Mozilla/<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">0</span> (Windows NT <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">0</span>; Win64; x64) AppleWebKit/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (KHTML, like Gecko) Digital/++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>-CL-<span class=\"hljs-number\">15973114</span> UnrealEngine/<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>.<span class=\"hljs-number\">2</span>-<span class=\"hljs-number\">15973114</span>+++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span> Chrome/<span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span> Safari/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span><br><span class=\"hljs-attribute\">Command</span> Line    <span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe&quot;</span> --browser-subprocess-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe&quot;</span> --no-sandbox --product-version=<span class=\"hljs-string\">&quot;Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15&quot;</span> --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources&quot;</span> --locales-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales&quot;</span> --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling<br><span class=\"hljs-attribute\">Module</span> Path D:\\Program Files\\Epic Games\\UE_4.<span class=\"hljs-number\">26</span>\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll<br><span class=\"hljs-attribute\">Cache</span> Path  D:/***/Saved/webcache<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>通过查询该浏览器版本支持的对应功能（查询网站：<a href=\"http://html5test.com/\">查询浏览器支持的语法、API等</a>)发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。</p>\n</li>\n<li><p><img src=\"/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png\" alt=\"cef3-htm5test\"></p>\n</li>\n<li><p>解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着<strong>如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。</strong>使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换</p>\n</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">transpileDependencies: [&#x27;quasar&#x27; ]<br></code></pre></td></tr></table></figure></li>\n<li><p>h5给ue4传输数组数据或对象失败问题</p>\n<ul>\n<li>问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作</li>\n<li>解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":2718,"excerpt":"","more":"<h2 id=\"一、技术方案：\"><a href=\"#一、技术方案：\" class=\"headerlink\" title=\"一、技术方案：\"></a>一、技术方案：</h2><p>UE4通过本地路径导入前端打包的项目，引入对应的h5页面，借助UE4的WebBrowser插件实现与h5的双向通信</p>\n<p>注：本文档以纵横项目demo为例，主要介绍前端需要做的相关工作</p>\n<h2 id=\"二、前端技术栈\"><a href=\"#二、前端技术栈\" class=\"headerlink\" title=\"二、前端技术栈\"></a>二、前端技术栈</h2><p>vue3+quasar+axios+vue-router</p>\n<p>注：使用什么技术栈并不影响与ue的交互，但是后续在引入项目中会存在不兼容的问题，后续打包时需要配置进行polyfill处理，详见问题及解决方案1</p>\n<h2 id=\"三、核心流程\"><a href=\"#三、核心流程\" class=\"headerlink\" title=\"三、核心流程\"></a>三、核心流程</h2><!--ue4传数据给h5后续补充-->\n\n<ol>\n<li><p>h5传数据给UE4</p>\n<ul>\n<li>判断h5中全局环境下是否已经有ue对象（UE4中WebBrowser插件不同版本或者不同插件，可能拿到的是ue4对象，当前项目拿到的是ue对象）</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ue = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">ue</span>;<br><span class=\"hljs-keyword\">const</span> isHasUE = <span class=\"hljs-keyword\">typeof</span> ue !== <span class=\"hljs-string\">&quot;undefined&quot;</span> &amp;&amp; ue !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-literal\">true</span> : <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>调用UE中定义的挂载在ue对象中的对应方法</li>\n</ul>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">MinimizeApp</span>(<span class=\"hljs-params\">trackdata</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">callback</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!isHasUE) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;ue initial faild! can&#x27;t call function!~&quot;</span>);<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>     <span class=\"hljs-comment\">// 这里的webapi是和ue同事沟通统一的名称 </span><br>    ue.<span class=\"hljs-property\">webapi</span><br>    \t<span class=\"hljs-comment\">// 这里的方法名要全部小写，需要和ue同事进行统一</span><br>      .<span class=\"hljs-title function_\">minimizeapp</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(trackdata))<br>      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">ret</span>) &#123;<br>        <span class=\"hljs-comment\">// ret是调用ue的返回值。UE4中WebBrowser插件不同版本或者不同插件，可能返回值名称必须要是ReturnValue</span><br>        <span class=\"hljs-title function_\">callback</span>(ret);<br>      &#125;)<br>      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(error);<br>      &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"四、问题及解决方案\"><a href=\"#四、问题及解决方案\" class=\"headerlink\" title=\"四、问题及解决方案\"></a>四、问题及解决方案</h2><ol>\n<li><p>UE4加载web项目显示空白问题</p>\n<ul>\n<li><p>问题产生原因：UE4中的Chromium内核不支持ES module</p>\n</li>\n<li><p>UE4自带的WebBrowser使用CEF3（使用Chromium内核）, 对应的内核版本信息如下：</p>\n</li>\n</ul>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">CEF</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">1611</span>.g4a19305<br><span class=\"hljs-attribute\">Chromium</span>    <span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span><br><span class=\"hljs-attribute\">OS</span>  Windows<br><span class=\"hljs-attribute\">WebKit</span>  <span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (@b3f9fb3b948d9304d587a127c3e4f47b2ad78927)<br><span class=\"hljs-attribute\">JavaScript</span>  <span class=\"hljs-number\">5.9.211.4</span><br><span class=\"hljs-attribute\">Flash</span>   <br><span class=\"hljs-attribute\">User</span> Agent  Mozilla/<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">0</span> (Windows NT <span class=\"hljs-number\">10</span>.<span class=\"hljs-number\">0</span>; Win64; x64) AppleWebKit/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span> (KHTML, like Gecko) Digital/++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>-CL-<span class=\"hljs-number\">15973114</span> UnrealEngine/<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span>.<span class=\"hljs-number\">2</span>-<span class=\"hljs-number\">15973114</span>+++UE4+Release-<span class=\"hljs-number\">4</span>.<span class=\"hljs-number\">26</span> Chrome/<span class=\"hljs-number\">59</span>.<span class=\"hljs-number\">0</span>.<span class=\"hljs-number\">3071</span>.<span class=\"hljs-number\">15</span> Safari/<span class=\"hljs-number\">537</span>.<span class=\"hljs-number\">36</span><br><span class=\"hljs-attribute\">Command</span> Line    <span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UE4Editor.exe&quot;</span> --browser-subprocess-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/Win64/UnrealCEFSubProcess.exe&quot;</span> --no-sandbox --product-version=<span class=\"hljs-string\">&quot;Digital/++UE4+Release-4.26-CL-15973114 UnrealEngine/4.26.2-15973114+++UE4+Release-4.26 Chrome/59.0.3071.15&quot;</span> --lang=en --log-file=D:/Projects/digital-factory/Digital/Saved/Logs/cef3.log --log-severity=warning --resources-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources&quot;</span> --locales-dir-path=<span class=\"hljs-string\">&quot;D:/Program Files/Epic Games/UE_4.26/Engine/Binaries/ThirdParty/CEF3/Win64/Resources/locales&quot;</span> --enable-gpu --enable-gpu-compositing --enable-begin-frame-scheduling<br><span class=\"hljs-attribute\">Module</span> Path D:\\Program Files\\Epic Games\\UE_4.<span class=\"hljs-number\">26</span>\\Engine\\Binaries\\ThirdParty\\CEF3\\Win64\\libcef.dll<br><span class=\"hljs-attribute\">Cache</span> Path  D:/***/Saved/webcache<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>通过查询该浏览器版本支持的对应功能（查询网站：<a href=\"http://html5test.com/\">查询浏览器支持的语法、API等</a>)发现，该浏览器不支持ES module语法，需要对项目进行polyfill打补丁，让UE4支持项目中一些新的API。</p>\n</li>\n<li><p><img src=\"/Users/luyao/Desktop/wattman/zongheng/cef3-htm5test.png\" alt=\"cef3-htm5test\"></p>\n</li>\n<li><p>解决方案：vue-cli4中会默认这样它会根据源代码中出现的语言特性自动检测需要的 polyfill。这确保了最终包里 polyfill 数量的最小化。然而，这也意味着<strong>如果其中一个依赖需要特殊的 polyfill，默认情况下 Babel 无法将其检测出来。</strong>使用vue-cli4中的transpileDependencies选项，对可能有造成不兼容问题的依赖进行polyfill。如项目中对quasar进行转换</p>\n</li>\n</ul>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vue\">transpileDependencies: [&#x27;quasar&#x27; ]<br></code></pre></td></tr></table></figure></li>\n<li><p>h5给ue4传输数组数据或对象失败问题</p>\n<ul>\n<li>问题产生原因：与浏览器与后端进行数据传输类似，h5与ue进行数据传输也需要对数据进行序列化。由于平时使用axios进行网络数据请求，其内部对传输的数据就已经进行了序列化的操作，此处在与u4通信时，并不是通过axios，遗忘了对数据进行序列化的操作</li>\n<li>解决方案：使用浏览器的API对数据进行序列化操作后传给ue：JSON.stringify()</li>\n</ul>\n</li>\n</ol>\n"},{"title":"CommonJS和ESModule的区别","keywords":"JS模块化","_content":"\n## CommonJS 和 ESModule 的区别\n\n### 1.引入位置不同\n\n**commonjs**\n\ncommonjs 是动态导入，可以在代码的任何地方引入\n\n```javascript\nconst flag = true\nif (flag) {\n  const aaa = require('./aaa.js')\n}\n```\n\n**esmodule**\n\nesmodule 是静态导入，也可以理解为在编译阶段就导入，所以不能在条件语句、函数嵌套等情况下导入\n\n```javascript\nimport aaa from './aaa.js'\nconst flag = true\nif (flag) {\n  // import aaa from './aaa.js' // 会报错\n}\n```\n\n### 2.使用语法不同\n\n**commonjs**\n\n导出:\n\n```javascript\n// aaa.js\nconst name = 'kobe'\nconst obj = {\n  age: 18\n}\nmodule.exports = {\n  name,\n  obj\n}\n```\n\n导入：\n\n```javascript\n// bbb.js\nconst aaa = require('./aaa.js')\nconsole.log(aaa.name) // kobe\n```\n\n### 3.模块导出导入\n\n**commonjs**\n\ncommonjs 导出的是一个 module.exports, 导入其实就是给变量赋值(而值可以是原始类型，也可以是应用类型)\n\n- 当 module.exports 的值是数字，字符串等原始类型时，赋值是值的拷贝，这样才会产生导出值的改变不会影响到导入值改变的现象\n\n```javascript\n  # 导出模块 a.js\n  let title = 'hello hi'\n  setTimeout(() => {\n      title = 'hello hehe'\n  }, 2000)\n  module.exports = title\n\n  # 导入模块 b.js\n  const title = require('./a.js')\n  setTimeout(() => {\n     console.log(title)\n  }, 4000)\n  console.log(title)\n\n  # 输出结果\n  hello hi\n  hello hi\n```\n\n- 如果 module.exports 导出的是一个对象，导出值的改变是否会影响到导入的值，这个跟导入时赋值的方式是有直接关系的\n\n```javascript\n  # 导出模块 a.js\n  const obj = {\n      title: 'hello hi'\n  }\n  setTimeout(() => {\n      obj.title = 'hello hehe'\n  }, 2000)\n  module.exports = obj\n\n  # 导入模块 b.js\n  const obj = require('./a.js')\n  setTimeout(() => {\n     console.log(obj.title)\n  }, 4000)\n  console.log(obj.title)\n\n  # 输出结果\n  hello hi\n  hello hehe\n\n  可以看出输出的值变了，说明模块内部值的变化导致了导入对象值的变化\n  这里的赋值实际上就是引用赋值，module.exports导出的对象被赋值到导入的模块，两者指向同一块内存空间\n```\n\n```javascript\n  # 导出模块 a.js\n  const obj = {\n      title: 'hello hi'\n  }\n  setTimeout(() => {\n      obj.title = 'hello hehe'\n  }, 2000)\n  module.exports = obj\n\n  # 导入模块 b.js\n  const { title } = require('./a.js')\n  setTimeout(() => {\n     console.log(title)\n  }, 4000)\n  console.log(title)\n\n  # 输出结果\n  hello hi\n  hello hi\n\n  可以看出输出的值没有发生变化，说明模块内部值的变化没有导致导入值的变化\n  这里的赋值实际上就是值的拷贝，通过对象解构的方式直接给变量title赋值，所以模块内部对象值的变化不会影响到导入变量值的变化\n```\n\n**esmodule**\n\nesModule 模块输出的是一个`值的引用`, 使用的是动态绑定，esModule 导入导出的值都指向同一个内存地址，所以导入值会跟着导出值发生变化\n\nJS 引擎对脚本进行静态分析的时候，如果遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行的时候，再通过这个只读引用，到被加载的模块中去取值。\n\nesModule 导入的基本类型值在当前模块不能直接进行修改(代码会报错，但是可以通过调用模块内的方法进行修改)，也就是说基本类型的值在被导入的模块中是只读状态，对于导入引用类型的值，可以直接进行修改设置，但是不会对模块内的值产生任何影响\n\n```javascript\n# 导出模块 a.js\nexport let title = 'hello hi'\nconst obj = {\n    name: 'tom'\n}\nexport default obj\nsetTimeout(() => {\n    title = 'hello world'\n    obj.name = 'tony'\n}, 2000)\n\n# 导入模块 b.js\nimport obj, { title } from './a.js'\nconsole.log(title)\nconsole.log(obj.name)\nsetTimeout(() => {\n    console.log(title)\n    console.log(obj.name)\n}, 4000)\n\n# 输入结果\nhello hi\ntom\nhello world\ntony\n\n可以看出输出的值发生了变化，这是因为导入和导出的值都指向同一内存地址，值变化，取值也就发生变化\n```\n\ncjs 输出的是一个对象，该对象需要在模块脚本运行完成后才能生成，而 esm 输出的是静态的，在编译时就能生成\n\n### 4.加载运行\n\n**commonjs**\n\ncommonjs 是在代码运行时加载，因为 commonjs 是导出的整个对象，需要在脚本运行完成后才能生成\n\n**esmodule**\n\nesmodule 输出的不是一个对象，而是静态分析编译时输出的接口，它的对外接口是一种静态的定义，可以理解为生成一个个引用变量，在模块读取的时候再去取\n","source":"_posts/CommonJS和ESModule的区别.md","raw":"---\ntitle: CommonJS和ESModule的区别\ntag: JS模块化\nkeywords: JS模块化\ncategories: 前端工程化\n---\n\n## CommonJS 和 ESModule 的区别\n\n### 1.引入位置不同\n\n**commonjs**\n\ncommonjs 是动态导入，可以在代码的任何地方引入\n\n```javascript\nconst flag = true\nif (flag) {\n  const aaa = require('./aaa.js')\n}\n```\n\n**esmodule**\n\nesmodule 是静态导入，也可以理解为在编译阶段就导入，所以不能在条件语句、函数嵌套等情况下导入\n\n```javascript\nimport aaa from './aaa.js'\nconst flag = true\nif (flag) {\n  // import aaa from './aaa.js' // 会报错\n}\n```\n\n### 2.使用语法不同\n\n**commonjs**\n\n导出:\n\n```javascript\n// aaa.js\nconst name = 'kobe'\nconst obj = {\n  age: 18\n}\nmodule.exports = {\n  name,\n  obj\n}\n```\n\n导入：\n\n```javascript\n// bbb.js\nconst aaa = require('./aaa.js')\nconsole.log(aaa.name) // kobe\n```\n\n### 3.模块导出导入\n\n**commonjs**\n\ncommonjs 导出的是一个 module.exports, 导入其实就是给变量赋值(而值可以是原始类型，也可以是应用类型)\n\n- 当 module.exports 的值是数字，字符串等原始类型时，赋值是值的拷贝，这样才会产生导出值的改变不会影响到导入值改变的现象\n\n```javascript\n  # 导出模块 a.js\n  let title = 'hello hi'\n  setTimeout(() => {\n      title = 'hello hehe'\n  }, 2000)\n  module.exports = title\n\n  # 导入模块 b.js\n  const title = require('./a.js')\n  setTimeout(() => {\n     console.log(title)\n  }, 4000)\n  console.log(title)\n\n  # 输出结果\n  hello hi\n  hello hi\n```\n\n- 如果 module.exports 导出的是一个对象，导出值的改变是否会影响到导入的值，这个跟导入时赋值的方式是有直接关系的\n\n```javascript\n  # 导出模块 a.js\n  const obj = {\n      title: 'hello hi'\n  }\n  setTimeout(() => {\n      obj.title = 'hello hehe'\n  }, 2000)\n  module.exports = obj\n\n  # 导入模块 b.js\n  const obj = require('./a.js')\n  setTimeout(() => {\n     console.log(obj.title)\n  }, 4000)\n  console.log(obj.title)\n\n  # 输出结果\n  hello hi\n  hello hehe\n\n  可以看出输出的值变了，说明模块内部值的变化导致了导入对象值的变化\n  这里的赋值实际上就是引用赋值，module.exports导出的对象被赋值到导入的模块，两者指向同一块内存空间\n```\n\n```javascript\n  # 导出模块 a.js\n  const obj = {\n      title: 'hello hi'\n  }\n  setTimeout(() => {\n      obj.title = 'hello hehe'\n  }, 2000)\n  module.exports = obj\n\n  # 导入模块 b.js\n  const { title } = require('./a.js')\n  setTimeout(() => {\n     console.log(title)\n  }, 4000)\n  console.log(title)\n\n  # 输出结果\n  hello hi\n  hello hi\n\n  可以看出输出的值没有发生变化，说明模块内部值的变化没有导致导入值的变化\n  这里的赋值实际上就是值的拷贝，通过对象解构的方式直接给变量title赋值，所以模块内部对象值的变化不会影响到导入变量值的变化\n```\n\n**esmodule**\n\nesModule 模块输出的是一个`值的引用`, 使用的是动态绑定，esModule 导入导出的值都指向同一个内存地址，所以导入值会跟着导出值发生变化\n\nJS 引擎对脚本进行静态分析的时候，如果遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行的时候，再通过这个只读引用，到被加载的模块中去取值。\n\nesModule 导入的基本类型值在当前模块不能直接进行修改(代码会报错，但是可以通过调用模块内的方法进行修改)，也就是说基本类型的值在被导入的模块中是只读状态，对于导入引用类型的值，可以直接进行修改设置，但是不会对模块内的值产生任何影响\n\n```javascript\n# 导出模块 a.js\nexport let title = 'hello hi'\nconst obj = {\n    name: 'tom'\n}\nexport default obj\nsetTimeout(() => {\n    title = 'hello world'\n    obj.name = 'tony'\n}, 2000)\n\n# 导入模块 b.js\nimport obj, { title } from './a.js'\nconsole.log(title)\nconsole.log(obj.name)\nsetTimeout(() => {\n    console.log(title)\n    console.log(obj.name)\n}, 4000)\n\n# 输入结果\nhello hi\ntom\nhello world\ntony\n\n可以看出输出的值发生了变化，这是因为导入和导出的值都指向同一内存地址，值变化，取值也就发生变化\n```\n\ncjs 输出的是一个对象，该对象需要在模块脚本运行完成后才能生成，而 esm 输出的是静态的，在编译时就能生成\n\n### 4.加载运行\n\n**commonjs**\n\ncommonjs 是在代码运行时加载，因为 commonjs 是导出的整个对象，需要在脚本运行完成后才能生成\n\n**esmodule**\n\nesmodule 输出的不是一个对象，而是静态分析编译时输出的接口，它的对外接口是一种静态的定义，可以理解为生成一个个引用变量，在模块读取的时候再去取\n","slug":"CommonJS和ESModule的区别","published":1,"date":"2023-02-01T06:48:25.881Z","updated":"2023-02-01T07:40:19.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9kw000fi024baql32el","content":"<h2 id=\"CommonJS-和-ESModule-的区别\"><a href=\"#CommonJS-和-ESModule-的区别\" class=\"headerlink\" title=\"CommonJS 和 ESModule 的区别\"></a>CommonJS 和 ESModule 的区别</h2><h3 id=\"1-引入位置不同\"><a href=\"#1-引入位置不同\" class=\"headerlink\" title=\"1.引入位置不同\"></a>1.引入位置不同</h3><p><strong>commonjs</strong></p>\n<p>commonjs 是动态导入，可以在代码的任何地方引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> flag = <span class=\"hljs-literal\">true</span><br><span class=\"hljs-keyword\">if</span> (flag) &#123;<br>  <span class=\"hljs-keyword\">const</span> aaa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>esmodule</strong></p>\n<p>esmodule 是静态导入，也可以理解为在编译阶段就导入，所以不能在条件语句、函数嵌套等情况下导入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> aaa <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span><br><span class=\"hljs-keyword\">const</span> flag = <span class=\"hljs-literal\">true</span><br><span class=\"hljs-keyword\">if</span> (flag) &#123;<br>  <span class=\"hljs-comment\">// import aaa from &#x27;./aaa.js&#x27; // 会报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用语法不同\"><a href=\"#2-使用语法不同\" class=\"headerlink\" title=\"2.使用语法不同\"></a>2.使用语法不同</h3><p><strong>commonjs</strong></p>\n<p>导出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// aaa.js</span><br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&#x27;kobe&#x27;</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span><br>&#125;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  name,<br>  obj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>导入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bbb.js</span><br><span class=\"hljs-keyword\">const</span> aaa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(aaa.<span class=\"hljs-property\">name</span>) <span class=\"hljs-comment\">// kobe</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-模块导出导入\"><a href=\"#3-模块导出导入\" class=\"headerlink\" title=\"3.模块导出导入\"></a>3.模块导出导入</h3><p><strong>commonjs</strong></p>\n<p>commonjs 导出的是一个 module.exports, 导入其实就是给变量赋值(而值可以是原始类型，也可以是应用类型)</p>\n<ul>\n<li>当 module.exports 的值是数字，字符串等原始类型时，赋值是值的拷贝，这样才会产生导出值的改变不会影响到导入值改变的现象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">let</span> title = <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    title = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = title<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><br># 输出结果<br>hello hi<br>hello hi<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 module.exports 导出的是一个对象，导出值的改变是否会影响到导入的值，这个跟导入时赋值的方式是有直接关系的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    obj.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = obj<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">title</span>)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">title</span>)<br><br># 输出结果<br>hello hi<br>hello hehe<br><br>可以看出输出的值变了，说明模块内部值的变化导致了导入对象值的变化<br>这里的赋值实际上就是引用赋值，<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span>导出的对象被赋值到导入的模块，两者指向同一块内存空间<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    obj.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = obj<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> &#123; title &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><br># 输出结果<br>hello hi<br>hello hi<br><br>可以看出输出的值没有发生变化，说明模块内部值的变化没有导致导入值的变化<br>这里的赋值实际上就是值的拷贝，通过对象解构的方式直接给变量title赋值，所以模块内部对象值的变化不会影响到导入变量值的变化<br></code></pre></td></tr></table></figure>\n\n<p><strong>esmodule</strong></p>\n<p>esModule 模块输出的是一个<code>值的引用</code>, 使用的是动态绑定，esModule 导入导出的值都指向同一个内存地址，所以导入值会跟着导出值发生变化</p>\n<p>JS 引擎对脚本进行静态分析的时候，如果遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行的时候，再通过这个只读引用，到被加载的模块中去取值。</p>\n<p>esModule 导入的基本类型值在当前模块不能直接进行修改(代码会报错，但是可以通过调用模块内的方法进行修改)，也就是说基本类型的值在被导入的模块中是只读状态，对于导入引用类型的值，可以直接进行修改设置，但是不会对模块内的值产生任何影响</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> title = <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> obj<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    title = <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>    obj.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;tony&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">import</span> obj, &#123; title &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a.js&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">name</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">name</span>)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><br># 输入结果<br>hello hi<br>tom<br>hello world<br>tony<br><br>可以看出输出的值发生了变化，这是因为导入和导出的值都指向同一内存地址，值变化，取值也就发生变化<br></code></pre></td></tr></table></figure>\n\n<p>cjs 输出的是一个对象，该对象需要在模块脚本运行完成后才能生成，而 esm 输出的是静态的，在编译时就能生成</p>\n<h3 id=\"4-加载运行\"><a href=\"#4-加载运行\" class=\"headerlink\" title=\"4.加载运行\"></a>4.加载运行</h3><p><strong>commonjs</strong></p>\n<p>commonjs 是在代码运行时加载，因为 commonjs 是导出的整个对象，需要在脚本运行完成后才能生成</p>\n<p><strong>esmodule</strong></p>\n<p>esmodule 输出的不是一个对象，而是静态分析编译时输出的接口，它的对外接口是一种静态的定义，可以理解为生成一个个引用变量，在模块读取的时候再去取</p>\n","site":{"data":{}},"wordcount":2779,"excerpt":"","more":"<h2 id=\"CommonJS-和-ESModule-的区别\"><a href=\"#CommonJS-和-ESModule-的区别\" class=\"headerlink\" title=\"CommonJS 和 ESModule 的区别\"></a>CommonJS 和 ESModule 的区别</h2><h3 id=\"1-引入位置不同\"><a href=\"#1-引入位置不同\" class=\"headerlink\" title=\"1.引入位置不同\"></a>1.引入位置不同</h3><p><strong>commonjs</strong></p>\n<p>commonjs 是动态导入，可以在代码的任何地方引入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> flag = <span class=\"hljs-literal\">true</span><br><span class=\"hljs-keyword\">if</span> (flag) &#123;<br>  <span class=\"hljs-keyword\">const</span> aaa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>esmodule</strong></p>\n<p>esmodule 是静态导入，也可以理解为在编译阶段就导入，所以不能在条件语句、函数嵌套等情况下导入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> aaa <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span><br><span class=\"hljs-keyword\">const</span> flag = <span class=\"hljs-literal\">true</span><br><span class=\"hljs-keyword\">if</span> (flag) &#123;<br>  <span class=\"hljs-comment\">// import aaa from &#x27;./aaa.js&#x27; // 会报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用语法不同\"><a href=\"#2-使用语法不同\" class=\"headerlink\" title=\"2.使用语法不同\"></a>2.使用语法不同</h3><p><strong>commonjs</strong></p>\n<p>导出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// aaa.js</span><br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&#x27;kobe&#x27;</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span><br>&#125;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  name,<br>  obj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>导入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// bbb.js</span><br><span class=\"hljs-keyword\">const</span> aaa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./aaa.js&#x27;</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(aaa.<span class=\"hljs-property\">name</span>) <span class=\"hljs-comment\">// kobe</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-模块导出导入\"><a href=\"#3-模块导出导入\" class=\"headerlink\" title=\"3.模块导出导入\"></a>3.模块导出导入</h3><p><strong>commonjs</strong></p>\n<p>commonjs 导出的是一个 module.exports, 导入其实就是给变量赋值(而值可以是原始类型，也可以是应用类型)</p>\n<ul>\n<li>当 module.exports 的值是数字，字符串等原始类型时，赋值是值的拷贝，这样才会产生导出值的改变不会影响到导入值改变的现象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">let</span> title = <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    title = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = title<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> title = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><br># 输出结果<br>hello hi<br>hello hi<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 module.exports 导出的是一个对象，导出值的改变是否会影响到导入的值，这个跟导入时赋值的方式是有直接关系的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    obj.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = obj<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">title</span>)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">title</span>)<br><br># 输出结果<br>hello hi<br>hello hehe<br><br>可以看出输出的值变了，说明模块内部值的变化导致了导入对象值的变化<br>这里的赋值实际上就是引用赋值，<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span>导出的对象被赋值到导入的模块，两者指向同一块内存空间<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br>&#125;<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    obj.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">&#x27;hello hehe&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = obj<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">const</span> &#123; title &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a.js&#x27;</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><br># 输出结果<br>hello hi<br>hello hi<br><br>可以看出输出的值没有发生变化，说明模块内部值的变化没有导致导入值的变化<br>这里的赋值实际上就是值的拷贝，通过对象解构的方式直接给变量title赋值，所以模块内部对象值的变化不会影响到导入变量值的变化<br></code></pre></td></tr></table></figure>\n\n<p><strong>esmodule</strong></p>\n<p>esModule 模块输出的是一个<code>值的引用</code>, 使用的是动态绑定，esModule 导入导出的值都指向同一个内存地址，所以导入值会跟着导出值发生变化</p>\n<p>JS 引擎对脚本进行静态分析的时候，如果遇到模块加载命令 import，就会生成一个只读引用，等到脚本真正执行的时候，再通过这个只读引用，到被加载的模块中去取值。</p>\n<p>esModule 导入的基本类型值在当前模块不能直接进行修改(代码会报错，但是可以通过调用模块内的方法进行修改)，也就是说基本类型的值在被导入的模块中是只读状态，对于导入引用类型的值，可以直接进行修改设置，但是不会对模块内的值产生任何影响</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 导出模块 a.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> title = <span class=\"hljs-string\">&#x27;hello hi&#x27;</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;tom&#x27;</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> obj<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    title = <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>    obj.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&#x27;tony&#x27;</span><br>&#125;, <span class=\"hljs-number\">2000</span>)<br><br># 导入模块 b.<span class=\"hljs-property\">js</span><br><span class=\"hljs-keyword\">import</span> obj, &#123; title &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./a.js&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">name</span>)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(title)<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">name</span>)<br>&#125;, <span class=\"hljs-number\">4000</span>)<br><br># 输入结果<br>hello hi<br>tom<br>hello world<br>tony<br><br>可以看出输出的值发生了变化，这是因为导入和导出的值都指向同一内存地址，值变化，取值也就发生变化<br></code></pre></td></tr></table></figure>\n\n<p>cjs 输出的是一个对象，该对象需要在模块脚本运行完成后才能生成，而 esm 输出的是静态的，在编译时就能生成</p>\n<h3 id=\"4-加载运行\"><a href=\"#4-加载运行\" class=\"headerlink\" title=\"4.加载运行\"></a>4.加载运行</h3><p><strong>commonjs</strong></p>\n<p>commonjs 是在代码运行时加载，因为 commonjs 是导出的整个对象，需要在脚本运行完成后才能生成</p>\n<p><strong>esmodule</strong></p>\n<p>esmodule 输出的不是一个对象，而是静态分析编译时输出的接口，它的对外接口是一种静态的定义，可以理解为生成一个个引用变量，在模块读取的时候再去取</p>\n"},{"title":"JS 高级","keywords":"Javascript","_content":"\n## 一、深入 javascript 与运行原理\n\n### 1.V8 引擎的原理\n\n- V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用户 Chrome 和 nodejs 等\n\n- 它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32， ARM 或 MIPS 处理器的 Linux 系统上运行\n- V8 可以独立运行，也可以嵌入到任何 C ++应用程序中\n\n### 2.V8 引擎的架构\n\n- parse 模块将 javascript 代码转换成 ast 抽象语法树，这是因为解释器并不直接认识 javascript 代码\n- Ignition 是一个解释器，会将 ast 转换成 ByteCode 字节码\n- TurboFan 是一个编译器，可以将字节码变异成 CPU 可以直接执行的机器码 ![1](./images/1.png)\n\n### 3.V8 执行的细节\n\n- Blink 将解析 HTML 文件时，遇到 Javascript 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换\n- Scanner 会进行词法分析，词法分析会将代码转换成 tokens\n- 接下来 tokens 经过 Parser 和 PreParser 模块转换成 AST 树\n  - Parser 就是将 tokens 转成 AST 树结构\n  - PreParser 称之为预解析，为什么需要预解析呢？\n    - 这是因为并不是所有的 Javscript 代码，在一开始就会被执行。对所有的 Javascript 代码进行解析，必然会影响网页的运行效率\n    - 所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析就是在函数被调用时才会进行\n    - 比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析\n- 生成 AST 树后，会被 Ignition 模块专程字节码（bytecode），之后的过程就是代码的执行过程\n\n### 4.Javascript 的执行过程\n\n1. 初始化全局对象\n   - js 引擎在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）\n     - 该对象所有的作用域（scope）都可以访问\n     - 里面会包含 Date、Array、String、Number、setTimeout、setInteval 等等全局属性 AA 己\n2. 创建执行上下文栈\n   - js 引擎内部有一个执行上下文栈（Execution Context Stack， 简称 ECS），它是用于执行代码的调用栈（执行栈）\n   - 那么现在它要执行谁呢？执行的是全局的代码块：\n     - 全局的代码块为了执行会创建一个全局执行上下文 Global Execution Context（GEC），GEC 中会创建一个 VO 对象（就是 GO 对象）\n     - GEC 会放到 ECS 中执行\n   - GEC 被放入到 ECS 里面包含两个内容：\n     - 第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是只是声明，不会赋值。这个过程也称作是作用域提升\n     - 第二部分：在代码执行中，对变量赋值，或者执行其他的函数\n3. 遇到函数创建函数执行上下文\n   - 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context， 简称 FEC），并且压入到 EC Stack 中\n   - FEC 包含三部分内容：\n     - 第一部分：在解析函数称为 AST 树结构时，会创建一个 Activation Object（AO）\n       - AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量\n     - 第二部分：作用域链，由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找（函数的父级作用域 Parent Scope 和函数的定义位置有关系，和调用位置是没有关系的）\n     - 第三部分：this 绑定的值\n\n## 二、JS 的内存管理和闭包\n\n### 1.认识内存管理\n\n- 不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的，不同的是**某些编程语言**需要我们**自己手动**\n\n  **的管理内存**，**某些编程语言**会可以**自动帮助我们管理内存**\n\n- 不管以什么样的方式来管理内存，**内存的管理都会有如下的生命周期**：\n\n  - 第一步：分配申请你需要的内存（申请）；\n  - 第二步：使用分配的内存（存放一些东西，比如对象等）；\n  - 第三步：不需要使用时，对其进行释放；\n\n- **不同的编程语言对于第一步和第三步会有不同的实现：**\n\n- 手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函数）\n- 自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；\n\n- 我们可以知道 JavaScript 通常情况下是不需要手动来管理的。\n\n### 2.JS 的内存管理\n\n- javascript 会在定义变量时分配内存\n  - 对于基本数据类型，会在栈空间分配内存\n  - 对于复杂数据类型，会在堆空间开辟内存，并将这块空间的指针返回给值变量引用\n\n### 3.JS 的垃圾回收\n\n- 因为**内存的大小是有限**的，所以当**内存不再需要的时候**，我们需要**对其进行释放**，以便腾出**更多的内存空间**\n- JS 有自己的垃圾回收机制（Garbage Collection，简称 GC）\n- 对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间\n\n### 4.常见的 GC 算法\n\n1. 引用计数算法\n\n   - 当一个对象有一个引用指向它时，那么这个对象的引用就+1，当一个对象的引用为 0 时，这个对象就可以被销\n\n     毁掉\n\n   - p 这个算法有一个很大的弊端就是会产生循环引用\n\n2. 标记清除\n\n   - 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对\n\n     于哪些没有引用到的对象，就认为是不可用的对象\n\n   - 这个算法可以很好的解决循环引用的问题\n\n   - JS 引擎比较广泛的采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合\n\n     一些其他的算法。\n\n## 三、JS 中闭包的定义\n\n- 这里先来看一下闭包的定义，分成两个：在计算机科学中和在 JavaScript 中。\n- 在计算机科学中对闭包的定义（维基百科）：\n\n  - 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；\n  - 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术；\n  - 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；\n  - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；\n\n- 闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包：\n\n  - 因为 JavaScript 中有大量的设计是来源于 Scheme 的；\n\n- 我们再来看一下 MDN 对 JavaScript 闭包的解释：\n\n  - 一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）；\n  - 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；\n  - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；\n\n- 那么我的理解和总结：\n- 一个普通的函数 function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；\n- 从广义的角度来说：JavaScript 中的函数都是闭包；\n- 从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；\n\n## 四、JS 中的 this 指向\n\n### 1.this 的绑定规律\n\n1. 函数在调用时，JavaScript 会默认给 this 绑定一个值；\n2. this 的绑定和定义的位置（编写的位置）没有关系；\n3. this 的绑定和调用方式以及调用的位置有关系；\n4. this 是在运行时被绑定的；\n\n### 2.this 的绑定规则\n\n- 默认绑定（优先级最低）：独立函数调用\n- 隐式绑定（优先级大于默认绑定）：obj.fn()\n- 显示绑定（优先级大于隐式绑定）：apply、call、bind 等\n- new 绑定（优先级大于显示绑定）：new Foo()\n\n## 五、手写 call、apply 和 bind\n\n### 1.call 函数的实现\n\n```javascript\nFunction.prototype.lyCall = function (thisArg, ...args) {\n  // 1.处理thisArg\n  thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n  // 2.隐式绑定，调用需要修改this指向的函数\n  const key = Symbol()\n  thisArg[key] = this\n  const result = thisArg[key](...args)\n  delete thisArg[key]\n  // 3.返回函数执行结果\n  return result\n}\n```\n\n### 2.apply 函数的实现\n\n```javascript\nFunction.prototype.lyApply = function (thisArg, argArray) {\n  // 1.处理thisArg\n  thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n  // 2.隐式绑定，调用需要修改this指向的函数\n  const key = Symbol()\n  thisArg[key] = this\n  argArray = argArray || []\n  const result = thisArg[key](...argArray)\n  delete thisArg[key]\n  // 3.返回函数执行结果\n  return result\n}\n```\n\n### 3.bind 函数的实现\n\n```javascript\nFunction.prototype.lyBind = function (thisArg, ...args) {\n  return function (...bindArgs) {\n    // 1.处理thisArg\n    thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n    // 2.隐式绑定，调用需要修改this指向的函数\n    const key = Symbol()\n    thisArg[key] = this\n    const result = thisArg[key]([...args, ...bindArgs])\n    delete thisArg[key]\n    // 3.返回函数执行结果\n    return result\n  }\n}\n```\n\n## 六、函数科里化\n\n### 1.函数科里化的概念\n\n一个接收多个参数的函数，变成一个可以只接收部分参数，并且返回一个接收剩余参数的函数的函数。这个过程就叫科里化\n\n### 2.函数科里化的实现\n\n```javascript\nfunction curring(fn) {\n  const curriedFn = function (...args) {\n    if (args.length >= fn.length) {\n      // 本次函数调用传入的参数个数已经达到需要执行函数的最大参数长度，直接执行该函数\n      return fn.apply(this, args)\n    } else {\n      // 本次函数调用传入的参数个数没有达到需要执行函数的最大参数长度，返回一个接收剩余参数的函数\n      return function (...restArgs) {\n        return curriedFn.apply(this, [...args, ...restArgs])\n      }\n    }\n  }\n\n  return curriedFn\n}\n```\n\n## 七、组合函数\n\n### 1.组合函数的概念\n\n将多个需要执行的函数，组合到一个函数里面，函数内部会自动依次调用。这个过程就是对函数的组合，这个函数就称为组合函数\n\n### 2.通用组合函数的实现\n\n```javascript\nfunction compose(...fns) {\n  fns.forEach((fn) => {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected arguments are function!')\n    }\n  })\n  const list = fns.slice()\n  return function (...args) {\n    let result = list.shift().apply(this, args)\n    while (list.length > 0) {\n      result = list.shift().call(this, result)\n    }\n    return result\n  }\n}\n```\n\n## 八、寄生组合式继承（最终方案）\n\n```javascript\n// 寄生式继承-对象\nfunction createObject(o) {\n  function Fn() {}\n  Fn.prototype = o\n  return new Fn()\n}\n\nfunction inheritPrototype(subType, superType) {\n  // subType.prototype = Object.create(superType.prototype) // 子类显式原型指向新创建的对象，新对象__proto__指向父类显示原型\n  subType.prototype = createObject(superType.prototype)\n  // 子类显示原型的构造函数指向自己\n  Object.defineProperty(subType.prototype, 'constuctor', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: subType\n  })\n}\n// 父类\nfunction Person(name) {\n  this.name = name\n}\nPerson.prototype.eating = function () {\n  console.log('eating')\n}\n// 子类\nfunction Student(sno) {\n  // 继承父类属性\n  Person.call(this, name)\n  this.sno = sno\n}\n// 继承父类方法\ninheritPrototype(Student, Person)\n```\n\n## 九、手写 instanceof\n\n```javascript\nfunction _instanceof(a, b) {\n  while (a.__proto__) {\n    if (a.__proto__ === b.prototype) {\n      return true\n    }\n    a = a.__proto__\n  }\n  return false\n}\n```\n\n## 十、手写 new 操作符\n\n```javascript\nfunction _new(constructor, ...args) {\n  let instance = Object.create(constructor.prototype)\n  const res = constuctor.apply(instance, args)\n  // 构造函数有明确的返回值且返回值是Object时，直接返回构造函数的返回结果\n  return res instanceof Object ? res : instance\n}\n```\n\n## 十一、响应式原理实现\n\n```javascript\n// Dep类存储响应式函数（副作用）\nclass Dep {\n  subscribers = new Set()\n  addEffect() {\n    activeEffect && this.subscribers.add(activeEffect)\n  }\n  notify() {\n    this.subscribers.forEach((effect) => effect())\n  }\n}\n\n// 当前需要收集的响应式函数（副作用）\nlet activeEffect = null\n// 第一次执行响应式函数（副作用），并触发对应的追踪收集操作\nconst watchEffect = (fn) => {\n  activeEffect = fn\n  fn()\n  activeEffect = null\n}\n\n// WeakMap: { obj -> Map }  Map: { obj属性 -> dep对象(存储响应式函数,并提供触发方法) }\nconst weakMap = new WeakMap()\n// 收集响应式函数（副作用）\nconst track = (target, key) => {\n  let targetMap = weakMap.get(target)\n  if (!targetMap) {\n    targetMap = new Map()\n    weakMap.set(target, targetMap)\n  }\n  let dep = targetMap.get(key)\n  if (!dep) {\n    dep = new Dep()\n    targetMap.set(key, dep)\n  }\n  dep.addEffect()\n}\n// 触发响应式函数（副作用）\nconst trigger = (target, key) => {\n  const targetMap = weakMap.get(target)\n  if (!targetMap) return\n  const dep = targetMap.get(key)\n  dep?.notify()\n}\n\n// 创建代理对象\nconst reactive = (o) => {\n  return new Proxy(o, {\n    get(target, key, receiver) {\n      track(target, key)\n      return Reflect.get(target, key, receiver)\n    },\n    set(target, key, newValue, receiver) {\n      trigger(target, key)\n      Reflect.set(target, key, newValue, receiver)\n    }\n  })\n}\n```\n\n## 十二、手写简易版 promise 实现\n\n```javascript\nconst PROMISE_STATUS_PENDING = 'pending'\nconst PROMISE_STATUS_FULFILLED = 'fulfilled'\nconst PROMISE_STATUS_REJECTED = 'rejected'\n\nconst execCallbackWithCatchErr = (execFn, value, resolve, reject) => {\n  try {\n    const result = execFn(value)\n    resolve(result)\n  } catch (err) {\n    reject(err)\n  }\n}\n\nclass LyPromise {\n  status = PROMISE_STATUS_PENDING\n  value = undefined\n  reason = undefined\n  onfulfilledCallbacks = []\n  onrejectedCallbacks = []\n  constructor(executor) {\n    const resolve = (value) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return\n          this.status = PROMISE_STATUS_FULFILLED\n          this.value = value\n          this.onfulfilledCallbacks.forEach((callback) => {\n            callback(this.value)\n          })\n        })\n      }\n    }\n    const reject = (reason) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return\n          this.status = PROMISE_STATUS_REJECTED\n          this.reason = reason\n          this.onrejectedCallbacks.forEach((callback) => {\n            callback(this.reason)\n          })\n        })\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (err) {\n      reject(err)\n    }\n  }\n\n  then(onfulfilled, onrejected) {\n    return new LyPromise((resolve, reject) => {\n      onfulfilled =\n        onfulfilled ||\n        ((res) => {\n          return res\n        })\n      onrejected =\n        onrejected ||\n        ((err) => {\n          throw err\n        })\n\n      switch (this.status) {\n        case PROMISE_STATUS_PENDING:\n          this.onfulfilledCallbacks.push(() => {\n            execCallbackWithCatchErr(onfulfilled, this.value, resolve, reject)\n          })\n          this.onrejectedCallbacks.push(() => {\n            execCallbackWithCatchErr(onrejected, this.reason, resolve, reject)\n          })\n          break\n        case PROMISE_STATUS_FULFILLED:\n          execCallbackWithCatchErr(onfulfilled, this.value, resolve, reject)\n          break\n        case PROMISE_STATUS_REJECTED:\n          execCallbackWithCatchErr(onrejected, this.reason, resolve, reject)\n          break\n      }\n    })\n  }\n\n  catch(onrejected) {\n    return this.then(undefined, onrejected)\n  }\n\n  finally(onfinally) {\n    return this.then(onfinally, onfinally)\n  }\n\n  static resolve(value) {\n    return new LyPromise((resolve) => resolve(value))\n  }\n\n  static reject(reason) {\n    return new LyPromise((resolve, reject) => reject(reason))\n  }\n\n  static all(promises) {\n    return new Promise((resolve, reject) => {\n      let values = []\n      promises.forEach((promise) => {\n        promise.then((res) => {\n          values.push(res)\n          if (values.length === promises.length) resolve(values)\n        }, reject)\n      })\n    })\n  }\n\n  static allSettled(promises) {\n    return new Promise((resolve, reject) => {\n      let result = []\n      promises.forEach((promise) => {\n        promise.then(\n          (res) => {\n            result.push({\n              status: PROMISE_STATUS_FULFILLED,\n              value: res\n            })\n            if (result.length === promises.length) resolve(result)\n          },\n          (err) => {\n            result.push({\n              status: PROMISE_STATUS_REJECTED,\n              reason: err\n            })\n            if (result.length === promises.length) resolve(result)\n          }\n        )\n      })\n    })\n  }\n\n  static race(promises) {\n    return new LyPromise((resolve, reject) => {\n      promises.forEach((promise) => {\n        promise.then(resolve, reject)\n      })\n    })\n  }\n\n  static any(promises) {\n    return new LyPromise((resolve, reject) => {\n      let reasons = []\n      promises.forEach((promise) => {\n        promise.then(resolve, (err) => {\n          reasons.push(err)\n          if (reasons.length === promises.length) {\n            reject(new AggregateError(reasons))\n          }\n        })\n      })\n    })\n  }\n}\n```\n\n## 十三、异步方案：Promise+Generator\n\n```javascript\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(url)\n    }, 2000)\n  })\n}\n\n// 生成器\nfunction* getData() {\n  const res1 = yield requestData('coder')\n  const res2 = yield requestData(res1 + '111')\n  const res3 = yield requestData(res2 + '222')\n  const res4 = yield requestData(res3 + '333')\n  console.log(res4)\n}\n\n// 自动递归执行生成器\nfunction co(genFn) {\n  const generator = genFn()\n  const exec = (res) => {\n    const result = generator.next(res)\n    if (result.done) {\n      return result.value\n    }\n    result.value.then((res) => {\n      exec(res)\n    })\n  }\n  exec()\n}\n\nco(getData)\n```\n\n## 十二、手写防抖和节流\n\n### 1.防抖\n\n```javascript\nfunction debounce(fn, delay, immediate = false) {\n  let timer = null\n  let isInvoke = false\n  const _debounce = (...args) {\n    if(timer) clearTimeout(timer)\n    if(immediate && !isInvoke) {\n      fn.apply(this, args)\n      isInvoke = true\n    }\n    timer = setTimeout(() => {\n      timer = null\n      isInvoke = false\n      fn.apply(this, args)\n    }, delay)\n  }\n\n  _debounce.cancel = () => {\n     if(timer) clearTimeout(timer)\n     timer = null\n     isInvoke = false\n  }\n\n  return _debounce\n}\n```\n\n### 2.节流\n\n```javascript\nfunction throttle(fn, interval, options = { leading: true, trailing: true }) {\n  let last = 0\n  timer = null\n  const { leading, trailing } = options\n  const _throttle = function (...args) {\n    let now = Date.now()\n    if (!last && !leading) last = now\n    const remainTime = interval - (now - last)\n    if (remainTime <= 0) {\n      fn.apply(fn, args)\n      last = now\n      return\n    }\n    if (trailing) {\n      if (timer) {\n        clearTimeout(timer)\n        timer = null\n      }\n      timer = setTimeout(() => {\n        fn.apply(fn, args)\n        timer = null\n        last = !leading ? 0 : Date.now()\n      }, remainTime)\n    }\n  }\n  _throttle.cancel = function () {\n    if (timer) {\n      clearTimeout(timer)\n      timer = null\n    }\n  }\n  return _throttle\n}\n```\n\n## 十三、深拷贝\n\n```javascript\nfunction isObject(o) {\n  const type = typeof o\n  return o !== null && (type === 'object' || type === 'function')\n}\nfunction deepClone(originValue, weakMap = new WeakMap()) {\n  // 处理数组格式\n  const newObj = Array.isArray(originValue) ? [] : {}\n  // 处理简单数据类型\n  if (!isObject(originValue)) return originValue\n  // 处理函数类型,不需要深拷贝，直接返回\n  if (typeof originValue === 'function') return originValue\n  // 处理Symbol类型，返回一个相同description的Symbol\n  if (typeof originValue === 'symbol') return Symbol(originValue.description)\n  // 处理Set类型\n  if (originValue instanceof Set) return new Set([...originValue])\n  // 处理Map类型\n  if (originValue instanceof Map) return new Set([...originValue])\n\n  // 解决循环引用问题\n  if (weakMap.has(originValue)) {\n    return weakMap.get(originValue)\n  }\n  weakMap.set(originValue, newObj)\n\n  for (const key in originValue) {\n    newObj[key] = deepClone(originValue[key], weakMap)\n  }\n  // 处理Symbol类型作为key\n  const symbolKeys = Object.getOwnPropertySymbols(originValue)\n  for (const sKey in symbolKeys) {\n    newObj[sKey] = deepClone(originValue[sKey], weakMap)\n  }\n\n  return newObj\n}\n```\n\n## 十四、事件总线\n\n```javascript\nclass LyEventBus {\n  constructor() {\n    this.eventBus = {}\n  }\n\n  on(eventName, eventCallBack, thisArg) {\n    let handlers = this.eventBus[eventName]\n    if (!handlers) handlers = []\n    handlers.push({\n      eventCallBack,\n      thisArg\n    })\n    this.eventBus[eventName] = handlers\n  }\n\n  emit(eventName, ...payload) {\n    const handlers = this.eventBus[eventName]\n    if (!handlers) return\n    handlers.forEach((handler) => {\n      handler.eventCallBack.apply(handler.thisArg, payload)\n    })\n  }\n\n  off(eventName, eventCallBack) {\n    const handlers = this.eventBus[eventName]\n    if (!handlers) return\n    const copyHandlers = [...handlers]\n    copyHandlers.forEach((handler) => {\n      if (handler.eventCallBack === eventCallBack) {\n        const index = handlers.indexOf(handler)\n        handlers.splice(index, 1)\n      }\n    })\n  }\n}\n```\n\n## 十五、快速排序\n\n```javascript\nfunction quickSort(arr, func = (a, b) => a - b) {\n  if (!arr || !arr.length) return [] // 确保传入的是数组\n  if (arr.length === 1) return arr // 跳出递归条件\n  const pivot = arr[0] // 选取基准元素\n  // 小于基准元素的元素集合\n  const smallSet = arr.slice(1).filter((item) => quickSort(item, pivot) < 0)\n  // 大于基准元素的元素集合\n  const bigSet = arr.slice(1).filter((item) => quickSort(item, pivot) > 0)\n  return quickSort(smallSet, func).concat([pivot]).concat(quickSort(bigSet, func))\n}\n```\n","source":"_posts/js高级.md","raw":"---\n\ntitle: JS 高级\ntag: Javascript\nkeywords: Javascript\ncategories: Javascript\n\n---\n\n## 一、深入 javascript 与运行原理\n\n### 1.V8 引擎的原理\n\n- V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用户 Chrome 和 nodejs 等\n\n- 它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32， ARM 或 MIPS 处理器的 Linux 系统上运行\n- V8 可以独立运行，也可以嵌入到任何 C ++应用程序中\n\n### 2.V8 引擎的架构\n\n- parse 模块将 javascript 代码转换成 ast 抽象语法树，这是因为解释器并不直接认识 javascript 代码\n- Ignition 是一个解释器，会将 ast 转换成 ByteCode 字节码\n- TurboFan 是一个编译器，可以将字节码变异成 CPU 可以直接执行的机器码 ![1](./images/1.png)\n\n### 3.V8 执行的细节\n\n- Blink 将解析 HTML 文件时，遇到 Javascript 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换\n- Scanner 会进行词法分析，词法分析会将代码转换成 tokens\n- 接下来 tokens 经过 Parser 和 PreParser 模块转换成 AST 树\n  - Parser 就是将 tokens 转成 AST 树结构\n  - PreParser 称之为预解析，为什么需要预解析呢？\n    - 这是因为并不是所有的 Javscript 代码，在一开始就会被执行。对所有的 Javascript 代码进行解析，必然会影响网页的运行效率\n    - 所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析就是在函数被调用时才会进行\n    - 比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析\n- 生成 AST 树后，会被 Ignition 模块专程字节码（bytecode），之后的过程就是代码的执行过程\n\n### 4.Javascript 的执行过程\n\n1. 初始化全局对象\n   - js 引擎在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）\n     - 该对象所有的作用域（scope）都可以访问\n     - 里面会包含 Date、Array、String、Number、setTimeout、setInteval 等等全局属性 AA 己\n2. 创建执行上下文栈\n   - js 引擎内部有一个执行上下文栈（Execution Context Stack， 简称 ECS），它是用于执行代码的调用栈（执行栈）\n   - 那么现在它要执行谁呢？执行的是全局的代码块：\n     - 全局的代码块为了执行会创建一个全局执行上下文 Global Execution Context（GEC），GEC 中会创建一个 VO 对象（就是 GO 对象）\n     - GEC 会放到 ECS 中执行\n   - GEC 被放入到 ECS 里面包含两个内容：\n     - 第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是只是声明，不会赋值。这个过程也称作是作用域提升\n     - 第二部分：在代码执行中，对变量赋值，或者执行其他的函数\n3. 遇到函数创建函数执行上下文\n   - 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context， 简称 FEC），并且压入到 EC Stack 中\n   - FEC 包含三部分内容：\n     - 第一部分：在解析函数称为 AST 树结构时，会创建一个 Activation Object（AO）\n       - AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量\n     - 第二部分：作用域链，由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找（函数的父级作用域 Parent Scope 和函数的定义位置有关系，和调用位置是没有关系的）\n     - 第三部分：this 绑定的值\n\n## 二、JS 的内存管理和闭包\n\n### 1.认识内存管理\n\n- 不管什么样的编程语言，在**代码的执行过程中都是需要给它分配内存**的，不同的是**某些编程语言**需要我们**自己手动**\n\n  **的管理内存**，**某些编程语言**会可以**自动帮助我们管理内存**\n\n- 不管以什么样的方式来管理内存，**内存的管理都会有如下的生命周期**：\n\n  - 第一步：分配申请你需要的内存（申请）；\n  - 第二步：使用分配的内存（存放一些东西，比如对象等）；\n  - 第三步：不需要使用时，对其进行释放；\n\n- **不同的编程语言对于第一步和第三步会有不同的实现：**\n\n- 手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函数）\n- 自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；\n\n- 我们可以知道 JavaScript 通常情况下是不需要手动来管理的。\n\n### 2.JS 的内存管理\n\n- javascript 会在定义变量时分配内存\n  - 对于基本数据类型，会在栈空间分配内存\n  - 对于复杂数据类型，会在堆空间开辟内存，并将这块空间的指针返回给值变量引用\n\n### 3.JS 的垃圾回收\n\n- 因为**内存的大小是有限**的，所以当**内存不再需要的时候**，我们需要**对其进行释放**，以便腾出**更多的内存空间**\n- JS 有自己的垃圾回收机制（Garbage Collection，简称 GC）\n- 对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间\n\n### 4.常见的 GC 算法\n\n1. 引用计数算法\n\n   - 当一个对象有一个引用指向它时，那么这个对象的引用就+1，当一个对象的引用为 0 时，这个对象就可以被销\n\n     毁掉\n\n   - p 这个算法有一个很大的弊端就是会产生循环引用\n\n2. 标记清除\n\n   - 这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对\n\n     于哪些没有引用到的对象，就认为是不可用的对象\n\n   - 这个算法可以很好的解决循环引用的问题\n\n   - JS 引擎比较广泛的采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合\n\n     一些其他的算法。\n\n## 三、JS 中闭包的定义\n\n- 这里先来看一下闭包的定义，分成两个：在计算机科学中和在 JavaScript 中。\n- 在计算机科学中对闭包的定义（维基百科）：\n\n  - 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；\n  - 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术；\n  - 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；\n  - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；\n\n- 闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包：\n\n  - 因为 JavaScript 中有大量的设计是来源于 Scheme 的；\n\n- 我们再来看一下 MDN 对 JavaScript 闭包的解释：\n\n  - 一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）；\n  - 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；\n  - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；\n\n- 那么我的理解和总结：\n- 一个普通的函数 function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；\n- 从广义的角度来说：JavaScript 中的函数都是闭包；\n- 从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；\n\n## 四、JS 中的 this 指向\n\n### 1.this 的绑定规律\n\n1. 函数在调用时，JavaScript 会默认给 this 绑定一个值；\n2. this 的绑定和定义的位置（编写的位置）没有关系；\n3. this 的绑定和调用方式以及调用的位置有关系；\n4. this 是在运行时被绑定的；\n\n### 2.this 的绑定规则\n\n- 默认绑定（优先级最低）：独立函数调用\n- 隐式绑定（优先级大于默认绑定）：obj.fn()\n- 显示绑定（优先级大于隐式绑定）：apply、call、bind 等\n- new 绑定（优先级大于显示绑定）：new Foo()\n\n## 五、手写 call、apply 和 bind\n\n### 1.call 函数的实现\n\n```javascript\nFunction.prototype.lyCall = function (thisArg, ...args) {\n  // 1.处理thisArg\n  thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n  // 2.隐式绑定，调用需要修改this指向的函数\n  const key = Symbol()\n  thisArg[key] = this\n  const result = thisArg[key](...args)\n  delete thisArg[key]\n  // 3.返回函数执行结果\n  return result\n}\n```\n\n### 2.apply 函数的实现\n\n```javascript\nFunction.prototype.lyApply = function (thisArg, argArray) {\n  // 1.处理thisArg\n  thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n  // 2.隐式绑定，调用需要修改this指向的函数\n  const key = Symbol()\n  thisArg[key] = this\n  argArray = argArray || []\n  const result = thisArg[key](...argArray)\n  delete thisArg[key]\n  // 3.返回函数执行结果\n  return result\n}\n```\n\n### 3.bind 函数的实现\n\n```javascript\nFunction.prototype.lyBind = function (thisArg, ...args) {\n  return function (...bindArgs) {\n    // 1.处理thisArg\n    thisArg = thisArg !== undefined && thisArg !== null ? Object(thisArg) : window\n    // 2.隐式绑定，调用需要修改this指向的函数\n    const key = Symbol()\n    thisArg[key] = this\n    const result = thisArg[key]([...args, ...bindArgs])\n    delete thisArg[key]\n    // 3.返回函数执行结果\n    return result\n  }\n}\n```\n\n## 六、函数科里化\n\n### 1.函数科里化的概念\n\n一个接收多个参数的函数，变成一个可以只接收部分参数，并且返回一个接收剩余参数的函数的函数。这个过程就叫科里化\n\n### 2.函数科里化的实现\n\n```javascript\nfunction curring(fn) {\n  const curriedFn = function (...args) {\n    if (args.length >= fn.length) {\n      // 本次函数调用传入的参数个数已经达到需要执行函数的最大参数长度，直接执行该函数\n      return fn.apply(this, args)\n    } else {\n      // 本次函数调用传入的参数个数没有达到需要执行函数的最大参数长度，返回一个接收剩余参数的函数\n      return function (...restArgs) {\n        return curriedFn.apply(this, [...args, ...restArgs])\n      }\n    }\n  }\n\n  return curriedFn\n}\n```\n\n## 七、组合函数\n\n### 1.组合函数的概念\n\n将多个需要执行的函数，组合到一个函数里面，函数内部会自动依次调用。这个过程就是对函数的组合，这个函数就称为组合函数\n\n### 2.通用组合函数的实现\n\n```javascript\nfunction compose(...fns) {\n  fns.forEach((fn) => {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected arguments are function!')\n    }\n  })\n  const list = fns.slice()\n  return function (...args) {\n    let result = list.shift().apply(this, args)\n    while (list.length > 0) {\n      result = list.shift().call(this, result)\n    }\n    return result\n  }\n}\n```\n\n## 八、寄生组合式继承（最终方案）\n\n```javascript\n// 寄生式继承-对象\nfunction createObject(o) {\n  function Fn() {}\n  Fn.prototype = o\n  return new Fn()\n}\n\nfunction inheritPrototype(subType, superType) {\n  // subType.prototype = Object.create(superType.prototype) // 子类显式原型指向新创建的对象，新对象__proto__指向父类显示原型\n  subType.prototype = createObject(superType.prototype)\n  // 子类显示原型的构造函数指向自己\n  Object.defineProperty(subType.prototype, 'constuctor', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: subType\n  })\n}\n// 父类\nfunction Person(name) {\n  this.name = name\n}\nPerson.prototype.eating = function () {\n  console.log('eating')\n}\n// 子类\nfunction Student(sno) {\n  // 继承父类属性\n  Person.call(this, name)\n  this.sno = sno\n}\n// 继承父类方法\ninheritPrototype(Student, Person)\n```\n\n## 九、手写 instanceof\n\n```javascript\nfunction _instanceof(a, b) {\n  while (a.__proto__) {\n    if (a.__proto__ === b.prototype) {\n      return true\n    }\n    a = a.__proto__\n  }\n  return false\n}\n```\n\n## 十、手写 new 操作符\n\n```javascript\nfunction _new(constructor, ...args) {\n  let instance = Object.create(constructor.prototype)\n  const res = constuctor.apply(instance, args)\n  // 构造函数有明确的返回值且返回值是Object时，直接返回构造函数的返回结果\n  return res instanceof Object ? res : instance\n}\n```\n\n## 十一、响应式原理实现\n\n```javascript\n// Dep类存储响应式函数（副作用）\nclass Dep {\n  subscribers = new Set()\n  addEffect() {\n    activeEffect && this.subscribers.add(activeEffect)\n  }\n  notify() {\n    this.subscribers.forEach((effect) => effect())\n  }\n}\n\n// 当前需要收集的响应式函数（副作用）\nlet activeEffect = null\n// 第一次执行响应式函数（副作用），并触发对应的追踪收集操作\nconst watchEffect = (fn) => {\n  activeEffect = fn\n  fn()\n  activeEffect = null\n}\n\n// WeakMap: { obj -> Map }  Map: { obj属性 -> dep对象(存储响应式函数,并提供触发方法) }\nconst weakMap = new WeakMap()\n// 收集响应式函数（副作用）\nconst track = (target, key) => {\n  let targetMap = weakMap.get(target)\n  if (!targetMap) {\n    targetMap = new Map()\n    weakMap.set(target, targetMap)\n  }\n  let dep = targetMap.get(key)\n  if (!dep) {\n    dep = new Dep()\n    targetMap.set(key, dep)\n  }\n  dep.addEffect()\n}\n// 触发响应式函数（副作用）\nconst trigger = (target, key) => {\n  const targetMap = weakMap.get(target)\n  if (!targetMap) return\n  const dep = targetMap.get(key)\n  dep?.notify()\n}\n\n// 创建代理对象\nconst reactive = (o) => {\n  return new Proxy(o, {\n    get(target, key, receiver) {\n      track(target, key)\n      return Reflect.get(target, key, receiver)\n    },\n    set(target, key, newValue, receiver) {\n      trigger(target, key)\n      Reflect.set(target, key, newValue, receiver)\n    }\n  })\n}\n```\n\n## 十二、手写简易版 promise 实现\n\n```javascript\nconst PROMISE_STATUS_PENDING = 'pending'\nconst PROMISE_STATUS_FULFILLED = 'fulfilled'\nconst PROMISE_STATUS_REJECTED = 'rejected'\n\nconst execCallbackWithCatchErr = (execFn, value, resolve, reject) => {\n  try {\n    const result = execFn(value)\n    resolve(result)\n  } catch (err) {\n    reject(err)\n  }\n}\n\nclass LyPromise {\n  status = PROMISE_STATUS_PENDING\n  value = undefined\n  reason = undefined\n  onfulfilledCallbacks = []\n  onrejectedCallbacks = []\n  constructor(executor) {\n    const resolve = (value) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return\n          this.status = PROMISE_STATUS_FULFILLED\n          this.value = value\n          this.onfulfilledCallbacks.forEach((callback) => {\n            callback(this.value)\n          })\n        })\n      }\n    }\n    const reject = (reason) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return\n          this.status = PROMISE_STATUS_REJECTED\n          this.reason = reason\n          this.onrejectedCallbacks.forEach((callback) => {\n            callback(this.reason)\n          })\n        })\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (err) {\n      reject(err)\n    }\n  }\n\n  then(onfulfilled, onrejected) {\n    return new LyPromise((resolve, reject) => {\n      onfulfilled =\n        onfulfilled ||\n        ((res) => {\n          return res\n        })\n      onrejected =\n        onrejected ||\n        ((err) => {\n          throw err\n        })\n\n      switch (this.status) {\n        case PROMISE_STATUS_PENDING:\n          this.onfulfilledCallbacks.push(() => {\n            execCallbackWithCatchErr(onfulfilled, this.value, resolve, reject)\n          })\n          this.onrejectedCallbacks.push(() => {\n            execCallbackWithCatchErr(onrejected, this.reason, resolve, reject)\n          })\n          break\n        case PROMISE_STATUS_FULFILLED:\n          execCallbackWithCatchErr(onfulfilled, this.value, resolve, reject)\n          break\n        case PROMISE_STATUS_REJECTED:\n          execCallbackWithCatchErr(onrejected, this.reason, resolve, reject)\n          break\n      }\n    })\n  }\n\n  catch(onrejected) {\n    return this.then(undefined, onrejected)\n  }\n\n  finally(onfinally) {\n    return this.then(onfinally, onfinally)\n  }\n\n  static resolve(value) {\n    return new LyPromise((resolve) => resolve(value))\n  }\n\n  static reject(reason) {\n    return new LyPromise((resolve, reject) => reject(reason))\n  }\n\n  static all(promises) {\n    return new Promise((resolve, reject) => {\n      let values = []\n      promises.forEach((promise) => {\n        promise.then((res) => {\n          values.push(res)\n          if (values.length === promises.length) resolve(values)\n        }, reject)\n      })\n    })\n  }\n\n  static allSettled(promises) {\n    return new Promise((resolve, reject) => {\n      let result = []\n      promises.forEach((promise) => {\n        promise.then(\n          (res) => {\n            result.push({\n              status: PROMISE_STATUS_FULFILLED,\n              value: res\n            })\n            if (result.length === promises.length) resolve(result)\n          },\n          (err) => {\n            result.push({\n              status: PROMISE_STATUS_REJECTED,\n              reason: err\n            })\n            if (result.length === promises.length) resolve(result)\n          }\n        )\n      })\n    })\n  }\n\n  static race(promises) {\n    return new LyPromise((resolve, reject) => {\n      promises.forEach((promise) => {\n        promise.then(resolve, reject)\n      })\n    })\n  }\n\n  static any(promises) {\n    return new LyPromise((resolve, reject) => {\n      let reasons = []\n      promises.forEach((promise) => {\n        promise.then(resolve, (err) => {\n          reasons.push(err)\n          if (reasons.length === promises.length) {\n            reject(new AggregateError(reasons))\n          }\n        })\n      })\n    })\n  }\n}\n```\n\n## 十三、异步方案：Promise+Generator\n\n```javascript\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(url)\n    }, 2000)\n  })\n}\n\n// 生成器\nfunction* getData() {\n  const res1 = yield requestData('coder')\n  const res2 = yield requestData(res1 + '111')\n  const res3 = yield requestData(res2 + '222')\n  const res4 = yield requestData(res3 + '333')\n  console.log(res4)\n}\n\n// 自动递归执行生成器\nfunction co(genFn) {\n  const generator = genFn()\n  const exec = (res) => {\n    const result = generator.next(res)\n    if (result.done) {\n      return result.value\n    }\n    result.value.then((res) => {\n      exec(res)\n    })\n  }\n  exec()\n}\n\nco(getData)\n```\n\n## 十二、手写防抖和节流\n\n### 1.防抖\n\n```javascript\nfunction debounce(fn, delay, immediate = false) {\n  let timer = null\n  let isInvoke = false\n  const _debounce = (...args) {\n    if(timer) clearTimeout(timer)\n    if(immediate && !isInvoke) {\n      fn.apply(this, args)\n      isInvoke = true\n    }\n    timer = setTimeout(() => {\n      timer = null\n      isInvoke = false\n      fn.apply(this, args)\n    }, delay)\n  }\n\n  _debounce.cancel = () => {\n     if(timer) clearTimeout(timer)\n     timer = null\n     isInvoke = false\n  }\n\n  return _debounce\n}\n```\n\n### 2.节流\n\n```javascript\nfunction throttle(fn, interval, options = { leading: true, trailing: true }) {\n  let last = 0\n  timer = null\n  const { leading, trailing } = options\n  const _throttle = function (...args) {\n    let now = Date.now()\n    if (!last && !leading) last = now\n    const remainTime = interval - (now - last)\n    if (remainTime <= 0) {\n      fn.apply(fn, args)\n      last = now\n      return\n    }\n    if (trailing) {\n      if (timer) {\n        clearTimeout(timer)\n        timer = null\n      }\n      timer = setTimeout(() => {\n        fn.apply(fn, args)\n        timer = null\n        last = !leading ? 0 : Date.now()\n      }, remainTime)\n    }\n  }\n  _throttle.cancel = function () {\n    if (timer) {\n      clearTimeout(timer)\n      timer = null\n    }\n  }\n  return _throttle\n}\n```\n\n## 十三、深拷贝\n\n```javascript\nfunction isObject(o) {\n  const type = typeof o\n  return o !== null && (type === 'object' || type === 'function')\n}\nfunction deepClone(originValue, weakMap = new WeakMap()) {\n  // 处理数组格式\n  const newObj = Array.isArray(originValue) ? [] : {}\n  // 处理简单数据类型\n  if (!isObject(originValue)) return originValue\n  // 处理函数类型,不需要深拷贝，直接返回\n  if (typeof originValue === 'function') return originValue\n  // 处理Symbol类型，返回一个相同description的Symbol\n  if (typeof originValue === 'symbol') return Symbol(originValue.description)\n  // 处理Set类型\n  if (originValue instanceof Set) return new Set([...originValue])\n  // 处理Map类型\n  if (originValue instanceof Map) return new Set([...originValue])\n\n  // 解决循环引用问题\n  if (weakMap.has(originValue)) {\n    return weakMap.get(originValue)\n  }\n  weakMap.set(originValue, newObj)\n\n  for (const key in originValue) {\n    newObj[key] = deepClone(originValue[key], weakMap)\n  }\n  // 处理Symbol类型作为key\n  const symbolKeys = Object.getOwnPropertySymbols(originValue)\n  for (const sKey in symbolKeys) {\n    newObj[sKey] = deepClone(originValue[sKey], weakMap)\n  }\n\n  return newObj\n}\n```\n\n## 十四、事件总线\n\n```javascript\nclass LyEventBus {\n  constructor() {\n    this.eventBus = {}\n  }\n\n  on(eventName, eventCallBack, thisArg) {\n    let handlers = this.eventBus[eventName]\n    if (!handlers) handlers = []\n    handlers.push({\n      eventCallBack,\n      thisArg\n    })\n    this.eventBus[eventName] = handlers\n  }\n\n  emit(eventName, ...payload) {\n    const handlers = this.eventBus[eventName]\n    if (!handlers) return\n    handlers.forEach((handler) => {\n      handler.eventCallBack.apply(handler.thisArg, payload)\n    })\n  }\n\n  off(eventName, eventCallBack) {\n    const handlers = this.eventBus[eventName]\n    if (!handlers) return\n    const copyHandlers = [...handlers]\n    copyHandlers.forEach((handler) => {\n      if (handler.eventCallBack === eventCallBack) {\n        const index = handlers.indexOf(handler)\n        handlers.splice(index, 1)\n      }\n    })\n  }\n}\n```\n\n## 十五、快速排序\n\n```javascript\nfunction quickSort(arr, func = (a, b) => a - b) {\n  if (!arr || !arr.length) return [] // 确保传入的是数组\n  if (arr.length === 1) return arr // 跳出递归条件\n  const pivot = arr[0] // 选取基准元素\n  // 小于基准元素的元素集合\n  const smallSet = arr.slice(1).filter((item) => quickSort(item, pivot) < 0)\n  // 大于基准元素的元素集合\n  const bigSet = arr.slice(1).filter((item) => quickSort(item, pivot) > 0)\n  return quickSort(smallSet, func).concat([pivot]).concat(quickSort(bigSet, func))\n}\n```\n","slug":"js高级","published":1,"date":"2022-11-01T06:32:50.800Z","updated":"2022-11-01T07:13:53.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9kx000gi024ed3m1f2f","content":"<h2 id=\"一、深入-javascript-与运行原理\"><a href=\"#一、深入-javascript-与运行原理\" class=\"headerlink\" title=\"一、深入 javascript 与运行原理\"></a>一、深入 javascript 与运行原理</h2><h3 id=\"1-V8-引擎的原理\"><a href=\"#1-V8-引擎的原理\" class=\"headerlink\" title=\"1.V8 引擎的原理\"></a>1.V8 引擎的原理</h3><ul>\n<li><p>V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用户 Chrome 和 nodejs 等</p>\n</li>\n<li><p>它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32， ARM 或 MIPS 处理器的 Linux 系统上运行</p>\n</li>\n<li><p>V8 可以独立运行，也可以嵌入到任何 C ++应用程序中</p>\n</li>\n</ul>\n<h3 id=\"2-V8-引擎的架构\"><a href=\"#2-V8-引擎的架构\" class=\"headerlink\" title=\"2.V8 引擎的架构\"></a>2.V8 引擎的架构</h3><ul>\n<li>parse 模块将 javascript 代码转换成 ast 抽象语法树，这是因为解释器并不直接认识 javascript 代码</li>\n<li>Ignition 是一个解释器，会将 ast 转换成 ByteCode 字节码</li>\n<li>TurboFan 是一个编译器，可以将字节码变异成 CPU 可以直接执行的机器码 <img src=\"./images/1.png\" alt=\"1\"></li>\n</ul>\n<h3 id=\"3-V8-执行的细节\"><a href=\"#3-V8-执行的细节\" class=\"headerlink\" title=\"3.V8 执行的细节\"></a>3.V8 执行的细节</h3><ul>\n<li>Blink 将解析 HTML 文件时，遇到 Javascript 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换</li>\n<li>Scanner 会进行词法分析，词法分析会将代码转换成 tokens</li>\n<li>接下来 tokens 经过 Parser 和 PreParser 模块转换成 AST 树<ul>\n<li>Parser 就是将 tokens 转成 AST 树结构</li>\n<li>PreParser 称之为预解析，为什么需要预解析呢？<ul>\n<li>这是因为并不是所有的 Javscript 代码，在一开始就会被执行。对所有的 Javascript 代码进行解析，必然会影响网页的运行效率</li>\n<li>所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析就是在函数被调用时才会进行</li>\n<li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生成 AST 树后，会被 Ignition 模块专程字节码（bytecode），之后的过程就是代码的执行过程</li>\n</ul>\n<h3 id=\"4-Javascript-的执行过程\"><a href=\"#4-Javascript-的执行过程\" class=\"headerlink\" title=\"4.Javascript 的执行过程\"></a>4.Javascript 的执行过程</h3><ol>\n<li>初始化全局对象<ul>\n<li>js 引擎在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）<ul>\n<li>该对象所有的作用域（scope）都可以访问</li>\n<li>里面会包含 Date、Array、String、Number、setTimeout、setInteval 等等全局属性 AA 己</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>创建执行上下文栈<ul>\n<li>js 引擎内部有一个执行上下文栈（Execution Context Stack， 简称 ECS），它是用于执行代码的调用栈（执行栈）</li>\n<li>那么现在它要执行谁呢？执行的是全局的代码块：<ul>\n<li>全局的代码块为了执行会创建一个全局执行上下文 Global Execution Context（GEC），GEC 中会创建一个 VO 对象（就是 GO 对象）</li>\n<li>GEC 会放到 ECS 中执行</li>\n</ul>\n</li>\n<li>GEC 被放入到 ECS 里面包含两个内容：<ul>\n<li>第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是只是声明，不会赋值。这个过程也称作是作用域提升</li>\n<li>第二部分：在代码执行中，对变量赋值，或者执行其他的函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>遇到函数创建函数执行上下文<ul>\n<li>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context， 简称 FEC），并且压入到 EC Stack 中</li>\n<li>FEC 包含三部分内容：<ul>\n<li>第一部分：在解析函数称为 AST 树结构时，会创建一个 Activation Object（AO）<ul>\n<li>AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量</li>\n</ul>\n</li>\n<li>第二部分：作用域链，由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找（函数的父级作用域 Parent Scope 和函数的定义位置有关系，和调用位置是没有关系的）</li>\n<li>第三部分：this 绑定的值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"二、JS-的内存管理和闭包\"><a href=\"#二、JS-的内存管理和闭包\" class=\"headerlink\" title=\"二、JS 的内存管理和闭包\"></a>二、JS 的内存管理和闭包</h2><h3 id=\"1-认识内存管理\"><a href=\"#1-认识内存管理\" class=\"headerlink\" title=\"1.认识内存管理\"></a>1.认识内存管理</h3><ul>\n<li><p>不管什么样的编程语言，在<strong>代码的执行过程中都是需要给它分配内存</strong>的，不同的是<strong>某些编程语言</strong>需要我们<strong>自己手动</strong></p>\n<p><strong>的管理内存</strong>，<strong>某些编程语言</strong>会可以<strong>自动帮助我们管理内存</strong></p>\n</li>\n<li><p>不管以什么样的方式来管理内存，<strong>内存的管理都会有如下的生命周期</strong>：</p>\n<ul>\n<li>第一步：分配申请你需要的内存（申请）；</li>\n<li>第二步：使用分配的内存（存放一些东西，比如对象等）；</li>\n<li>第三步：不需要使用时，对其进行释放；</li>\n</ul>\n</li>\n<li><p><strong>不同的编程语言对于第一步和第三步会有不同的实现：</strong></p>\n</li>\n<li><p>手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函数）</p>\n</li>\n<li><p>自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；</p>\n</li>\n<li><p>我们可以知道 JavaScript 通常情况下是不需要手动来管理的。</p>\n</li>\n</ul>\n<h3 id=\"2-JS-的内存管理\"><a href=\"#2-JS-的内存管理\" class=\"headerlink\" title=\"2.JS 的内存管理\"></a>2.JS 的内存管理</h3><ul>\n<li>javascript 会在定义变量时分配内存<ul>\n<li>对于基本数据类型，会在栈空间分配内存</li>\n<li>对于复杂数据类型，会在堆空间开辟内存，并将这块空间的指针返回给值变量引用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-JS-的垃圾回收\"><a href=\"#3-JS-的垃圾回收\" class=\"headerlink\" title=\"3.JS 的垃圾回收\"></a>3.JS 的垃圾回收</h3><ul>\n<li>因为<strong>内存的大小是有限</strong>的，所以当<strong>内存不再需要的时候</strong>，我们需要<strong>对其进行释放</strong>，以便腾出<strong>更多的内存空间</strong></li>\n<li>JS 有自己的垃圾回收机制（Garbage Collection，简称 GC）</li>\n<li>对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间</li>\n</ul>\n<h3 id=\"4-常见的-GC-算法\"><a href=\"#4-常见的-GC-算法\" class=\"headerlink\" title=\"4.常见的 GC 算法\"></a>4.常见的 GC 算法</h3><ol>\n<li><p>引用计数算法</p>\n<ul>\n<li><p>当一个对象有一个引用指向它时，那么这个对象的引用就+1，当一个对象的引用为 0 时，这个对象就可以被销</p>\n<p>毁掉</p>\n</li>\n<li><p>p 这个算法有一个很大的弊端就是会产生循环引用</p>\n</li>\n</ul>\n</li>\n<li><p>标记清除</p>\n<ul>\n<li><p>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对</p>\n<p>于哪些没有引用到的对象，就认为是不可用的对象</p>\n</li>\n<li><p>这个算法可以很好的解决循环引用的问题</p>\n</li>\n<li><p>JS 引擎比较广泛的采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合</p>\n<p>一些其他的算法。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"三、JS-中闭包的定义\"><a href=\"#三、JS-中闭包的定义\" class=\"headerlink\" title=\"三、JS 中闭包的定义\"></a>三、JS 中闭包的定义</h2><ul>\n<li><p>这里先来看一下闭包的定义，分成两个：在计算机科学中和在 JavaScript 中。</p>\n</li>\n<li><p>在计算机科学中对闭包的定义（维基百科）：</p>\n<ul>\n<li>闭包（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures）；</li>\n<li>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术；</li>\n<li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；</li>\n<li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；</li>\n</ul>\n</li>\n<li><p>闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包：</p>\n<ul>\n<li>因为 JavaScript 中有大量的设计是来源于 Scheme 的；</li>\n</ul>\n</li>\n<li><p>我们再来看一下 MDN 对 JavaScript 闭包的解释：</p>\n<ul>\n<li>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）；</li>\n<li>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</li>\n<li>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</li>\n</ul>\n</li>\n<li><p>那么我的理解和总结：</p>\n</li>\n<li><p>一个普通的函数 function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；</p>\n</li>\n<li><p>从广义的角度来说：JavaScript 中的函数都是闭包；</p>\n</li>\n<li><p>从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；</p>\n</li>\n</ul>\n<h2 id=\"四、JS-中的-this-指向\"><a href=\"#四、JS-中的-this-指向\" class=\"headerlink\" title=\"四、JS 中的 this 指向\"></a>四、JS 中的 this 指向</h2><h3 id=\"1-this-的绑定规律\"><a href=\"#1-this-的绑定规律\" class=\"headerlink\" title=\"1.this 的绑定规律\"></a>1.this 的绑定规律</h3><ol>\n<li>函数在调用时，JavaScript 会默认给 this 绑定一个值；</li>\n<li>this 的绑定和定义的位置（编写的位置）没有关系；</li>\n<li>this 的绑定和调用方式以及调用的位置有关系；</li>\n<li>this 是在运行时被绑定的；</li>\n</ol>\n<h3 id=\"2-this-的绑定规则\"><a href=\"#2-this-的绑定规则\" class=\"headerlink\" title=\"2.this 的绑定规则\"></a>2.this 的绑定规则</h3><ul>\n<li>默认绑定（优先级最低）：独立函数调用</li>\n<li>隐式绑定（优先级大于默认绑定）：obj.fn()</li>\n<li>显示绑定（优先级大于隐式绑定）：apply、call、bind 等</li>\n<li>new 绑定（优先级大于显示绑定）：new Foo()</li>\n</ul>\n<h2 id=\"五、手写-call、apply-和-bind\"><a href=\"#五、手写-call、apply-和-bind\" class=\"headerlink\" title=\"五、手写 call、apply 和 bind\"></a>五、手写 call、apply 和 bind</h2><h3 id=\"1-call-函数的实现\"><a href=\"#1-call-函数的实现\" class=\"headerlink\" title=\"1.call 函数的实现\"></a>1.call 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyCall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...args</span>) &#123;<br>  <span class=\"hljs-comment\">// 1.处理thisArg</span><br>  thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>  <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>  <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>  thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">const</span> result = thisArg[key](...args)<br>  <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>  <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-apply-函数的实现\"><a href=\"#2-apply-函数的实现\" class=\"headerlink\" title=\"2.apply 函数的实现\"></a>2.apply 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyApply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, argArray</span>) &#123;<br>  <span class=\"hljs-comment\">// 1.处理thisArg</span><br>  thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>  <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>  <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>  thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>  argArray = argArray || []<br>  <span class=\"hljs-keyword\">const</span> result = thisArg[key](...argArray)<br>  <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>  <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-bind-函数的实现\"><a href=\"#3-bind-函数的实现\" class=\"headerlink\" title=\"3.bind 函数的实现\"></a>3.bind 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...args</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...bindArgs</span>) &#123;<br>    <span class=\"hljs-comment\">// 1.处理thisArg</span><br>    thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>    <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>    thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>    <span class=\"hljs-keyword\">const</span> result = thisArg[key]([...args, ...bindArgs])<br>    <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>    <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、函数科里化\"><a href=\"#六、函数科里化\" class=\"headerlink\" title=\"六、函数科里化\"></a>六、函数科里化</h2><h3 id=\"1-函数科里化的概念\"><a href=\"#1-函数科里化的概念\" class=\"headerlink\" title=\"1.函数科里化的概念\"></a>1.函数科里化的概念</h3><p>一个接收多个参数的函数，变成一个可以只接收部分参数，并且返回一个接收剩余参数的函数的函数。这个过程就叫科里化</p>\n<h3 id=\"2-函数科里化的实现\"><a href=\"#2-函数科里化的实现\" class=\"headerlink\" title=\"2.函数科里化的实现\"></a>2.函数科里化的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curring</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> curriedFn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> &gt;= fn.<span class=\"hljs-property\">length</span>) &#123;<br>      <span class=\"hljs-comment\">// 本次函数调用传入的参数个数已经达到需要执行函数的最大参数长度，直接执行该函数</span><br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 本次函数调用传入的参数个数没有达到需要执行函数的最大参数长度，返回一个接收剩余参数的函数</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...restArgs</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> curriedFn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, [...args, ...restArgs])<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> curriedFn<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、组合函数\"><a href=\"#七、组合函数\" class=\"headerlink\" title=\"七、组合函数\"></a>七、组合函数</h2><h3 id=\"1-组合函数的概念\"><a href=\"#1-组合函数的概念\" class=\"headerlink\" title=\"1.组合函数的概念\"></a>1.组合函数的概念</h3><p>将多个需要执行的函数，组合到一个函数里面，函数内部会自动依次调用。这个过程就是对函数的组合，这个函数就称为组合函数</p>\n<h3 id=\"2-通用组合函数的实现\"><a href=\"#2-通用组合函数的实现\" class=\"headerlink\" title=\"2.通用组合函数的实现\"></a>2.通用组合函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...fns</span>) &#123;<br>  fns.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">fn</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> fn !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Expected arguments are function!&#x27;</span>)<br>    &#125;<br>  &#125;)<br>  <span class=\"hljs-keyword\">const</span> list = fns.<span class=\"hljs-title function_\">slice</span>()<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> result = list.<span class=\"hljs-title function_\">shift</span>().<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    <span class=\"hljs-keyword\">while</span> (list.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      result = list.<span class=\"hljs-title function_\">shift</span>().<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, result)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、寄生组合式继承（最终方案）\"><a href=\"#八、寄生组合式继承（最终方案）\" class=\"headerlink\" title=\"八、寄生组合式继承（最终方案）\"></a>八、寄生组合式继承（最终方案）</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 寄生式继承-对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createObject</span>(<span class=\"hljs-params\">o</span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>  <span class=\"hljs-title class_\">Fn</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = o<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fn</span>()<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-params\">subType, superType</span>) &#123;<br>  <span class=\"hljs-comment\">// subType.prototype = Object.create(superType.prototype) // 子类显式原型指向新创建的对象，新对象__proto__指向父类显示原型</span><br>  subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title function_\">createObject</span>(superType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)<br>  <span class=\"hljs-comment\">// 子类显示原型的构造函数指向自己</span><br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;constuctor&#x27;</span>, &#123;<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">value</span>: subType<br>  &#125;)<br>&#125;<br><span class=\"hljs-comment\">// 父类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>&#125;<br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eating</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;eating&#x27;</span>)<br>&#125;<br><span class=\"hljs-comment\">// 子类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Student</span>(<span class=\"hljs-params\">sno</span>) &#123;<br>  <span class=\"hljs-comment\">// 继承父类属性</span><br>  <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name)<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sno</span> = sno<br>&#125;<br><span class=\"hljs-comment\">// 继承父类方法</span><br><span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-title class_\">Student</span>, <span class=\"hljs-title class_\">Person</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、手写-instanceof\"><a href=\"#九、手写-instanceof\" class=\"headerlink\" title=\"九、手写 instanceof\"></a>九、手写 instanceof</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_instanceof</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-property\">__proto__</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (a.<span class=\"hljs-property\">__proto__</span> === b.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    a = a.<span class=\"hljs-property\">__proto__</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十、手写-new-操作符\"><a href=\"#十、手写-new-操作符\" class=\"headerlink\" title=\"十、手写 new 操作符\"></a>十、手写 new 操作符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_new</span>(<span class=\"hljs-params\">constructor, ...args</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> instance = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(constructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)<br>  <span class=\"hljs-keyword\">const</span> res = constuctor.<span class=\"hljs-title function_\">apply</span>(instance, args)<br>  <span class=\"hljs-comment\">// 构造函数有明确的返回值且返回值是Object时，直接返回构造函数的返回结果</span><br>  <span class=\"hljs-keyword\">return</span> res <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span> ? res : instance<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十一、响应式原理实现\"><a href=\"#十一、响应式原理实现\" class=\"headerlink\" title=\"十一、响应式原理实现\"></a>十一、响应式原理实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Dep类存储响应式函数（副作用）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dep</span> &#123;<br>  subscribers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()<br>  <span class=\"hljs-title function_\">addEffect</span>(<span class=\"hljs-params\"></span>) &#123;<br>    activeEffect &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subscribers</span>.<span class=\"hljs-title function_\">add</span>(activeEffect)<br>  &#125;<br>  <span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subscribers</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">effect</span>) =&gt;</span> <span class=\"hljs-title function_\">effect</span>())<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 当前需要收集的响应式函数（副作用）</span><br><span class=\"hljs-keyword\">let</span> activeEffect = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-comment\">// 第一次执行响应式函数（副作用），并触发对应的追踪收集操作</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">watchEffect</span> = (<span class=\"hljs-params\">fn</span>) =&gt; &#123;<br>  activeEffect = fn<br>  <span class=\"hljs-title function_\">fn</span>()<br>  activeEffect = <span class=\"hljs-literal\">null</span><br>&#125;<br><br><span class=\"hljs-comment\">// WeakMap: &#123; obj -&gt; Map &#125;  Map: &#123; obj属性 -&gt; dep对象(存储响应式函数,并提供触发方法) &#125;</span><br><span class=\"hljs-keyword\">const</span> weakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>()<br><span class=\"hljs-comment\">// 收集响应式函数（副作用）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">track</span> = (<span class=\"hljs-params\">target, key</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> targetMap = weakMap.<span class=\"hljs-title function_\">get</span>(target)<br>  <span class=\"hljs-keyword\">if</span> (!targetMap) &#123;<br>    targetMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>    weakMap.<span class=\"hljs-title function_\">set</span>(target, targetMap)<br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> dep = targetMap.<span class=\"hljs-title function_\">get</span>(key)<br>  <span class=\"hljs-keyword\">if</span> (!dep) &#123;<br>    dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dep</span>()<br>    targetMap.<span class=\"hljs-title function_\">set</span>(key, dep)<br>  &#125;<br>  dep.<span class=\"hljs-title function_\">addEffect</span>()<br>&#125;<br><span class=\"hljs-comment\">// 触发响应式函数（副作用）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">trigger</span> = (<span class=\"hljs-params\">target, key</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> targetMap = weakMap.<span class=\"hljs-title function_\">get</span>(target)<br>  <span class=\"hljs-keyword\">if</span> (!targetMap) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-keyword\">const</span> dep = targetMap.<span class=\"hljs-title function_\">get</span>(key)<br>  dep?.<span class=\"hljs-title function_\">notify</span>()<br>&#125;<br><br><span class=\"hljs-comment\">// 创建代理对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reactive</span> = (<span class=\"hljs-params\">o</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(o, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>      <span class=\"hljs-title function_\">track</span>(target, key)<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver)<br>    &#125;,<br>    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, newValue, receiver</span>) &#123;<br>      <span class=\"hljs-title function_\">trigger</span>(target, key)<br>      <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, newValue, receiver)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十二、手写简易版-promise-实现\"><a href=\"#十二、手写简易版-promise-实现\" class=\"headerlink\" title=\"十二、手写简易版 promise 实现\"></a>十二、手写简易版 promise 实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span> = <span class=\"hljs-string\">&#x27;pending&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span> = <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span> = <span class=\"hljs-string\">&#x27;rejected&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">execCallbackWithCatchErr</span> = (<span class=\"hljs-params\">execFn, value, resolve, reject</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">execFn</span>(value)<br>    <span class=\"hljs-title function_\">resolve</span>(result)<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-title function_\">reject</span>(err)<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LyPromise</span> &#123;<br>  status = <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span><br>  value = <span class=\"hljs-literal\">undefined</span><br>  reason = <span class=\"hljs-literal\">undefined</span><br>  onfulfilledCallbacks = []<br>  onrejectedCallbacks = []<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">executor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">resolve</span> = (<span class=\"hljs-params\">value</span>) =&gt; &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> === <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;<br>        <span class=\"hljs-title function_\">queueMicrotask</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> !== <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) <span class=\"hljs-keyword\">return</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> = <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onfulfilledCallbacks</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">callback</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>)<br>          &#125;)<br>        &#125;)<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reject</span> = (<span class=\"hljs-params\">reason</span>) =&gt; &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> === <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;<br>        <span class=\"hljs-title function_\">queueMicrotask</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> !== <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) <span class=\"hljs-keyword\">return</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> = <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span> = reason<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onrejectedCallbacks</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">callback</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>)<br>          &#125;)<br>        &#125;)<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-title function_\">executor</span>(resolve, reject)<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>      <span class=\"hljs-title function_\">reject</span>(err)<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">then</span>(<span class=\"hljs-params\">onfulfilled, onrejected</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      onfulfilled =<br>        onfulfilled ||<br>        (<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">return</span> res<br>        &#125;)<br>      onrejected =<br>        onrejected ||<br>        (<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">throw</span> err<br>        &#125;)<br><br>      <span class=\"hljs-keyword\">switch</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span>) &#123;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_PENDING</span>:<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onfulfilledCallbacks</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onfulfilled, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>, resolve, reject)<br>          &#125;)<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onrejectedCallbacks</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onrejected, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>, resolve, reject)<br>          &#125;)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_FULFILLED</span>:<br>          <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onfulfilled, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>, resolve, reject)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_REJECTED</span>:<br>          <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onrejected, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>, resolve, reject)<br>          <span class=\"hljs-keyword\">break</span><br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">catch</span>(onrejected) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-literal\">undefined</span>, onrejected)<br>  &#125;<br><br>  <span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-params\">onfinally</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">then</span>(onfinally, onfinally)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(value))<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-params\">reason</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-title function_\">reject</span>(reason))<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">all</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> values = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>          values.<span class=\"hljs-title function_\">push</span>(res)<br>          <span class=\"hljs-keyword\">if</span> (values.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(values)<br>        &#125;, reject)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">allSettled</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> result = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(<br>          <span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>            result.<span class=\"hljs-title function_\">push</span>(&#123;<br>              <span class=\"hljs-attr\">status</span>: <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span>,<br>              <span class=\"hljs-attr\">value</span>: res<br>            &#125;)<br>            <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(result)<br>          &#125;,<br>          <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>            result.<span class=\"hljs-title function_\">push</span>(&#123;<br>              <span class=\"hljs-attr\">status</span>: <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span>,<br>              <span class=\"hljs-attr\">reason</span>: err<br>            &#125;)<br>            <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(result)<br>          &#125;<br>        )<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">race</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(resolve, reject)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">any</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> reasons = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(resolve, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>          reasons.<span class=\"hljs-title function_\">push</span>(err)<br>          <span class=\"hljs-keyword\">if</span> (reasons.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) &#123;<br>            <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AggregateError</span>(reasons))<br>          &#125;<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、异步方案：Promise-Generator\"><a href=\"#十三、异步方案：Promise-Generator\" class=\"headerlink\" title=\"十三、异步方案：Promise+Generator\"></a>十三、异步方案：Promise+Generator</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">requestData</span>(<span class=\"hljs-params\">url</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">resolve</span>(url)<br>    &#125;, <span class=\"hljs-number\">2000</span>)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">// 生成器</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> res1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(<span class=\"hljs-string\">&#x27;coder&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res1 + <span class=\"hljs-string\">&#x27;111&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res2 + <span class=\"hljs-string\">&#x27;222&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res3 + <span class=\"hljs-string\">&#x27;333&#x27;</span>)<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res4)<br>&#125;<br><br><span class=\"hljs-comment\">// 自动递归执行生成器</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">co</span>(<span class=\"hljs-params\">genFn</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> generator = <span class=\"hljs-title function_\">genFn</span>()<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">exec</span> = (<span class=\"hljs-params\">res</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> result = generator.<span class=\"hljs-title function_\">next</span>(res)<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> result.<span class=\"hljs-property\">value</span><br>    &#125;<br>    result.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">exec</span>(res)<br>    &#125;)<br>  &#125;<br>  <span class=\"hljs-title function_\">exec</span>()<br>&#125;<br><br><span class=\"hljs-title function_\">co</span>(getData)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十二、手写防抖和节流\"><a href=\"#十二、手写防抖和节流\" class=\"headerlink\" title=\"十二、手写防抖和节流\"></a>十二、手写防抖和节流</h2><h3 id=\"1-防抖\"><a href=\"#1-防抖\" class=\"headerlink\" title=\"1.防抖\"></a>1.防抖</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">fn, delay, immediate = <span class=\"hljs-literal\">false</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span><br>  <span class=\"hljs-keyword\">let</span> isInvoke = <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-keyword\">const</span> _debounce = (...args) &#123;<br>    <span class=\"hljs-keyword\">if</span>(timer) <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>    <span class=\"hljs-keyword\">if</span>(immediate &amp;&amp; !isInvoke) &#123;<br>      fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>      isInvoke = <span class=\"hljs-literal\">true</span><br>    &#125;<br>    timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      timer = <span class=\"hljs-literal\">null</span><br>      isInvoke = <span class=\"hljs-literal\">false</span><br>      fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    &#125;, delay)<br>  &#125;<br><br>  _debounce.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>     <span class=\"hljs-keyword\">if</span>(timer) <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>     timer = <span class=\"hljs-literal\">null</span><br>     isInvoke = <span class=\"hljs-literal\">false</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> _debounce<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-节流\"><a href=\"#2-节流\" class=\"headerlink\" title=\"2.节流\"></a>2.节流</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">fn, interval, options = &#123; leading: <span class=\"hljs-literal\">true</span>, trailing: <span class=\"hljs-literal\">true</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> last = <span class=\"hljs-number\">0</span><br>  timer = <span class=\"hljs-literal\">null</span><br>  <span class=\"hljs-keyword\">const</span> &#123; leading, trailing &#125; = options<br>  <span class=\"hljs-keyword\">const</span> _throttle = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> now = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>    <span class=\"hljs-keyword\">if</span> (!last &amp;&amp; !leading) last = now<br>    <span class=\"hljs-keyword\">const</span> remainTime = interval - (now - last)<br>    <span class=\"hljs-keyword\">if</span> (remainTime &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>      fn.<span class=\"hljs-title function_\">apply</span>(fn, args)<br>      last = now<br>      <span class=\"hljs-keyword\">return</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (trailing) &#123;<br>      <span class=\"hljs-keyword\">if</span> (timer) &#123;<br>        <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>        timer = <span class=\"hljs-literal\">null</span><br>      &#125;<br>      timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        fn.<span class=\"hljs-title function_\">apply</span>(fn, args)<br>        timer = <span class=\"hljs-literal\">null</span><br>        last = !leading ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>      &#125;, remainTime)<br>    &#125;<br>  &#125;<br>  _throttle.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (timer) &#123;<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>      timer = <span class=\"hljs-literal\">null</span><br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> _throttle<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、深拷贝\"><a href=\"#十三、深拷贝\" class=\"headerlink\" title=\"十三、深拷贝\"></a>十三、深拷贝</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isObject</span>(<span class=\"hljs-params\">o</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-keyword\">typeof</span> o<br>  <span class=\"hljs-keyword\">return</span> o !== <span class=\"hljs-literal\">null</span> &amp;&amp; (type === <span class=\"hljs-string\">&#x27;object&#x27;</span> || type === <span class=\"hljs-string\">&#x27;function&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deepClone</span>(<span class=\"hljs-params\">originValue, weakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()</span>) &#123;<br>  <span class=\"hljs-comment\">// 处理数组格式</span><br>  <span class=\"hljs-keyword\">const</span> newObj = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(originValue) ? [] : &#123;&#125;<br>  <span class=\"hljs-comment\">// 处理简单数据类型</span><br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isObject</span>(originValue)) <span class=\"hljs-keyword\">return</span> originValue<br>  <span class=\"hljs-comment\">// 处理函数类型,不需要深拷贝，直接返回</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> originValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>) <span class=\"hljs-keyword\">return</span> originValue<br>  <span class=\"hljs-comment\">// 处理Symbol类型，返回一个相同description的Symbol</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> originValue === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Symbol</span>(originValue.<span class=\"hljs-property\">description</span>)<br>  <span class=\"hljs-comment\">// 处理Set类型</span><br>  <span class=\"hljs-keyword\">if</span> (originValue <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Set</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...originValue])<br>  <span class=\"hljs-comment\">// 处理Map类型</span><br>  <span class=\"hljs-keyword\">if</span> (originValue <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Map</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...originValue])<br><br>  <span class=\"hljs-comment\">// 解决循环引用问题</span><br>  <span class=\"hljs-keyword\">if</span> (weakMap.<span class=\"hljs-title function_\">has</span>(originValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> weakMap.<span class=\"hljs-title function_\">get</span>(originValue)<br>  &#125;<br>  weakMap.<span class=\"hljs-title function_\">set</span>(originValue, newObj)<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> originValue) &#123;<br>    newObj[key] = <span class=\"hljs-title function_\">deepClone</span>(originValue[key], weakMap)<br>  &#125;<br>  <span class=\"hljs-comment\">// 处理Symbol类型作为key</span><br>  <span class=\"hljs-keyword\">const</span> symbolKeys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(originValue)<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> sKey <span class=\"hljs-keyword\">in</span> symbolKeys) &#123;<br>    newObj[sKey] = <span class=\"hljs-title function_\">deepClone</span>(originValue[sKey], weakMap)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、事件总线\"><a href=\"#十四、事件总线\" class=\"headerlink\" title=\"十四、事件总线\"></a>十四、事件总线</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LyEventBus</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span> = &#123;&#125;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">on</span>(<span class=\"hljs-params\">eventName, eventCallBack, thisArg</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) handlers = []<br>    handlers.<span class=\"hljs-title function_\">push</span>(&#123;<br>      eventCallBack,<br>      thisArg<br>    &#125;)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName] = handlers<br>  &#125;<br><br>  <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-params\">eventName, ...payload</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) <span class=\"hljs-keyword\">return</span><br>    handlers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">handler</span>) =&gt;</span> &#123;<br>      handler.<span class=\"hljs-property\">eventCallBack</span>.<span class=\"hljs-title function_\">apply</span>(handler.<span class=\"hljs-property\">thisArg</span>, payload)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-title function_\">off</span>(<span class=\"hljs-params\">eventName, eventCallBack</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-keyword\">const</span> copyHandlers = [...handlers]<br>    copyHandlers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">handler</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (handler.<span class=\"hljs-property\">eventCallBack</span> === eventCallBack) &#123;<br>        <span class=\"hljs-keyword\">const</span> index = handlers.<span class=\"hljs-title function_\">indexOf</span>(handler)<br>        handlers.<span class=\"hljs-title function_\">splice</span>(index, <span class=\"hljs-number\">1</span>)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十五、快速排序\"><a href=\"#十五、快速排序\" class=\"headerlink\" title=\"十五、快速排序\"></a>十五、快速排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">quickSort</span>(<span class=\"hljs-params\">arr, func = (a, b) =&gt; a - b</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (!arr || !arr.<span class=\"hljs-property\">length</span>) <span class=\"hljs-keyword\">return</span> [] <span class=\"hljs-comment\">// 确保传入的是数组</span><br>  <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> arr <span class=\"hljs-comment\">// 跳出递归条件</span><br>  <span class=\"hljs-keyword\">const</span> pivot = arr[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 选取基准元素</span><br>  <span class=\"hljs-comment\">// 小于基准元素的元素集合</span><br>  <span class=\"hljs-keyword\">const</span> smallSet = arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> <span class=\"hljs-title function_\">quickSort</span>(item, pivot) &lt; <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-comment\">// 大于基准元素的元素集合</span><br>  <span class=\"hljs-keyword\">const</span> bigSet = arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> <span class=\"hljs-title function_\">quickSort</span>(item, pivot) &gt; <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">quickSort</span>(smallSet, func).<span class=\"hljs-title function_\">concat</span>([pivot]).<span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-title function_\">quickSort</span>(bigSet, func))<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":15333,"excerpt":"","more":"<h2 id=\"一、深入-javascript-与运行原理\"><a href=\"#一、深入-javascript-与运行原理\" class=\"headerlink\" title=\"一、深入 javascript 与运行原理\"></a>一、深入 javascript 与运行原理</h2><h3 id=\"1-V8-引擎的原理\"><a href=\"#1-V8-引擎的原理\" class=\"headerlink\" title=\"1.V8 引擎的原理\"></a>1.V8 引擎的原理</h3><ul>\n<li><p>V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用户 Chrome 和 nodejs 等</p>\n</li>\n<li><p>它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32， ARM 或 MIPS 处理器的 Linux 系统上运行</p>\n</li>\n<li><p>V8 可以独立运行，也可以嵌入到任何 C ++应用程序中</p>\n</li>\n</ul>\n<h3 id=\"2-V8-引擎的架构\"><a href=\"#2-V8-引擎的架构\" class=\"headerlink\" title=\"2.V8 引擎的架构\"></a>2.V8 引擎的架构</h3><ul>\n<li>parse 模块将 javascript 代码转换成 ast 抽象语法树，这是因为解释器并不直接认识 javascript 代码</li>\n<li>Ignition 是一个解释器，会将 ast 转换成 ByteCode 字节码</li>\n<li>TurboFan 是一个编译器，可以将字节码变异成 CPU 可以直接执行的机器码 <img src=\"./images/1.png\" alt=\"1\"></li>\n</ul>\n<h3 id=\"3-V8-执行的细节\"><a href=\"#3-V8-执行的细节\" class=\"headerlink\" title=\"3.V8 执行的细节\"></a>3.V8 执行的细节</h3><ul>\n<li>Blink 将解析 HTML 文件时，遇到 Javascript 将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换</li>\n<li>Scanner 会进行词法分析，词法分析会将代码转换成 tokens</li>\n<li>接下来 tokens 经过 Parser 和 PreParser 模块转换成 AST 树<ul>\n<li>Parser 就是将 tokens 转成 AST 树结构</li>\n<li>PreParser 称之为预解析，为什么需要预解析呢？<ul>\n<li>这是因为并不是所有的 Javscript 代码，在一开始就会被执行。对所有的 Javascript 代码进行解析，必然会影响网页的运行效率</li>\n<li>所以 V8 引擎就实现了 Lazy Parsing（延迟解析）的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对函数的全量解析就是在函数被调用时才会进行</li>\n<li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生成 AST 树后，会被 Ignition 模块专程字节码（bytecode），之后的过程就是代码的执行过程</li>\n</ul>\n<h3 id=\"4-Javascript-的执行过程\"><a href=\"#4-Javascript-的执行过程\" class=\"headerlink\" title=\"4.Javascript 的执行过程\"></a>4.Javascript 的执行过程</h3><ol>\n<li>初始化全局对象<ul>\n<li>js 引擎在执行代码之前，会在堆内存中创建一个全局对象：Global Object（GO）<ul>\n<li>该对象所有的作用域（scope）都可以访问</li>\n<li>里面会包含 Date、Array、String、Number、setTimeout、setInteval 等等全局属性 AA 己</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>创建执行上下文栈<ul>\n<li>js 引擎内部有一个执行上下文栈（Execution Context Stack， 简称 ECS），它是用于执行代码的调用栈（执行栈）</li>\n<li>那么现在它要执行谁呢？执行的是全局的代码块：<ul>\n<li>全局的代码块为了执行会创建一个全局执行上下文 Global Execution Context（GEC），GEC 中会创建一个 VO 对象（就是 GO 对象）</li>\n<li>GEC 会放到 ECS 中执行</li>\n</ul>\n</li>\n<li>GEC 被放入到 ECS 里面包含两个内容：<ul>\n<li>第一部分：在代码执行前，在 parser 转成 AST 的过程中，会将全局定义的变量、函数等加入到 GlobalObject 中，但是只是声明，不会赋值。这个过程也称作是作用域提升</li>\n<li>第二部分：在代码执行中，对变量赋值，或者执行其他的函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>遇到函数创建函数执行上下文<ul>\n<li>在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（Functional Execution Context， 简称 FEC），并且压入到 EC Stack 中</li>\n<li>FEC 包含三部分内容：<ul>\n<li>第一部分：在解析函数称为 AST 树结构时，会创建一个 Activation Object（AO）<ul>\n<li>AO 中包含形参、arguments、函数定义和指向函数对象、定义的变量</li>\n</ul>\n</li>\n<li>第二部分：作用域链，由 VO（在函数中就是 AO 对象）和父级 VO 组成，查找时会一层层查找（函数的父级作用域 Parent Scope 和函数的定义位置有关系，和调用位置是没有关系的）</li>\n<li>第三部分：this 绑定的值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"二、JS-的内存管理和闭包\"><a href=\"#二、JS-的内存管理和闭包\" class=\"headerlink\" title=\"二、JS 的内存管理和闭包\"></a>二、JS 的内存管理和闭包</h2><h3 id=\"1-认识内存管理\"><a href=\"#1-认识内存管理\" class=\"headerlink\" title=\"1.认识内存管理\"></a>1.认识内存管理</h3><ul>\n<li><p>不管什么样的编程语言，在<strong>代码的执行过程中都是需要给它分配内存</strong>的，不同的是<strong>某些编程语言</strong>需要我们<strong>自己手动</strong></p>\n<p><strong>的管理内存</strong>，<strong>某些编程语言</strong>会可以<strong>自动帮助我们管理内存</strong></p>\n</li>\n<li><p>不管以什么样的方式来管理内存，<strong>内存的管理都会有如下的生命周期</strong>：</p>\n<ul>\n<li>第一步：分配申请你需要的内存（申请）；</li>\n<li>第二步：使用分配的内存（存放一些东西，比如对象等）；</li>\n<li>第三步：不需要使用时，对其进行释放；</li>\n</ul>\n</li>\n<li><p><strong>不同的编程语言对于第一步和第三步会有不同的实现：</strong></p>\n</li>\n<li><p>手动管理内存：比如 C、C++，包括早期的 OC，都是需要手动来管理内存的申请和释放的（malloc 和 free 函数）</p>\n</li>\n<li><p>自动管理内存：比如 Java、JavaScript、Python、Swift、Dart 等，它们有自动帮助我们管理内存；</p>\n</li>\n<li><p>我们可以知道 JavaScript 通常情况下是不需要手动来管理的。</p>\n</li>\n</ul>\n<h3 id=\"2-JS-的内存管理\"><a href=\"#2-JS-的内存管理\" class=\"headerlink\" title=\"2.JS 的内存管理\"></a>2.JS 的内存管理</h3><ul>\n<li>javascript 会在定义变量时分配内存<ul>\n<li>对于基本数据类型，会在栈空间分配内存</li>\n<li>对于复杂数据类型，会在堆空间开辟内存，并将这块空间的指针返回给值变量引用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-JS-的垃圾回收\"><a href=\"#3-JS-的垃圾回收\" class=\"headerlink\" title=\"3.JS 的垃圾回收\"></a>3.JS 的垃圾回收</h3><ul>\n<li>因为<strong>内存的大小是有限</strong>的，所以当<strong>内存不再需要的时候</strong>，我们需要<strong>对其进行释放</strong>，以便腾出<strong>更多的内存空间</strong></li>\n<li>JS 有自己的垃圾回收机制（Garbage Collection，简称 GC）</li>\n<li>对于那些不再使用的对象，我们都称之为是垃圾，它需要被回收，以释放更多的内存空间</li>\n</ul>\n<h3 id=\"4-常见的-GC-算法\"><a href=\"#4-常见的-GC-算法\" class=\"headerlink\" title=\"4.常见的 GC 算法\"></a>4.常见的 GC 算法</h3><ol>\n<li><p>引用计数算法</p>\n<ul>\n<li><p>当一个对象有一个引用指向它时，那么这个对象的引用就+1，当一个对象的引用为 0 时，这个对象就可以被销</p>\n<p>毁掉</p>\n</li>\n<li><p>p 这个算法有一个很大的弊端就是会产生循环引用</p>\n</li>\n</ul>\n</li>\n<li><p>标记清除</p>\n<ul>\n<li><p>这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对</p>\n<p>于哪些没有引用到的对象，就认为是不可用的对象</p>\n</li>\n<li><p>这个算法可以很好的解决循环引用的问题</p>\n</li>\n<li><p>JS 引擎比较广泛的采用的就是标记清除算法，当然类似于 V8 引擎为了进行更好的优化，它在算法的实现细节上也会结合</p>\n<p>一些其他的算法。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"三、JS-中闭包的定义\"><a href=\"#三、JS-中闭包的定义\" class=\"headerlink\" title=\"三、JS 中闭包的定义\"></a>三、JS 中闭包的定义</h2><ul>\n<li><p>这里先来看一下闭包的定义，分成两个：在计算机科学中和在 JavaScript 中。</p>\n</li>\n<li><p>在计算机科学中对闭包的定义（维基百科）：</p>\n<ul>\n<li>闭包（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures）；</li>\n<li>是在支持 <strong>头等函数</strong> 的编程语言中，实现词法绑定的一种技术；</li>\n<li>闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；</li>\n<li>闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 <strong>自由变量</strong> 会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；</li>\n</ul>\n</li>\n<li><p>闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么 JavaScript 中有闭包：</p>\n<ul>\n<li>因为 JavaScript 中有大量的设计是来源于 Scheme 的；</li>\n</ul>\n</li>\n<li><p>我们再来看一下 MDN 对 JavaScript 闭包的解释：</p>\n<ul>\n<li>一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）；</li>\n<li>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；</li>\n<li>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；</li>\n</ul>\n</li>\n<li><p>那么我的理解和总结：</p>\n</li>\n<li><p>一个普通的函数 function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；</p>\n</li>\n<li><p>从广义的角度来说：JavaScript 中的函数都是闭包；</p>\n</li>\n<li><p>从狭义的角度来说：JavaScript 中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；</p>\n</li>\n</ul>\n<h2 id=\"四、JS-中的-this-指向\"><a href=\"#四、JS-中的-this-指向\" class=\"headerlink\" title=\"四、JS 中的 this 指向\"></a>四、JS 中的 this 指向</h2><h3 id=\"1-this-的绑定规律\"><a href=\"#1-this-的绑定规律\" class=\"headerlink\" title=\"1.this 的绑定规律\"></a>1.this 的绑定规律</h3><ol>\n<li>函数在调用时，JavaScript 会默认给 this 绑定一个值；</li>\n<li>this 的绑定和定义的位置（编写的位置）没有关系；</li>\n<li>this 的绑定和调用方式以及调用的位置有关系；</li>\n<li>this 是在运行时被绑定的；</li>\n</ol>\n<h3 id=\"2-this-的绑定规则\"><a href=\"#2-this-的绑定规则\" class=\"headerlink\" title=\"2.this 的绑定规则\"></a>2.this 的绑定规则</h3><ul>\n<li>默认绑定（优先级最低）：独立函数调用</li>\n<li>隐式绑定（优先级大于默认绑定）：obj.fn()</li>\n<li>显示绑定（优先级大于隐式绑定）：apply、call、bind 等</li>\n<li>new 绑定（优先级大于显示绑定）：new Foo()</li>\n</ul>\n<h2 id=\"五、手写-call、apply-和-bind\"><a href=\"#五、手写-call、apply-和-bind\" class=\"headerlink\" title=\"五、手写 call、apply 和 bind\"></a>五、手写 call、apply 和 bind</h2><h3 id=\"1-call-函数的实现\"><a href=\"#1-call-函数的实现\" class=\"headerlink\" title=\"1.call 函数的实现\"></a>1.call 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyCall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...args</span>) &#123;<br>  <span class=\"hljs-comment\">// 1.处理thisArg</span><br>  thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>  <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>  <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>  thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">const</span> result = thisArg[key](...args)<br>  <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>  <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-apply-函数的实现\"><a href=\"#2-apply-函数的实现\" class=\"headerlink\" title=\"2.apply 函数的实现\"></a>2.apply 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyApply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, argArray</span>) &#123;<br>  <span class=\"hljs-comment\">// 1.处理thisArg</span><br>  thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>  <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>  <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>  thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>  argArray = argArray || []<br>  <span class=\"hljs-keyword\">const</span> result = thisArg[key](...argArray)<br>  <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>  <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-bind-函数的实现\"><a href=\"#3-bind-函数的实现\" class=\"headerlink\" title=\"3.bind 函数的实现\"></a>3.bind 函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">lyBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">thisArg, ...args</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...bindArgs</span>) &#123;<br>    <span class=\"hljs-comment\">// 1.处理thisArg</span><br>    thisArg = thisArg !== <span class=\"hljs-literal\">undefined</span> &amp;&amp; thisArg !== <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-title class_\">Object</span>(thisArg) : <span class=\"hljs-variable language_\">window</span><br>    <span class=\"hljs-comment\">// 2.隐式绑定，调用需要修改this指向的函数</span><br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">Symbol</span>()<br>    thisArg[key] = <span class=\"hljs-variable language_\">this</span><br>    <span class=\"hljs-keyword\">const</span> result = thisArg[key]([...args, ...bindArgs])<br>    <span class=\"hljs-keyword\">delete</span> thisArg[key]<br>    <span class=\"hljs-comment\">// 3.返回函数执行结果</span><br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、函数科里化\"><a href=\"#六、函数科里化\" class=\"headerlink\" title=\"六、函数科里化\"></a>六、函数科里化</h2><h3 id=\"1-函数科里化的概念\"><a href=\"#1-函数科里化的概念\" class=\"headerlink\" title=\"1.函数科里化的概念\"></a>1.函数科里化的概念</h3><p>一个接收多个参数的函数，变成一个可以只接收部分参数，并且返回一个接收剩余参数的函数的函数。这个过程就叫科里化</p>\n<h3 id=\"2-函数科里化的实现\"><a href=\"#2-函数科里化的实现\" class=\"headerlink\" title=\"2.函数科里化的实现\"></a>2.函数科里化的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curring</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> curriedFn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> &gt;= fn.<span class=\"hljs-property\">length</span>) &#123;<br>      <span class=\"hljs-comment\">// 本次函数调用传入的参数个数已经达到需要执行函数的最大参数长度，直接执行该函数</span><br>      <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 本次函数调用传入的参数个数没有达到需要执行函数的最大参数长度，返回一个接收剩余参数的函数</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...restArgs</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> curriedFn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, [...args, ...restArgs])<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> curriedFn<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、组合函数\"><a href=\"#七、组合函数\" class=\"headerlink\" title=\"七、组合函数\"></a>七、组合函数</h2><h3 id=\"1-组合函数的概念\"><a href=\"#1-组合函数的概念\" class=\"headerlink\" title=\"1.组合函数的概念\"></a>1.组合函数的概念</h3><p>将多个需要执行的函数，组合到一个函数里面，函数内部会自动依次调用。这个过程就是对函数的组合，这个函数就称为组合函数</p>\n<h3 id=\"2-通用组合函数的实现\"><a href=\"#2-通用组合函数的实现\" class=\"headerlink\" title=\"2.通用组合函数的实现\"></a>2.通用组合函数的实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...fns</span>) &#123;<br>  fns.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">fn</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> fn !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Expected arguments are function!&#x27;</span>)<br>    &#125;<br>  &#125;)<br>  <span class=\"hljs-keyword\">const</span> list = fns.<span class=\"hljs-title function_\">slice</span>()<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> result = list.<span class=\"hljs-title function_\">shift</span>().<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    <span class=\"hljs-keyword\">while</span> (list.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      result = list.<span class=\"hljs-title function_\">shift</span>().<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, result)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、寄生组合式继承（最终方案）\"><a href=\"#八、寄生组合式继承（最终方案）\" class=\"headerlink\" title=\"八、寄生组合式继承（最终方案）\"></a>八、寄生组合式继承（最终方案）</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 寄生式继承-对象</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createObject</span>(<span class=\"hljs-params\">o</span>) &#123;<br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>  <span class=\"hljs-title class_\">Fn</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = o<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fn</span>()<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-params\">subType, superType</span>) &#123;<br>  <span class=\"hljs-comment\">// subType.prototype = Object.create(superType.prototype) // 子类显式原型指向新创建的对象，新对象__proto__指向父类显示原型</span><br>  subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title function_\">createObject</span>(superType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)<br>  <span class=\"hljs-comment\">// 子类显示原型的构造函数指向自己</span><br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(subType.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-string\">&#x27;constuctor&#x27;</span>, &#123;<br>    <span class=\"hljs-attr\">configurable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span>,<br>    <span class=\"hljs-attr\">writable</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">value</span>: subType<br>  &#125;)<br>&#125;<br><span class=\"hljs-comment\">// 父类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>&#125;<br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eating</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;eating&#x27;</span>)<br>&#125;<br><span class=\"hljs-comment\">// 子类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Student</span>(<span class=\"hljs-params\">sno</span>) &#123;<br>  <span class=\"hljs-comment\">// 继承父类属性</span><br>  <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>, name)<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sno</span> = sno<br>&#125;<br><span class=\"hljs-comment\">// 继承父类方法</span><br><span class=\"hljs-title function_\">inheritPrototype</span>(<span class=\"hljs-title class_\">Student</span>, <span class=\"hljs-title class_\">Person</span>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、手写-instanceof\"><a href=\"#九、手写-instanceof\" class=\"headerlink\" title=\"九、手写 instanceof\"></a>九、手写 instanceof</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_instanceof</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">while</span> (a.<span class=\"hljs-property\">__proto__</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (a.<span class=\"hljs-property\">__proto__</span> === b.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    a = a.<span class=\"hljs-property\">__proto__</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十、手写-new-操作符\"><a href=\"#十、手写-new-操作符\" class=\"headerlink\" title=\"十、手写 new 操作符\"></a>十、手写 new 操作符</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_new</span>(<span class=\"hljs-params\">constructor, ...args</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> instance = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(constructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)<br>  <span class=\"hljs-keyword\">const</span> res = constuctor.<span class=\"hljs-title function_\">apply</span>(instance, args)<br>  <span class=\"hljs-comment\">// 构造函数有明确的返回值且返回值是Object时，直接返回构造函数的返回结果</span><br>  <span class=\"hljs-keyword\">return</span> res <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span> ? res : instance<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十一、响应式原理实现\"><a href=\"#十一、响应式原理实现\" class=\"headerlink\" title=\"十一、响应式原理实现\"></a>十一、响应式原理实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Dep类存储响应式函数（副作用）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dep</span> &#123;<br>  subscribers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()<br>  <span class=\"hljs-title function_\">addEffect</span>(<span class=\"hljs-params\"></span>) &#123;<br>    activeEffect &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subscribers</span>.<span class=\"hljs-title function_\">add</span>(activeEffect)<br>  &#125;<br>  <span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">subscribers</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">effect</span>) =&gt;</span> <span class=\"hljs-title function_\">effect</span>())<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 当前需要收集的响应式函数（副作用）</span><br><span class=\"hljs-keyword\">let</span> activeEffect = <span class=\"hljs-literal\">null</span><br><span class=\"hljs-comment\">// 第一次执行响应式函数（副作用），并触发对应的追踪收集操作</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">watchEffect</span> = (<span class=\"hljs-params\">fn</span>) =&gt; &#123;<br>  activeEffect = fn<br>  <span class=\"hljs-title function_\">fn</span>()<br>  activeEffect = <span class=\"hljs-literal\">null</span><br>&#125;<br><br><span class=\"hljs-comment\">// WeakMap: &#123; obj -&gt; Map &#125;  Map: &#123; obj属性 -&gt; dep对象(存储响应式函数,并提供触发方法) &#125;</span><br><span class=\"hljs-keyword\">const</span> weakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WeakMap</span>()<br><span class=\"hljs-comment\">// 收集响应式函数（副作用）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">track</span> = (<span class=\"hljs-params\">target, key</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">let</span> targetMap = weakMap.<span class=\"hljs-title function_\">get</span>(target)<br>  <span class=\"hljs-keyword\">if</span> (!targetMap) &#123;<br>    targetMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>()<br>    weakMap.<span class=\"hljs-title function_\">set</span>(target, targetMap)<br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> dep = targetMap.<span class=\"hljs-title function_\">get</span>(key)<br>  <span class=\"hljs-keyword\">if</span> (!dep) &#123;<br>    dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dep</span>()<br>    targetMap.<span class=\"hljs-title function_\">set</span>(key, dep)<br>  &#125;<br>  dep.<span class=\"hljs-title function_\">addEffect</span>()<br>&#125;<br><span class=\"hljs-comment\">// 触发响应式函数（副作用）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">trigger</span> = (<span class=\"hljs-params\">target, key</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> targetMap = weakMap.<span class=\"hljs-title function_\">get</span>(target)<br>  <span class=\"hljs-keyword\">if</span> (!targetMap) <span class=\"hljs-keyword\">return</span><br>  <span class=\"hljs-keyword\">const</span> dep = targetMap.<span class=\"hljs-title function_\">get</span>(key)<br>  dep?.<span class=\"hljs-title function_\">notify</span>()<br>&#125;<br><br><span class=\"hljs-comment\">// 创建代理对象</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reactive</span> = (<span class=\"hljs-params\">o</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(o, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">target, key, receiver</span>) &#123;<br>      <span class=\"hljs-title function_\">track</span>(target, key)<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">get</span>(target, key, receiver)<br>    &#125;,<br>    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, newValue, receiver</span>) &#123;<br>      <span class=\"hljs-title function_\">trigger</span>(target, key)<br>      <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, newValue, receiver)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十二、手写简易版-promise-实现\"><a href=\"#十二、手写简易版-promise-实现\" class=\"headerlink\" title=\"十二、手写简易版 promise 实现\"></a>十二、手写简易版 promise 实现</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span> = <span class=\"hljs-string\">&#x27;pending&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span> = <span class=\"hljs-string\">&#x27;fulfilled&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span> = <span class=\"hljs-string\">&#x27;rejected&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">execCallbackWithCatchErr</span> = (<span class=\"hljs-params\">execFn, value, resolve, reject</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">execFn</span>(value)<br>    <span class=\"hljs-title function_\">resolve</span>(result)<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-title function_\">reject</span>(err)<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LyPromise</span> &#123;<br>  status = <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span><br>  value = <span class=\"hljs-literal\">undefined</span><br>  reason = <span class=\"hljs-literal\">undefined</span><br>  onfulfilledCallbacks = []<br>  onrejectedCallbacks = []<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">executor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">resolve</span> = (<span class=\"hljs-params\">value</span>) =&gt; &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> === <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;<br>        <span class=\"hljs-title function_\">queueMicrotask</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> !== <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) <span class=\"hljs-keyword\">return</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> = <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onfulfilledCallbacks</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">callback</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>)<br>          &#125;)<br>        &#125;)<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reject</span> = (<span class=\"hljs-params\">reason</span>) =&gt; &#123;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> === <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) &#123;<br>        <span class=\"hljs-title function_\">queueMicrotask</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> !== <span class=\"hljs-variable constant_\">PROMISE_STATUS_PENDING</span>) <span class=\"hljs-keyword\">return</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span> = <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span><br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span> = reason<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onrejectedCallbacks</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">callback</span>) =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">callback</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>)<br>          &#125;)<br>        &#125;)<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-title function_\">executor</span>(resolve, reject)<br>    &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>      <span class=\"hljs-title function_\">reject</span>(err)<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">then</span>(<span class=\"hljs-params\">onfulfilled, onrejected</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      onfulfilled =<br>        onfulfilled ||<br>        (<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">return</span> res<br>        &#125;)<br>      onrejected =<br>        onrejected ||<br>        (<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">throw</span> err<br>        &#125;)<br><br>      <span class=\"hljs-keyword\">switch</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">status</span>) &#123;<br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_PENDING</span>:<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onfulfilledCallbacks</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onfulfilled, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>, resolve, reject)<br>          &#125;)<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">onrejectedCallbacks</span>.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onrejected, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>, resolve, reject)<br>          &#125;)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_FULFILLED</span>:<br>          <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onfulfilled, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>, resolve, reject)<br>          <span class=\"hljs-keyword\">break</span><br>        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-attr\">PROMISE_STATUS_REJECTED</span>:<br>          <span class=\"hljs-title function_\">execCallbackWithCatchErr</span>(onrejected, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reason</span>, resolve, reject)<br>          <span class=\"hljs-keyword\">break</span><br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">catch</span>(onrejected) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-literal\">undefined</span>, onrejected)<br>  &#125;<br><br>  <span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-params\">onfinally</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">then</span>(onfinally, onfinally)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(value))<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-params\">reason</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-title function_\">reject</span>(reason))<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">all</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> values = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>          values.<span class=\"hljs-title function_\">push</span>(res)<br>          <span class=\"hljs-keyword\">if</span> (values.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(values)<br>        &#125;, reject)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">allSettled</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> result = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(<br>          <span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>            result.<span class=\"hljs-title function_\">push</span>(&#123;<br>              <span class=\"hljs-attr\">status</span>: <span class=\"hljs-variable constant_\">PROMISE_STATUS_FULFILLED</span>,<br>              <span class=\"hljs-attr\">value</span>: res<br>            &#125;)<br>            <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(result)<br>          &#125;,<br>          <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>            result.<span class=\"hljs-title function_\">push</span>(&#123;<br>              <span class=\"hljs-attr\">status</span>: <span class=\"hljs-variable constant_\">PROMISE_STATUS_REJECTED</span>,<br>              <span class=\"hljs-attr\">reason</span>: err<br>            &#125;)<br>            <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) <span class=\"hljs-title function_\">resolve</span>(result)<br>          &#125;<br>        )<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">race</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(resolve, reject)<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title function_\">any</span>(<span class=\"hljs-params\">promises</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LyPromise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">let</span> reasons = []<br>      promises.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">promise</span>) =&gt;</span> &#123;<br>        promise.<span class=\"hljs-title function_\">then</span>(resolve, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>          reasons.<span class=\"hljs-title function_\">push</span>(err)<br>          <span class=\"hljs-keyword\">if</span> (reasons.<span class=\"hljs-property\">length</span> === promises.<span class=\"hljs-property\">length</span>) &#123;<br>            <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AggregateError</span>(reasons))<br>          &#125;<br>        &#125;)<br>      &#125;)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、异步方案：Promise-Generator\"><a href=\"#十三、异步方案：Promise-Generator\" class=\"headerlink\" title=\"十三、异步方案：Promise+Generator\"></a>十三、异步方案：Promise+Generator</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">requestData</span>(<span class=\"hljs-params\">url</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">resolve</span>(url)<br>    &#125;, <span class=\"hljs-number\">2000</span>)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-comment\">// 生成器</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">getData</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> res1 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(<span class=\"hljs-string\">&#x27;coder&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res2 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res1 + <span class=\"hljs-string\">&#x27;111&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res3 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res2 + <span class=\"hljs-string\">&#x27;222&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> res4 = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">requestData</span>(res3 + <span class=\"hljs-string\">&#x27;333&#x27;</span>)<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res4)<br>&#125;<br><br><span class=\"hljs-comment\">// 自动递归执行生成器</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">co</span>(<span class=\"hljs-params\">genFn</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> generator = <span class=\"hljs-title function_\">genFn</span>()<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">exec</span> = (<span class=\"hljs-params\">res</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> result = generator.<span class=\"hljs-title function_\">next</span>(res)<br>    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">done</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> result.<span class=\"hljs-property\">value</span><br>    &#125;<br>    result.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">exec</span>(res)<br>    &#125;)<br>  &#125;<br>  <span class=\"hljs-title function_\">exec</span>()<br>&#125;<br><br><span class=\"hljs-title function_\">co</span>(getData)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十二、手写防抖和节流\"><a href=\"#十二、手写防抖和节流\" class=\"headerlink\" title=\"十二、手写防抖和节流\"></a>十二、手写防抖和节流</h2><h3 id=\"1-防抖\"><a href=\"#1-防抖\" class=\"headerlink\" title=\"1.防抖\"></a>1.防抖</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">fn, delay, immediate = <span class=\"hljs-literal\">false</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span><br>  <span class=\"hljs-keyword\">let</span> isInvoke = <span class=\"hljs-literal\">false</span><br>  <span class=\"hljs-keyword\">const</span> _debounce = (...args) &#123;<br>    <span class=\"hljs-keyword\">if</span>(timer) <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>    <span class=\"hljs-keyword\">if</span>(immediate &amp;&amp; !isInvoke) &#123;<br>      fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>      isInvoke = <span class=\"hljs-literal\">true</span><br>    &#125;<br>    timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      timer = <span class=\"hljs-literal\">null</span><br>      isInvoke = <span class=\"hljs-literal\">false</span><br>      fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    &#125;, delay)<br>  &#125;<br><br>  _debounce.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>     <span class=\"hljs-keyword\">if</span>(timer) <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>     timer = <span class=\"hljs-literal\">null</span><br>     isInvoke = <span class=\"hljs-literal\">false</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> _debounce<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-节流\"><a href=\"#2-节流\" class=\"headerlink\" title=\"2.节流\"></a>2.节流</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">fn, interval, options = &#123; leading: <span class=\"hljs-literal\">true</span>, trailing: <span class=\"hljs-literal\">true</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> last = <span class=\"hljs-number\">0</span><br>  timer = <span class=\"hljs-literal\">null</span><br>  <span class=\"hljs-keyword\">const</span> &#123; leading, trailing &#125; = options<br>  <span class=\"hljs-keyword\">const</span> _throttle = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> now = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>    <span class=\"hljs-keyword\">if</span> (!last &amp;&amp; !leading) last = now<br>    <span class=\"hljs-keyword\">const</span> remainTime = interval - (now - last)<br>    <span class=\"hljs-keyword\">if</span> (remainTime &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>      fn.<span class=\"hljs-title function_\">apply</span>(fn, args)<br>      last = now<br>      <span class=\"hljs-keyword\">return</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (trailing) &#123;<br>      <span class=\"hljs-keyword\">if</span> (timer) &#123;<br>        <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>        timer = <span class=\"hljs-literal\">null</span><br>      &#125;<br>      timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        fn.<span class=\"hljs-title function_\">apply</span>(fn, args)<br>        timer = <span class=\"hljs-literal\">null</span><br>        last = !leading ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>      &#125;, remainTime)<br>    &#125;<br>  &#125;<br>  _throttle.<span class=\"hljs-property\">cancel</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (timer) &#123;<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer)<br>      timer = <span class=\"hljs-literal\">null</span><br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> _throttle<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、深拷贝\"><a href=\"#十三、深拷贝\" class=\"headerlink\" title=\"十三、深拷贝\"></a>十三、深拷贝</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isObject</span>(<span class=\"hljs-params\">o</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-keyword\">typeof</span> o<br>  <span class=\"hljs-keyword\">return</span> o !== <span class=\"hljs-literal\">null</span> &amp;&amp; (type === <span class=\"hljs-string\">&#x27;object&#x27;</span> || type === <span class=\"hljs-string\">&#x27;function&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">deepClone</span>(<span class=\"hljs-params\">originValue, weakMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>()</span>) &#123;<br>  <span class=\"hljs-comment\">// 处理数组格式</span><br>  <span class=\"hljs-keyword\">const</span> newObj = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArray</span>(originValue) ? [] : &#123;&#125;<br>  <span class=\"hljs-comment\">// 处理简单数据类型</span><br>  <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-title function_\">isObject</span>(originValue)) <span class=\"hljs-keyword\">return</span> originValue<br>  <span class=\"hljs-comment\">// 处理函数类型,不需要深拷贝，直接返回</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> originValue === <span class=\"hljs-string\">&#x27;function&#x27;</span>) <span class=\"hljs-keyword\">return</span> originValue<br>  <span class=\"hljs-comment\">// 处理Symbol类型，返回一个相同description的Symbol</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> originValue === <span class=\"hljs-string\">&#x27;symbol&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Symbol</span>(originValue.<span class=\"hljs-property\">description</span>)<br>  <span class=\"hljs-comment\">// 处理Set类型</span><br>  <span class=\"hljs-keyword\">if</span> (originValue <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Set</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...originValue])<br>  <span class=\"hljs-comment\">// 处理Map类型</span><br>  <span class=\"hljs-keyword\">if</span> (originValue <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Map</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...originValue])<br><br>  <span class=\"hljs-comment\">// 解决循环引用问题</span><br>  <span class=\"hljs-keyword\">if</span> (weakMap.<span class=\"hljs-title function_\">has</span>(originValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> weakMap.<span class=\"hljs-title function_\">get</span>(originValue)<br>  &#125;<br>  weakMap.<span class=\"hljs-title function_\">set</span>(originValue, newObj)<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> originValue) &#123;<br>    newObj[key] = <span class=\"hljs-title function_\">deepClone</span>(originValue[key], weakMap)<br>  &#125;<br>  <span class=\"hljs-comment\">// 处理Symbol类型作为key</span><br>  <span class=\"hljs-keyword\">const</span> symbolKeys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(originValue)<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> sKey <span class=\"hljs-keyword\">in</span> symbolKeys) &#123;<br>    newObj[sKey] = <span class=\"hljs-title function_\">deepClone</span>(originValue[sKey], weakMap)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> newObj<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、事件总线\"><a href=\"#十四、事件总线\" class=\"headerlink\" title=\"十四、事件总线\"></a>十四、事件总线</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LyEventBus</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span> = &#123;&#125;<br>  &#125;<br><br>  <span class=\"hljs-title function_\">on</span>(<span class=\"hljs-params\">eventName, eventCallBack, thisArg</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) handlers = []<br>    handlers.<span class=\"hljs-title function_\">push</span>(&#123;<br>      eventCallBack,<br>      thisArg<br>    &#125;)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName] = handlers<br>  &#125;<br><br>  <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-params\">eventName, ...payload</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) <span class=\"hljs-keyword\">return</span><br>    handlers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">handler</span>) =&gt;</span> &#123;<br>      handler.<span class=\"hljs-property\">eventCallBack</span>.<span class=\"hljs-title function_\">apply</span>(handler.<span class=\"hljs-property\">thisArg</span>, payload)<br>    &#125;)<br>  &#125;<br><br>  <span class=\"hljs-title function_\">off</span>(<span class=\"hljs-params\">eventName, eventCallBack</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> handlers = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">eventBus</span>[eventName]<br>    <span class=\"hljs-keyword\">if</span> (!handlers) <span class=\"hljs-keyword\">return</span><br>    <span class=\"hljs-keyword\">const</span> copyHandlers = [...handlers]<br>    copyHandlers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">handler</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (handler.<span class=\"hljs-property\">eventCallBack</span> === eventCallBack) &#123;<br>        <span class=\"hljs-keyword\">const</span> index = handlers.<span class=\"hljs-title function_\">indexOf</span>(handler)<br>        handlers.<span class=\"hljs-title function_\">splice</span>(index, <span class=\"hljs-number\">1</span>)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十五、快速排序\"><a href=\"#十五、快速排序\" class=\"headerlink\" title=\"十五、快速排序\"></a>十五、快速排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">quickSort</span>(<span class=\"hljs-params\">arr, func = (a, b) =&gt; a - b</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (!arr || !arr.<span class=\"hljs-property\">length</span>) <span class=\"hljs-keyword\">return</span> [] <span class=\"hljs-comment\">// 确保传入的是数组</span><br>  <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> arr <span class=\"hljs-comment\">// 跳出递归条件</span><br>  <span class=\"hljs-keyword\">const</span> pivot = arr[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 选取基准元素</span><br>  <span class=\"hljs-comment\">// 小于基准元素的元素集合</span><br>  <span class=\"hljs-keyword\">const</span> smallSet = arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> <span class=\"hljs-title function_\">quickSort</span>(item, pivot) &lt; <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-comment\">// 大于基准元素的元素集合</span><br>  <span class=\"hljs-keyword\">const</span> bigSet = arr.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span> <span class=\"hljs-title function_\">quickSort</span>(item, pivot) &gt; <span class=\"hljs-number\">0</span>)<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">quickSort</span>(smallSet, func).<span class=\"hljs-title function_\">concat</span>([pivot]).<span class=\"hljs-title function_\">concat</span>(<span class=\"hljs-title function_\">quickSort</span>(bigSet, func))<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"搭建jenkins服务器环境","keywords":"jenkins","_content":"\n## 一. 购买云服务器\n\n这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买\n\n## 二. 搭建服务器环境\n\n### 2.1. jenkins自动化部署\n\n#### 2.1.1. 安装Java环境\n\nJenkins本身是依赖Java的，所以我们需要先安装Java环境：\n\n* 这里我安装了Java1.8的环境\n\n```shell\ndnf search java-1.8\ndnf install java-1.8.0-openjdk.x86_64\n```\n\n\n\n#### 2.1.2. 安装Jenkins\n\n因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：\n\n* wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；\n* rpm：全称为**The RPM Package Manage**，是Linux下一个软件包管理器；\n\n```shell\nwget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo\n\n# 导入GPG密钥以确保您的软件合法\nrpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n# 或者\nrpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n```\n\n编辑一下文件/etc/yum.repos.d/jenkins.repo\n\n* 可以通过vim编辑\n\n```\n[jenkins]\n\nname=Jenkins-stable\n\nbaseurl=http://pkg.jenkins.io/redhat\n\ngpgcheck=1\n```\n\n安装Jenkins\n\n```shell\ndnf install jenkins # --nogpgcheck(可以不加)\n```\n\n启动Jenkins的服务：\n\n```shell\nsystemctl start jenkins\nsystemctl status jenkins\nsystemctl enable jenkins\n```\n\nJenkins默认使用8080端口提供服务，所以需要加入到安全组中：\n\n![image-20201204173117359](https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg)\n\n\n\n\n\n#### 2.1.3. Jenkins用户\n\n我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 `jenkins`，可能会没有访问权限，所以我们需要修改一下它的用户：\n\n修改文件的路径：`/etc/sysconfig/jenkins`\n\n![image-20210825162827962](https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg)\n\n之后需要重启一下Jenkins：\n\n```shell\nsystemctl restart jenkins\n```\n\n\n\n#### 2.1.4. Jenkins配置\n\n打开浏览器，输入：http://8.134.60.235:8080/\n\n* 注意：你输入自己的IP地址\n\n获取输入管理员密码：\n\n* 在下面的地址中 `cat /var/lib/jenkins/secrets/initialAdminPassword`\n\n![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)\n\n可以安装推荐的插件：\n\n![安装推荐的插件](https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg)\n\n\n\n#### 2.1.5. Jenkins任务\n\n**新建任务：**\n\n![新建任务](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg)\n\n![image-20201204185613061](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg)\n\n**配置项目和保留策略：**\n\n![image-20210825160744119](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg)\n\n**源码管理：**\n\n![image-20210825160818122](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg)\n\n**构建触发器：**\n\n这里的触发器规则是这样的：\n\n* 定时字符串从左往右分别是：分 时 日 月 周\n\n```js\n#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建\nH/30 * * * *\n\n#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建\nH H/2 * * *\n\n#每天凌晨两点定时构建\nH 2 * * *\n\n#每月15号执行构建\nH H 15 * *\n\n#工作日，上午9点整执行\nH 9 * * 1-5\n\n#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次\nH/30 8-20/4 * * 1,3,5\n```\n\n\n\n![触发器](https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg)\n\n**构建环境：**\n\n注意：我们需要搭建Node的环境\n\n* 第一步：配置Node的环境；\n* 第二步：安装Node的插件；\n\n![image-20201204190055096](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg)\n\n第一步：配置Node的环境\n\n![node环境](https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg)\n\n第二步：安装Node的插件\n\n* 这里因为我已经安装过了，所以没有搜索到；\n\n![image-20201204185949452](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg)\n\n\n\n构建执行的任务：\n\n* 查看Node的版本等是否有问题；\n* 执行 `npm install` 安装项目的依赖；\n* 移除原来mall_cms文件的所有内容；\n* 将打包的dist文件夹内容移动到mall_cms文件夹；\n\n```shell\npwd\nnode -v\nnpm -v\n\nnpm install \nnpm run build\n\npwd\n\necho '构建成功'\n\nls\n\n# 删除/root/mall_cms文件夹里所有的内容\nrm -rf /root/mall_cms/* \n\ncp -rf ./dist/* /root/mall_cms/\n```\n\n\n\n![执行构建任务](https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg)\n\n\n\n### 2.2. nginx安装和配置\n\n#### 2.2.1. 安装nginx\n\n后续我们部署会使用nginx，所以需要先安装一下nginx：\n\n```shell\ndnf install nginx\n```\n\n启动nginx：\n\n```shell\nsystemctl start nginx\nsystemctl status nginx\nsystemctl enable nginx\n```\n\n\n\n#### 2.2.2. 配置nginx\n\n我们这里主要配置nginx的用户和默认访问目录：\n\n配置用户：\n\n![image-20210825163329209](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg)\n\n\n\n通过Linux命令创建文件夹和文件：\n\n```shell\nmkdir /root/mall_cms\ncd /root/mall_cms\ntouch index.html\n\nvi index.html\n```\n\n\n\n配置访问目录：\n\n![image-20210825163406566](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg)\n\n\n\n","source":"_posts/搭建jenkins.md","raw":"---\ntitle:  搭建jenkins服务器环境\ntag: jenkins\nkeywords: jenkins\ncategories: 自动化部署\n---\n\n## 一. 购买云服务器\n\n这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买\n\n## 二. 搭建服务器环境\n\n### 2.1. jenkins自动化部署\n\n#### 2.1.1. 安装Java环境\n\nJenkins本身是依赖Java的，所以我们需要先安装Java环境：\n\n* 这里我安装了Java1.8的环境\n\n```shell\ndnf search java-1.8\ndnf install java-1.8.0-openjdk.x86_64\n```\n\n\n\n#### 2.1.2. 安装Jenkins\n\n因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：\n\n* wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；\n* rpm：全称为**The RPM Package Manage**，是Linux下一个软件包管理器；\n\n```shell\nwget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo\n\n# 导入GPG密钥以确保您的软件合法\nrpm --import https://pkg.jenkins.io/redhat/jenkins.io.key\n# 或者\nrpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key\n```\n\n编辑一下文件/etc/yum.repos.d/jenkins.repo\n\n* 可以通过vim编辑\n\n```\n[jenkins]\n\nname=Jenkins-stable\n\nbaseurl=http://pkg.jenkins.io/redhat\n\ngpgcheck=1\n```\n\n安装Jenkins\n\n```shell\ndnf install jenkins # --nogpgcheck(可以不加)\n```\n\n启动Jenkins的服务：\n\n```shell\nsystemctl start jenkins\nsystemctl status jenkins\nsystemctl enable jenkins\n```\n\nJenkins默认使用8080端口提供服务，所以需要加入到安全组中：\n\n![image-20201204173117359](https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg)\n\n\n\n\n\n#### 2.1.3. Jenkins用户\n\n我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 `jenkins`，可能会没有访问权限，所以我们需要修改一下它的用户：\n\n修改文件的路径：`/etc/sysconfig/jenkins`\n\n![image-20210825162827962](https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg)\n\n之后需要重启一下Jenkins：\n\n```shell\nsystemctl restart jenkins\n```\n\n\n\n#### 2.1.4. Jenkins配置\n\n打开浏览器，输入：http://8.134.60.235:8080/\n\n* 注意：你输入自己的IP地址\n\n获取输入管理员密码：\n\n* 在下面的地址中 `cat /var/lib/jenkins/secrets/initialAdminPassword`\n\n![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)\n\n可以安装推荐的插件：\n\n![安装推荐的插件](https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg)\n\n\n\n#### 2.1.5. Jenkins任务\n\n**新建任务：**\n\n![新建任务](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg)\n\n![image-20201204185613061](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg)\n\n**配置项目和保留策略：**\n\n![image-20210825160744119](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg)\n\n**源码管理：**\n\n![image-20210825160818122](https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg)\n\n**构建触发器：**\n\n这里的触发器规则是这样的：\n\n* 定时字符串从左往右分别是：分 时 日 月 周\n\n```js\n#每半小时构建一次OR每半小时检查一次远程代码分支，有更新则构建\nH/30 * * * *\n\n#每两小时构建一次OR每两小时检查一次远程代码分支，有更新则构建\nH H/2 * * *\n\n#每天凌晨两点定时构建\nH 2 * * *\n\n#每月15号执行构建\nH H 15 * *\n\n#工作日，上午9点整执行\nH 9 * * 1-5\n\n#每周1,3,5，从8:30开始，截止19:30，每4小时30分构建一次\nH/30 8-20/4 * * 1,3,5\n```\n\n\n\n![触发器](https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg)\n\n**构建环境：**\n\n注意：我们需要搭建Node的环境\n\n* 第一步：配置Node的环境；\n* 第二步：安装Node的插件；\n\n![image-20201204190055096](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg)\n\n第一步：配置Node的环境\n\n![node环境](https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg)\n\n第二步：安装Node的插件\n\n* 这里因为我已经安装过了，所以没有搜索到；\n\n![image-20201204185949452](https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg)\n\n\n\n构建执行的任务：\n\n* 查看Node的版本等是否有问题；\n* 执行 `npm install` 安装项目的依赖；\n* 移除原来mall_cms文件的所有内容；\n* 将打包的dist文件夹内容移动到mall_cms文件夹；\n\n```shell\npwd\nnode -v\nnpm -v\n\nnpm install \nnpm run build\n\npwd\n\necho '构建成功'\n\nls\n\n# 删除/root/mall_cms文件夹里所有的内容\nrm -rf /root/mall_cms/* \n\ncp -rf ./dist/* /root/mall_cms/\n```\n\n\n\n![执行构建任务](https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg)\n\n\n\n### 2.2. nginx安装和配置\n\n#### 2.2.1. 安装nginx\n\n后续我们部署会使用nginx，所以需要先安装一下nginx：\n\n```shell\ndnf install nginx\n```\n\n启动nginx：\n\n```shell\nsystemctl start nginx\nsystemctl status nginx\nsystemctl enable nginx\n```\n\n\n\n#### 2.2.2. 配置nginx\n\n我们这里主要配置nginx的用户和默认访问目录：\n\n配置用户：\n\n![image-20210825163329209](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg)\n\n\n\n通过Linux命令创建文件夹和文件：\n\n```shell\nmkdir /root/mall_cms\ncd /root/mall_cms\ntouch index.html\n\nvi index.html\n```\n\n\n\n配置访问目录：\n\n![image-20210825163406566](https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg)\n\n\n\n","slug":"搭建jenkins","published":1,"date":"2022-02-10T07:11:10.000Z","updated":"2022-02-10T07:21:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9kx000ji024c0vsdswz","content":"<h2 id=\"一-购买云服务器\"><a href=\"#一-购买云服务器\" class=\"headerlink\" title=\"一. 购买云服务器\"></a>一. 购买云服务器</h2><p>这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买</p>\n<h2 id=\"二-搭建服务器环境\"><a href=\"#二-搭建服务器环境\" class=\"headerlink\" title=\"二. 搭建服务器环境\"></a>二. 搭建服务器环境</h2><h3 id=\"2-1-jenkins自动化部署\"><a href=\"#2-1-jenkins自动化部署\" class=\"headerlink\" title=\"2.1. jenkins自动化部署\"></a>2.1. jenkins自动化部署</h3><h4 id=\"2-1-1-安装Java环境\"><a href=\"#2-1-1-安装Java环境\" class=\"headerlink\" title=\"2.1.1. 安装Java环境\"></a>2.1.1. 安装Java环境</h4><p>Jenkins本身是依赖Java的，所以我们需要先安装Java环境：</p>\n<ul>\n<li>这里我安装了Java1.8的环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf search java-1.8<br>dnf install java-1.8.0-openjdk.x86_64<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-2-安装Jenkins\"><a href=\"#2-1-2-安装Jenkins\" class=\"headerlink\" title=\"2.1.2. 安装Jenkins\"></a>2.1.2. 安装Jenkins</h4><p>因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：</p>\n<ul>\n<li>wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；</li>\n<li>rpm：全称为<strong>The RPM Package Manage</strong>，是Linux下一个软件包管理器；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">导入GPG密钥以确保您的软件合法</span><br>rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者</span><br>rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key<br></code></pre></td></tr></table></figure>\n\n<p>编辑一下文件/etc/yum.repos.d/jenkins.repo</p>\n<ul>\n<li>可以通过vim编辑</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[jenkins]</span><br><br><span class=\"hljs-attr\">name</span>=Jenkins-stable<br><br><span class=\"hljs-attr\">baseurl</span>=http://pkg.jenkins.io/redhat<br><br><span class=\"hljs-attr\">gpgcheck</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>安装Jenkins</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install jenkins # --nogpgcheck(可以不加)<br></code></pre></td></tr></table></figure>\n\n<p>启动Jenkins的服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start jenkins<br>systemctl status jenkins<br>systemctl enable jenkins<br></code></pre></td></tr></table></figure>\n\n<p>Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg\" alt=\"image-20201204173117359\"></p>\n<h4 id=\"2-1-3-Jenkins用户\"><a href=\"#2-1-3-Jenkins用户\" class=\"headerlink\" title=\"2.1.3. Jenkins用户\"></a>2.1.3. Jenkins用户</h4><p>我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 <code>jenkins</code>，可能会没有访问权限，所以我们需要修改一下它的用户：</p>\n<p>修改文件的路径：<code>/etc/sysconfig/jenkins</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg\" alt=\"image-20210825162827962\"></p>\n<p>之后需要重启一下Jenkins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl restart jenkins<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-4-Jenkins配置\"><a href=\"#2-1-4-Jenkins配置\" class=\"headerlink\" title=\"2.1.4. Jenkins配置\"></a>2.1.4. Jenkins配置</h4><p>打开浏览器，输入：<a href=\"http://8.134.60.235:8080/\">http://8.134.60.235:8080/</a></p>\n<ul>\n<li>注意：你输入自己的IP地址</li>\n</ul>\n<p>获取输入管理员密码：</p>\n<ul>\n<li>在下面的地址中 <code>cat /var/lib/jenkins/secrets/initialAdminPassword</code></li>\n</ul>\n<p>![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)</p>\n<p>可以安装推荐的插件：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg\" alt=\"安装推荐的插件\"></p>\n<h4 id=\"2-1-5-Jenkins任务\"><a href=\"#2-1-5-Jenkins任务\" class=\"headerlink\" title=\"2.1.5. Jenkins任务\"></a>2.1.5. Jenkins任务</h4><p><strong>新建任务：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg\" alt=\"新建任务\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg\" alt=\"image-20201204185613061\"></p>\n<p><strong>配置项目和保留策略：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg\" alt=\"image-20210825160744119\"></p>\n<p><strong>源码管理：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg\" alt=\"image-20210825160818122\"></p>\n<p><strong>构建触发器：</strong></p>\n<p>这里的触发器规则是这样的：</p>\n<ul>\n<li>定时字符串从左往右分别是：分 时 日 月 周</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">#每半小时构建一次<span class=\"hljs-variable constant_\">OR</span>每半小时检查一次远程代码分支，有更新则构建<br>H/<span class=\"hljs-number\">30</span> * * * *<br><br>#每两小时构建一次<span class=\"hljs-variable constant_\">OR</span>每两小时检查一次远程代码分支，有更新则构建<br>H H/<span class=\"hljs-number\">2</span> * * *<br><br>#每天凌晨两点定时构建<br>H <span class=\"hljs-number\">2</span> * * *<br><br>#每月<span class=\"hljs-number\">15</span>号执行构建<br>H H <span class=\"hljs-number\">15</span> * *<br><br>#工作日，上午<span class=\"hljs-number\">9</span>点整执行<br>H <span class=\"hljs-number\">9</span> * * <span class=\"hljs-number\">1</span>-<span class=\"hljs-number\">5</span><br><br>#每周<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>，从<span class=\"hljs-number\">8</span>:<span class=\"hljs-number\">30</span>开始，截止<span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">30</span>，每<span class=\"hljs-number\">4</span>小时<span class=\"hljs-number\">30</span>分构建一次<br>H/<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">8</span>-<span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">4</span> * * <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg\" alt=\"触发器\"></p>\n<p><strong>构建环境：</strong></p>\n<p>注意：我们需要搭建Node的环境</p>\n<ul>\n<li>第一步：配置Node的环境；</li>\n<li>第二步：安装Node的插件；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg\" alt=\"image-20201204190055096\"></p>\n<p>第一步：配置Node的环境</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg\" alt=\"node环境\"></p>\n<p>第二步：安装Node的插件</p>\n<ul>\n<li>这里因为我已经安装过了，所以没有搜索到；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg\" alt=\"image-20201204185949452\"></p>\n<p>构建执行的任务：</p>\n<ul>\n<li>查看Node的版本等是否有问题；</li>\n<li>执行 <code>npm install</code> 安装项目的依赖；</li>\n<li>移除原来mall_cms文件的所有内容；</li>\n<li>将打包的dist文件夹内容移动到mall_cms文件夹；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pwd<br>node -v<br>npm -v<br><br>npm install <br>npm run build<br><br>pwd<br><br>echo &#x27;构建成功&#x27;<br><br>ls<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除/root/mall_cms文件夹里所有的内容</span><br>rm -rf /root/mall_cms/* <br><br>cp -rf ./dist/* /root/mall_cms/<br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg\" alt=\"执行构建任务\"></p>\n<h3 id=\"2-2-nginx安装和配置\"><a href=\"#2-2-nginx安装和配置\" class=\"headerlink\" title=\"2.2. nginx安装和配置\"></a>2.2. nginx安装和配置</h3><h4 id=\"2-2-1-安装nginx\"><a href=\"#2-2-1-安装nginx\" class=\"headerlink\" title=\"2.2.1. 安装nginx\"></a>2.2.1. 安装nginx</h4><p>后续我们部署会使用nginx，所以需要先安装一下nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install nginx<br></code></pre></td></tr></table></figure>\n\n<p>启动nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start nginx<br>systemctl status nginx<br>systemctl enable nginx<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-2-配置nginx\"><a href=\"#2-2-2-配置nginx\" class=\"headerlink\" title=\"2.2.2. 配置nginx\"></a>2.2.2. 配置nginx</h4><p>我们这里主要配置nginx的用户和默认访问目录：</p>\n<p>配置用户：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg\" alt=\"image-20210825163329209\"></p>\n<p>通过Linux命令创建文件夹和文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir /root/mall_cms<br>cd /root/mall_cms<br>touch index.html<br><br>vi index.html<br></code></pre></td></tr></table></figure>\n\n\n\n<p>配置访问目录：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg\" alt=\"image-20210825163406566\"></p>\n","site":{"data":{}},"wordcount":2193,"excerpt":"","more":"<h2 id=\"一-购买云服务器\"><a href=\"#一-购买云服务器\" class=\"headerlink\" title=\"一. 购买云服务器\"></a>一. 购买云服务器</h2><p>这里我购买的服务器是阿里云的ECS云服务器，系统是CentOS Linux release 8.5.2111，怎么购买自行百度或直接去官网购买</p>\n<h2 id=\"二-搭建服务器环境\"><a href=\"#二-搭建服务器环境\" class=\"headerlink\" title=\"二. 搭建服务器环境\"></a>二. 搭建服务器环境</h2><h3 id=\"2-1-jenkins自动化部署\"><a href=\"#2-1-jenkins自动化部署\" class=\"headerlink\" title=\"2.1. jenkins自动化部署\"></a>2.1. jenkins自动化部署</h3><h4 id=\"2-1-1-安装Java环境\"><a href=\"#2-1-1-安装Java环境\" class=\"headerlink\" title=\"2.1.1. 安装Java环境\"></a>2.1.1. 安装Java环境</h4><p>Jenkins本身是依赖Java的，所以我们需要先安装Java环境：</p>\n<ul>\n<li>这里我安装了Java1.8的环境</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf search java-1.8<br>dnf install java-1.8.0-openjdk.x86_64<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-2-安装Jenkins\"><a href=\"#2-1-2-安装Jenkins\" class=\"headerlink\" title=\"2.1.2. 安装Jenkins\"></a>2.1.2. 安装Jenkins</h4><p>因为Jenkins本身是没有在dnf的软件仓库包中的，所以我们需要连接Jenkins仓库：</p>\n<ul>\n<li>wget是Linux中下载文件的一个工具，-O表示输出到某个文件夹并且命名为什么文件；</li>\n<li>rpm：全称为<strong>The RPM Package Manage</strong>，是Linux下一个软件包管理器；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">wget –O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">导入GPG密钥以确保您的软件合法</span><br>rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者</span><br>rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key<br></code></pre></td></tr></table></figure>\n\n<p>编辑一下文件/etc/yum.repos.d/jenkins.repo</p>\n<ul>\n<li>可以通过vim编辑</li>\n</ul>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-section\">[jenkins]</span><br><br><span class=\"hljs-attr\">name</span>=Jenkins-stable<br><br><span class=\"hljs-attr\">baseurl</span>=http://pkg.jenkins.io/redhat<br><br><span class=\"hljs-attr\">gpgcheck</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>安装Jenkins</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install jenkins # --nogpgcheck(可以不加)<br></code></pre></td></tr></table></figure>\n\n<p>启动Jenkins的服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start jenkins<br>systemctl status jenkins<br>systemctl enable jenkins<br></code></pre></td></tr></table></figure>\n\n<p>Jenkins默认使用8080端口提供服务，所以需要加入到安全组中：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbyeoz6tqj315w0bzmzj.jpg\" alt=\"image-20201204173117359\"></p>\n<h4 id=\"2-1-3-Jenkins用户\"><a href=\"#2-1-3-Jenkins用户\" class=\"headerlink\" title=\"2.1.3. Jenkins用户\"></a>2.1.3. Jenkins用户</h4><p>我们后面会访问centos中的某些文件夹，默认Jenkins使用的用户是 <code>jenkins</code>，可能会没有访问权限，所以我们需要修改一下它的用户：</p>\n<p>修改文件的路径：<code>/etc/sysconfig/jenkins</code></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt46oxg53j60n00aw75302.jpg\" alt=\"image-20210825162827962\"></p>\n<p>之后需要重启一下Jenkins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl restart jenkins<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-1-4-Jenkins配置\"><a href=\"#2-1-4-Jenkins配置\" class=\"headerlink\" title=\"2.1.4. Jenkins配置\"></a>2.1.4. Jenkins配置</h4><p>打开浏览器，输入：<a href=\"http://8.134.60.235:8080/\">http://8.134.60.235:8080/</a></p>\n<ul>\n<li>注意：你输入自己的IP地址</li>\n</ul>\n<p>获取输入管理员密码：</p>\n<ul>\n<li>在下面的地址中 <code>cat /var/lib/jenkins/secrets/initialAdminPassword</code></li>\n</ul>\n<p>![image-20201203173047824](/Users/coderwhy/Library/Application Support/typora-user-images/image-20201203173047824.png)</p>\n<p>可以安装推荐的插件：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glbylb26ouj30fb082js7.jpg\" alt=\"安装推荐的插件\"></p>\n<h4 id=\"2-1-5-Jenkins任务\"><a href=\"#2-1-5-Jenkins任务\" class=\"headerlink\" title=\"2.1.5. Jenkins任务\"></a>2.1.5. Jenkins任务</h4><p><strong>新建任务：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0uinjzej30pa0fet9z.jpg\" alt=\"新建任务\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0v225vaj30wl0hkn05.jpg\" alt=\"image-20201204185613061\"></p>\n<p><strong>配置项目和保留策略：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3l4fjm6j614p0d2dgl02.jpg\" alt=\"image-20210825160744119\"></p>\n<p><strong>源码管理：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt3lpcvtgj614k0j8jsn02.jpg\" alt=\"image-20210825160818122\"></p>\n<p><strong>构建触发器：</strong></p>\n<p>这里的触发器规则是这样的：</p>\n<ul>\n<li>定时字符串从左往右分别是：分 时 日 月 周</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">#每半小时构建一次<span class=\"hljs-variable constant_\">OR</span>每半小时检查一次远程代码分支，有更新则构建<br>H/<span class=\"hljs-number\">30</span> * * * *<br><br>#每两小时构建一次<span class=\"hljs-variable constant_\">OR</span>每两小时检查一次远程代码分支，有更新则构建<br>H H/<span class=\"hljs-number\">2</span> * * *<br><br>#每天凌晨两点定时构建<br>H <span class=\"hljs-number\">2</span> * * *<br><br>#每月<span class=\"hljs-number\">15</span>号执行构建<br>H H <span class=\"hljs-number\">15</span> * *<br><br>#工作日，上午<span class=\"hljs-number\">9</span>点整执行<br>H <span class=\"hljs-number\">9</span> * * <span class=\"hljs-number\">1</span>-<span class=\"hljs-number\">5</span><br><br>#每周<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>，从<span class=\"hljs-number\">8</span>:<span class=\"hljs-number\">30</span>开始，截止<span class=\"hljs-number\">19</span>:<span class=\"hljs-number\">30</span>，每<span class=\"hljs-number\">4</span>小时<span class=\"hljs-number\">30</span>分构建一次<br>H/<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">8</span>-<span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">4</span> * * <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt419gw6tj614g0agmy402.jpg\" alt=\"触发器\"></p>\n<p><strong>构建环境：</strong></p>\n<p>注意：我们需要搭建Node的环境</p>\n<ul>\n<li>第一步：配置Node的环境；</li>\n<li>第二步：安装Node的插件；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0zyecd4j31ar0ecjuz.jpg\" alt=\"image-20201204190055096\"></p>\n<p>第一步：配置Node的环境</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt42elwduj614h0elwfq02.jpg\" alt=\"node环境\"></p>\n<p>第二步：安装Node的插件</p>\n<ul>\n<li>这里因为我已经安装过了，所以没有搜索到；</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1glc0yta64bj30r907caam.jpg\" alt=\"image-20201204185949452\"></p>\n<p>构建执行的任务：</p>\n<ul>\n<li>查看Node的版本等是否有问题；</li>\n<li>执行 <code>npm install</code> 安装项目的依赖；</li>\n<li>移除原来mall_cms文件的所有内容；</li>\n<li>将打包的dist文件夹内容移动到mall_cms文件夹；</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">pwd<br>node -v<br>npm -v<br><br>npm install <br>npm run build<br><br>pwd<br><br>echo &#x27;构建成功&#x27;<br><br>ls<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除/root/mall_cms文件夹里所有的内容</span><br>rm -rf /root/mall_cms/* <br><br>cp -rf ./dist/* /root/mall_cms/<br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt43sz933j614o0dy0tk02.jpg\" alt=\"执行构建任务\"></p>\n<h3 id=\"2-2-nginx安装和配置\"><a href=\"#2-2-nginx安装和配置\" class=\"headerlink\" title=\"2.2. nginx安装和配置\"></a>2.2. nginx安装和配置</h3><h4 id=\"2-2-1-安装nginx\"><a href=\"#2-2-1-安装nginx\" class=\"headerlink\" title=\"2.2.1. 安装nginx\"></a>2.2.1. 安装nginx</h4><p>后续我们部署会使用nginx，所以需要先安装一下nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">dnf install nginx<br></code></pre></td></tr></table></figure>\n\n<p>启动nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start nginx<br>systemctl status nginx<br>systemctl enable nginx<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-2-配置nginx\"><a href=\"#2-2-2-配置nginx\" class=\"headerlink\" title=\"2.2.2. 配置nginx\"></a>2.2.2. 配置nginx</h4><p>我们这里主要配置nginx的用户和默认访问目录：</p>\n<p>配置用户：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4bwvxc4j60f30453yk02.jpg\" alt=\"image-20210825163329209\"></p>\n<p>通过Linux命令创建文件夹和文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir /root/mall_cms<br>cd /root/mall_cms<br>touch index.html<br><br>vi index.html<br></code></pre></td></tr></table></figure>\n\n\n\n<p>配置访问目录：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNgy1gtt4cka6hgj60n00bwgmc02.jpg\" alt=\"image-20210825163406566\"></p>\n"},{"title":"react学习笔记","keywords":"react","_content":"## 一、react的基本使用\n\n\n\n#### 1.react的安装：\n\n安装命令： npm i react react-dom\n\n- react包是核心，提供创建元素、组建等功能\n- react-dom包提供DOM相关功能\n\n#### 2.react的使用\n\n- 引入react和react-dom\n- 创建react元素\n  - const title = react.createElement('h1', null, 'hello react')\n  - 第一个参数：创建的元素名称\n  - 第二个参数： 元素的属性\n  - 第三个和以后的参数： 元素的子节点\n- 渲染react元素到页面中\n  - ReactDom.render(title, document.querySelector('#app') )\n  - 第一个参数：要渲染的元素\n  - 第二个参数：DOM对象，用于指定渲染到页面中的位置\n\n## 二、react脚手架的使用\n\n#### 1.使用react脚手架初始化项目\n\n- 命令：npx create-react-app my-app\n\n#### 2.npx命令介绍\n\n目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令\n\n## 三、JSX语法的基本使用\n\n#### 1.使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\n  const title = <h1>hello JSX<h1>\n  ```\n\n- 使用ReactDOM.render()方法渲染元素到页面中\n\n```react\n  ReactDOM.render(title, document.querySelector('#root'))\n  ```\n\n#### 2.为什么脚手架中可以使用JSX语法\n\ncreate-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译\n\n#### 3.注意点\n\n- 元素的属性名使用驼峰命名法\n- 特殊属性名： class -> className, for -> htmlFor, table index -> tabIndex\n- 没有子节点的React元素可以用/>结束\n- 推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱\n\n## 四、JSX中使用javascript表达式\n\n- 数据存储在js中\n\n- 语法： { javascript表达式 }\n\n```react\n  const name = 'jack'\n  const div = (\n  \t<div>hello {name}</div>\n  )\n  ```\n\n- 注意点\n\n  - 单大括号中可以使用任意的JavaScript表达式\n  - JSX自身也是JS表达式，可以在单大括号中使用\n  - js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中\n  - 不能在{}中出现语句（如if/for语句等 ）\n\n## 五、JSX的条件渲染\n\n- 场景：loading效果\n\n- 条件渲染：根据条件渲染特定的JSX结构\n\n- 可以使用if/else或三元运算符或逻辑于运算符来实现\n\n```react\n  const isLoading = false\n  const loadData = () => {\n    return isLoading ?  (<div>加载中...</div>) : (<div>加载完成</div>)\n  }\n  const title = (\n    <div>{loadData()}</div>\n  )\n  ```\n\n## 六、JSX的列表渲染\n\n- 如果要渲染一组数据，应该使用数组的map方法\n\n- 渲染列表时应该添加key属性，key属性的值应该要保证唯一\n\n- 尽量避免使用索引作为key\n\n```react\n  const songs = [\n    {id: 1, name: '痴心绝对'},\n    {id: 2, name: '童话'},\n    {id: 3, name: '演员'},\n  ]\n  const title = (\n    <ul>\n      {songs.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  )\n  ```\n\n## 七、JSX的样式处理\n\n1. 行内样式\n2. 类名\n\n```react\nimport './index.css'\nconst name = 'kobe'\n\nconst title = (\n  <h1 className=\"title\" style={{color: 'red', backgroundColor: 'blue'}}>\n    我是{name}\n  </h1>\n)\n```\n\n## 八、react组件的两种创建方式\n\n#### 1.使用函数创建组件\n\n- 使用JS中的函数创建的组件叫做函数组件\n\n- 函数组件必须有返回值\n\n- 组件名称必须以大写字母开头，react据此区分组件和普通的react元素\n\n- 使用函数名作为组件标签名\n\n```react\n  function Hello() {\n  \treturn(\n  \t\t<div>这是我的第一个函数组件</div>\n  \t)\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 2.使用类创建组件\n\n- 类组件：使用ES6的class创建的组件\n\n- 约定1：类名称必须以大写字母开头\n\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性\n\n- 约定3：类组件必须提供render（）方法\n\n- 约定4：render（）方法必须有返回值，表示该组件的结构\n\n```react\n  class Hello extends React.Component {\n  \trender() {\n  \t\treturn <div>我是类组件<div>\n  \t}\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 3.抽离为独立的js模块\n\n1. 创建Hello.js\n\n2. 在Hello.js中导入react\n\n3. 创建组件（函数或类组件）\n\n4. 在Hello.js中到处该组件\n\n5. 在index.js中导入Hello组件\n\n6. 渲染组件\n\n```react\n  // Hello.js\n  import React from 'react'\n  class Hello extends React.Component {\n    render() {\n      return <div>我是Hello组件</div>\n    }\n  }\n  // index.js\n  import Hello from './Hello'\n  ReactDOM.render(<Hello/>, root)\n```\n\n## 九、react事件处理\n\n- react事件绑定语法与DOM事件语法相似\n\n- 语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () => {} }\n\n- 注意：react事件才用驼峰命名法\n\n- 类组件中绑定事件\n\n```react\n  class App extends React.Component {\n    handleClick() {\n      console.log('click')\n    }\n  \trender() {\n      return <button onClick={this.handleClick}>点击</button>\n    }\n  }\n  ```\n\n- 函数组件中绑定事件\n\n```react\n  function App () {\n    handleClick() {\n      console.log('click')\n    }\n    return <button onClick={handleClick}>点击</button>\n  }\n  ```\n\n- 事件对象\n\n  - 可以通过事件处理程序的参数获取到事件对象\n\n  - react中的事件对象叫做：合成事件（对象）\n\n  - 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题\n\n  ```react\n    class Hello extends React.Component {\n      handleClick(e) {\n        e.preventDefault()\n      }\n      render() {\n        return <a onClick={this.handleClick} href=\"http://www.baidu.com\">百度一下</a>\n      }\n    }\n    ```\n\n## 十、有状态组件和无状态组件\n\n- 函数组件又叫做无状态组件，类组件又叫做有状态组件\n- 状态（state）即数据\n- 函数组件没有自己的状态，只负责数据展示（静）\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n## 十一、组件中的state和setState\n\n#### 1.state的基本使用\n\n- 状态即数据\n\n- 状态是私有的，只能在组件内部使用\n\n- 通过this.state来获取状态\n\n```react\n  class Hello extends React.Component {\n    // constructor() {\n    //  super(); //\n    //  this.state = {\n    //    count: 1\n    // }\n    // }\n    // 简写\n    state = {\n  \t\tcount: 1\n    }\n    render() {\n      return <h2>计数器： {this.state.count}</h2>\n    }\n  }\n  ```\n\n#### 2.setState()修改状态\n\n- 状态是可变的\n\n- 语法：this.setState({要修改的数据})\n\n- 注意：不要直接修改state的值\n\n- setState()作用：修改state、更新UI\n\n```react\n  this.setState({\n    count: this.state.count + 1\n  })\n  ```\n\n\n## 十二、事件绑定this指向\n\n1. 利用箭头函数改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tstate = {\n         count: 1\n       }\n     \trender() {\n         return (\n         \t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={() => this.handleClick()}>+1</button>\n           </div>\n         )\n       }\n     \thandleClick() {\n         this.setState({\n           count: this.state.count + 1\n         })\n       }\n     }\n     ```\n\n2. 利用bind改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick() {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n3. class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick = () => {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n## 十三、表单处理\n\n#### 1.受控组件（常用）\n\n其值收到react控制的表单元素\n\n实现一个受控组件（类似于vue中的v-model）：\n\n1.表单value绑定state中的状态\n\n2.监听表单的change事件，修改state中的状态\n\n```react\nclass Hello extends React.Component {\n\tstate = {\n    text: ''\n  }\n\trender() {\n    return <input type=\"text\" value={this.state.text} onClick={ this.inputChange }></input>\n  }\n\tinputChange = e => {\n    this.setState({\n      text: e.target.value\n    })\n\t}\n}\n```\n\n#### 2.非受控组件（不常用）\n\n- 通过React.createRef()方法创建ref对象\n\n```react\n  constructor() {\n    super()\n    this.txtRef = React.createRef()\n  }\n  ```\n\n  \n\n- 表单使用ref对象\n\n```react\n  render() {\n    return (\n    \t<div>\n      \t<input type=\"text\" ref={ this.txtRef }></input>\n        <button onClick={ this.getValue }>获取value</button>\n      </div>\n    )\n  }\n  ```\n\n  \n\n- 通过ref对象获取表单的值\n\n```react\n  getValue = () => {\n  \tconsole.log(this.txtRef.current.value)\n  }\n  ```\n\n## 十四、组件通讯\n\n#### 1.组件的props\n\n- props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据\n\n- 接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）\n\n```react\n   // 1.函数组件props\n  const Hello = props => {\n    return (\n      <h2>func props: { props.name }</h2>\n    )\n  }\n  // 2.类组件props\n  class Hello extends React.Component {\n    render() {\n      return (\n        <h2>class props: { this.props.name }</h2>\n      )\n    }\n  }\n  \n  ReactDOM.render(<Hello name=\"component props\" />, document.querySelector('#root'))\n  ```\n\n- 特点：\n\n  - 可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）\n  - props只读属性，只能读取属性的值，无法修改对象\n  - ⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props\n\n#### 2.父组件传递数据给子组件\n\n```react\nclass Parent extends React.Component {\n  state = {\n    name: 'kobe'\n  }\n  render() {\n    return (\n      <div>\n        父组件\n        <Child name={ this.state.name }></Child>\n        </div>\n    )\n  }\n}\nclass Child extends React.Component {\n  render() {\n    return (\n      <div>父组件传递给子组件的数据: { this.props.name}</div>\n    )\n  }\n}\nReactDOM.render(\n  <Parent/>,\n  document.querySelector(\"#root\")\n);\n```\n\n#### 3.子组件传递数据给父组件\n\n思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件\n\n```react\nclass Father extends React.Component {\n  state = {\n    childMsg: ''\n  }\n  render() {\n\t\treturn (\n    \t<div>\n      \t<h2>子组件传递的数据: { this.state.childMsg }</h2>\n        <Child getMsg={ this.getChildMsg }></Child>\n      </div>\n    )\n  }\n\tgetChildMsg(childMsg) {\n\t\tthis.setState({\n      childMsg:  childMsg\n    })\n  }\n}\nclass Son extends React.Component {\n\tstate = {\n\t\tchildMsg: 'child'\n  }\n\trender() {\n\t\treturn (\n    \t<button onClick={ this.emitMsg }></button>\n    )\n  }\n\temitMsg = () => {\n\t\tthis.props.getMsg(this.state.childMsg)\n  }\n}\n```\n\n注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错\n\n#### 4.兄弟组件通讯\n\n- 将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态\n\n- 父组件：提供共享状态、提供操作共享状态的方法\n\n- 子组件：通过props获取共享状态和操作共享状态\n\n```react\n  class Parent extends React.Component {\n    // 状态提升\n    state = {\n      count: 1\n    }\n    render() {\n      return (\n        <div>\n          <Child1 count={ this.state.count }></Child1>\n          <Child2 increment = { this.increment}></Child2>\n        </div>\n      )\n    }\n    // 提供修改状态的方法\n    increment = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n  }\n  \n  const Child1 = props => {\n    return (\n      <h2>计数器: { props.count }</h2>\n    )\n  }\n  \n  const Child2 = props => {\n    const increment = () => {\n      props.increment()\n    }\n    return (\n      <button onClick={ increment }>+1</button>\n    )\n  \n  }\n    ReactDOM.render(\n      <Parent/>,\n      document.querySelector(\"#root\")\n    )\n  ```\n\n\n#### 5.组件树传递数据\n\n- Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。\n\n- 使用 context, 我们可以避免通过中间元素传递 props：\n\n```react\n  // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n  // 为当前的 theme 创建一个 context（“light”为默认值）。\n  const ThemeContext = React.createContext('light');\n  class App extends React.Component {\n    render() {\n      // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n      // 无论多深，任何组件都能读取这个值。\n      // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n  }\n  \n  // 中间的组件再也不必指明往下传递 theme 了。\n  function Toolbar() {\n    return (\n      <div>\n        <ThemedButton />\n      </div>\n    );\n  }\n  \n  class ThemedButton extends React.Component {\n    // 指定 contextType 读取当前的 theme context。\n    // React 会往上找到最近的 theme Provider，然后使用它的值。\n    // 在这个例子中，当前的 theme 值为 “dark”。\n    static contextType = ThemeContext;\n    render() {\n      return <Button theme={this.context} />;\n    }\n  }\n  ```\n\n- 使用方法：\n\n  - 1.React.createContext方法创建context\n\n  ```react\n    const MyContext = React.createContext(defaultValue)\n    // 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n    // 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效\n    // or\n    const { Provider, Consumer } = React.creactContext()\n    ```\n\n  - 2.使用Context.Provider提供数据\n\n  ```react\n    <MyContext.Provider value={/* 某个值 */} />\n    // or\n    <Provider value={} />\n    // 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n    \n    // Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n    \n    // 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n    \n    \n    ```\n\n  - value提供为对象时注意事项：\n\n  - 因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 `value` 属性总是被赋值为新的对象：\n\n  ```react\n    class App extends React.Component {\n      render() {\n        return (\n          <MyContext.Provider value={{something: 'something'}}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 为了防止这种情况，将 value 状态提升到父节点的 state 里：\n\n  ```react\n    class App extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          value: {something: 'something'},\n        };\n      }\n    \n      render() {\n        return (\n          <MyContext.Provider value={this.state.value}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 3.消费数据\n\n    - 方式1：Class.contextType\n\n    ```react\n       // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\n      class MyClass extends React.Component {\n        static contextType = MyContext;\n        render() {\n          let value = this.context;\n          /* 基于这个值进行渲染工作 */\n        }\n      }\n      ```\n\n    - 方式2：Context.Consumer\n\n    ```react\n      // 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。\n      \n      // 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。\n      <MyContext.Consumer>\n        {value => /* 基于 context 值进行渲染*/}\n      </MyContext.Consumer>\n      // or \n      <Consumer>\n      \t{value => /* 基于 context 值进行渲染*/}\n      </Consumer>\n      ```\n\n      \n\n","source":"_posts/react.md","raw":"---\ntitle: react学习笔记\ntag: react\nkeywords: react\ncategories: 前端框架\n---\n## 一、react的基本使用\n\n\n\n#### 1.react的安装：\n\n安装命令： npm i react react-dom\n\n- react包是核心，提供创建元素、组建等功能\n- react-dom包提供DOM相关功能\n\n#### 2.react的使用\n\n- 引入react和react-dom\n- 创建react元素\n  - const title = react.createElement('h1', null, 'hello react')\n  - 第一个参数：创建的元素名称\n  - 第二个参数： 元素的属性\n  - 第三个和以后的参数： 元素的子节点\n- 渲染react元素到页面中\n  - ReactDom.render(title, document.querySelector('#app') )\n  - 第一个参数：要渲染的元素\n  - 第二个参数：DOM对象，用于指定渲染到页面中的位置\n\n## 二、react脚手架的使用\n\n#### 1.使用react脚手架初始化项目\n\n- 命令：npx create-react-app my-app\n\n#### 2.npx命令介绍\n\n目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令\n\n## 三、JSX语法的基本使用\n\n#### 1.使用步骤\n\n- 使用JSX语法创建react元素\n\n```react\n  const title = <h1>hello JSX<h1>\n  ```\n\n- 使用ReactDOM.render()方法渲染元素到页面中\n\n```react\n  ReactDOM.render(title, document.querySelector('#root'))\n  ```\n\n#### 2.为什么脚手架中可以使用JSX语法\n\ncreate-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译\n\n#### 3.注意点\n\n- 元素的属性名使用驼峰命名法\n- 特殊属性名： class -> className, for -> htmlFor, table index -> tabIndex\n- 没有子节点的React元素可以用/>结束\n- 推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱\n\n## 四、JSX中使用javascript表达式\n\n- 数据存储在js中\n\n- 语法： { javascript表达式 }\n\n```react\n  const name = 'jack'\n  const div = (\n  \t<div>hello {name}</div>\n  )\n  ```\n\n- 注意点\n\n  - 单大括号中可以使用任意的JavaScript表达式\n  - JSX自身也是JS表达式，可以在单大括号中使用\n  - js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中\n  - 不能在{}中出现语句（如if/for语句等 ）\n\n## 五、JSX的条件渲染\n\n- 场景：loading效果\n\n- 条件渲染：根据条件渲染特定的JSX结构\n\n- 可以使用if/else或三元运算符或逻辑于运算符来实现\n\n```react\n  const isLoading = false\n  const loadData = () => {\n    return isLoading ?  (<div>加载中...</div>) : (<div>加载完成</div>)\n  }\n  const title = (\n    <div>{loadData()}</div>\n  )\n  ```\n\n## 六、JSX的列表渲染\n\n- 如果要渲染一组数据，应该使用数组的map方法\n\n- 渲染列表时应该添加key属性，key属性的值应该要保证唯一\n\n- 尽量避免使用索引作为key\n\n```react\n  const songs = [\n    {id: 1, name: '痴心绝对'},\n    {id: 2, name: '童话'},\n    {id: 3, name: '演员'},\n  ]\n  const title = (\n    <ul>\n      {songs.map(item => <li key={item.id}>{item.name}</li>)}\n    </ul>\n  )\n  ```\n\n## 七、JSX的样式处理\n\n1. 行内样式\n2. 类名\n\n```react\nimport './index.css'\nconst name = 'kobe'\n\nconst title = (\n  <h1 className=\"title\" style={{color: 'red', backgroundColor: 'blue'}}>\n    我是{name}\n  </h1>\n)\n```\n\n## 八、react组件的两种创建方式\n\n#### 1.使用函数创建组件\n\n- 使用JS中的函数创建的组件叫做函数组件\n\n- 函数组件必须有返回值\n\n- 组件名称必须以大写字母开头，react据此区分组件和普通的react元素\n\n- 使用函数名作为组件标签名\n\n```react\n  function Hello() {\n  \treturn(\n  \t\t<div>这是我的第一个函数组件</div>\n  \t)\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 2.使用类创建组件\n\n- 类组件：使用ES6的class创建的组件\n\n- 约定1：类名称必须以大写字母开头\n\n- 约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性\n\n- 约定3：类组件必须提供render（）方法\n\n- 约定4：render（）方法必须有返回值，表示该组件的结构\n\n```react\n  class Hello extends React.Component {\n  \trender() {\n  \t\treturn <div>我是类组件<div>\n  \t}\n  }\n  ReactDOM.render(<Hello/>, document.getElementById('root'))\n  ```\n\n#### 3.抽离为独立的js模块\n\n1. 创建Hello.js\n\n2. 在Hello.js中导入react\n\n3. 创建组件（函数或类组件）\n\n4. 在Hello.js中到处该组件\n\n5. 在index.js中导入Hello组件\n\n6. 渲染组件\n\n```react\n  // Hello.js\n  import React from 'react'\n  class Hello extends React.Component {\n    render() {\n      return <div>我是Hello组件</div>\n    }\n  }\n  // index.js\n  import Hello from './Hello'\n  ReactDOM.render(<Hello/>, root)\n```\n\n## 九、react事件处理\n\n- react事件绑定语法与DOM事件语法相似\n\n- 语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () => {} }\n\n- 注意：react事件才用驼峰命名法\n\n- 类组件中绑定事件\n\n```react\n  class App extends React.Component {\n    handleClick() {\n      console.log('click')\n    }\n  \trender() {\n      return <button onClick={this.handleClick}>点击</button>\n    }\n  }\n  ```\n\n- 函数组件中绑定事件\n\n```react\n  function App () {\n    handleClick() {\n      console.log('click')\n    }\n    return <button onClick={handleClick}>点击</button>\n  }\n  ```\n\n- 事件对象\n\n  - 可以通过事件处理程序的参数获取到事件对象\n\n  - react中的事件对象叫做：合成事件（对象）\n\n  - 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题\n\n  ```react\n    class Hello extends React.Component {\n      handleClick(e) {\n        e.preventDefault()\n      }\n      render() {\n        return <a onClick={this.handleClick} href=\"http://www.baidu.com\">百度一下</a>\n      }\n    }\n    ```\n\n## 十、有状态组件和无状态组件\n\n- 函数组件又叫做无状态组件，类组件又叫做有状态组件\n- 状态（state）即数据\n- 函数组件没有自己的状态，只负责数据展示（静）\n- 类组件有自己的状态，负责更新UI，让页面动起来\n\n## 十一、组件中的state和setState\n\n#### 1.state的基本使用\n\n- 状态即数据\n\n- 状态是私有的，只能在组件内部使用\n\n- 通过this.state来获取状态\n\n```react\n  class Hello extends React.Component {\n    // constructor() {\n    //  super(); //\n    //  this.state = {\n    //    count: 1\n    // }\n    // }\n    // 简写\n    state = {\n  \t\tcount: 1\n    }\n    render() {\n      return <h2>计数器： {this.state.count}</h2>\n    }\n  }\n  ```\n\n#### 2.setState()修改状态\n\n- 状态是可变的\n\n- 语法：this.setState({要修改的数据})\n\n- 注意：不要直接修改state的值\n\n- setState()作用：修改state、更新UI\n\n```react\n  this.setState({\n    count: this.state.count + 1\n  })\n  ```\n\n\n## 十二、事件绑定this指向\n\n1. 利用箭头函数改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tstate = {\n         count: 1\n       }\n     \trender() {\n         return (\n         \t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={() => this.handleClick()}>+1</button>\n           </div>\n         )\n       }\n     \thandleClick() {\n         this.setState({\n           count: this.state.count + 1\n         })\n       }\n     }\n     ```\n\n2. 利用bind改变this指向\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick() {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n3. class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）\n\n  ```react\n     class Hello extends React.Component {\n     \tconstructor() {\n         this.state = {\n     \t\t\tcount: 1\n         }\n         this.handleClick = this.handleClick.bind(this)\n       }\n     \trender() {\n     \t\treturn (\n     \t\t\t<div>\n           \t<h2>计数器：{this.state.count}</h2>\n             <button onClick={this.handleClick}>-1</button>\n           </div>\n     \t\t)\n     \t}\n     \thandleClick = () => {\n     \t\tthis.setState({\n           count: this.state.count - 1\n         })\n     \t}\n     }\n     ```\n\n## 十三、表单处理\n\n#### 1.受控组件（常用）\n\n其值收到react控制的表单元素\n\n实现一个受控组件（类似于vue中的v-model）：\n\n1.表单value绑定state中的状态\n\n2.监听表单的change事件，修改state中的状态\n\n```react\nclass Hello extends React.Component {\n\tstate = {\n    text: ''\n  }\n\trender() {\n    return <input type=\"text\" value={this.state.text} onClick={ this.inputChange }></input>\n  }\n\tinputChange = e => {\n    this.setState({\n      text: e.target.value\n    })\n\t}\n}\n```\n\n#### 2.非受控组件（不常用）\n\n- 通过React.createRef()方法创建ref对象\n\n```react\n  constructor() {\n    super()\n    this.txtRef = React.createRef()\n  }\n  ```\n\n  \n\n- 表单使用ref对象\n\n```react\n  render() {\n    return (\n    \t<div>\n      \t<input type=\"text\" ref={ this.txtRef }></input>\n        <button onClick={ this.getValue }>获取value</button>\n      </div>\n    )\n  }\n  ```\n\n  \n\n- 通过ref对象获取表单的值\n\n```react\n  getValue = () => {\n  \tconsole.log(this.txtRef.current.value)\n  }\n  ```\n\n## 十四、组件通讯\n\n#### 1.组件的props\n\n- props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据\n\n- 接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）\n\n```react\n   // 1.函数组件props\n  const Hello = props => {\n    return (\n      <h2>func props: { props.name }</h2>\n    )\n  }\n  // 2.类组件props\n  class Hello extends React.Component {\n    render() {\n      return (\n        <h2>class props: { this.props.name }</h2>\n      )\n    }\n  }\n  \n  ReactDOM.render(<Hello name=\"component props\" />, document.querySelector('#root'))\n  ```\n\n- 特点：\n\n  - 可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）\n  - props只读属性，只能读取属性的值，无法修改对象\n  - ⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props\n\n#### 2.父组件传递数据给子组件\n\n```react\nclass Parent extends React.Component {\n  state = {\n    name: 'kobe'\n  }\n  render() {\n    return (\n      <div>\n        父组件\n        <Child name={ this.state.name }></Child>\n        </div>\n    )\n  }\n}\nclass Child extends React.Component {\n  render() {\n    return (\n      <div>父组件传递给子组件的数据: { this.props.name}</div>\n    )\n  }\n}\nReactDOM.render(\n  <Parent/>,\n  document.querySelector(\"#root\")\n);\n```\n\n#### 3.子组件传递数据给父组件\n\n思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件\n\n```react\nclass Father extends React.Component {\n  state = {\n    childMsg: ''\n  }\n  render() {\n\t\treturn (\n    \t<div>\n      \t<h2>子组件传递的数据: { this.state.childMsg }</h2>\n        <Child getMsg={ this.getChildMsg }></Child>\n      </div>\n    )\n  }\n\tgetChildMsg(childMsg) {\n\t\tthis.setState({\n      childMsg:  childMsg\n    })\n  }\n}\nclass Son extends React.Component {\n\tstate = {\n\t\tchildMsg: 'child'\n  }\n\trender() {\n\t\treturn (\n    \t<button onClick={ this.emitMsg }></button>\n    )\n  }\n\temitMsg = () => {\n\t\tthis.props.getMsg(this.state.childMsg)\n  }\n}\n```\n\n注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错\n\n#### 4.兄弟组件通讯\n\n- 将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态\n\n- 父组件：提供共享状态、提供操作共享状态的方法\n\n- 子组件：通过props获取共享状态和操作共享状态\n\n```react\n  class Parent extends React.Component {\n    // 状态提升\n    state = {\n      count: 1\n    }\n    render() {\n      return (\n        <div>\n          <Child1 count={ this.state.count }></Child1>\n          <Child2 increment = { this.increment}></Child2>\n        </div>\n      )\n    }\n    // 提供修改状态的方法\n    increment = () => {\n      this.setState({\n        count: this.state.count + 1\n      })\n    }\n  }\n  \n  const Child1 = props => {\n    return (\n      <h2>计数器: { props.count }</h2>\n    )\n  }\n  \n  const Child2 = props => {\n    const increment = () => {\n      props.increment()\n    }\n    return (\n      <button onClick={ increment }>+1</button>\n    )\n  \n  }\n    ReactDOM.render(\n      <Parent/>,\n      document.querySelector(\"#root\")\n    )\n  ```\n\n\n#### 5.组件树传递数据\n\n- Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。\n\n- 使用 context, 我们可以避免通过中间元素传递 props：\n\n```react\n  // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n  // 为当前的 theme 创建一个 context（“light”为默认值）。\n  const ThemeContext = React.createContext('light');\n  class App extends React.Component {\n    render() {\n      // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n      // 无论多深，任何组件都能读取这个值。\n      // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n      return (\n        <ThemeContext.Provider value=\"dark\">\n          <Toolbar />\n        </ThemeContext.Provider>\n      );\n    }\n  }\n  \n  // 中间的组件再也不必指明往下传递 theme 了。\n  function Toolbar() {\n    return (\n      <div>\n        <ThemedButton />\n      </div>\n    );\n  }\n  \n  class ThemedButton extends React.Component {\n    // 指定 contextType 读取当前的 theme context。\n    // React 会往上找到最近的 theme Provider，然后使用它的值。\n    // 在这个例子中，当前的 theme 值为 “dark”。\n    static contextType = ThemeContext;\n    render() {\n      return <Button theme={this.context} />;\n    }\n  }\n  ```\n\n- 使用方法：\n\n  - 1.React.createContext方法创建context\n\n  ```react\n    const MyContext = React.createContext(defaultValue)\n    // 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n    // 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效\n    // or\n    const { Provider, Consumer } = React.creactContext()\n    ```\n\n  - 2.使用Context.Provider提供数据\n\n  ```react\n    <MyContext.Provider value={/* 某个值 */} />\n    // or\n    <Provider value={} />\n    // 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n    \n    // Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n    \n    // 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n    \n    \n    ```\n\n  - value提供为对象时注意事项：\n\n  - 因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 `value` 属性总是被赋值为新的对象：\n\n  ```react\n    class App extends React.Component {\n      render() {\n        return (\n          <MyContext.Provider value={{something: 'something'}}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 为了防止这种情况，将 value 状态提升到父节点的 state 里：\n\n  ```react\n    class App extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          value: {something: 'something'},\n        };\n      }\n    \n      render() {\n        return (\n          <MyContext.Provider value={this.state.value}>\n            <Toolbar />\n          </MyContext.Provider>\n        );\n      }\n    }\n    ```\n\n  - 3.消费数据\n\n    - 方式1：Class.contextType\n\n    ```react\n       // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。\n      class MyClass extends React.Component {\n        static contextType = MyContext;\n        render() {\n          let value = this.context;\n          /* 基于这个值进行渲染工作 */\n        }\n      }\n      ```\n\n    - 方式2：Context.Consumer\n\n    ```react\n      // 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。\n      \n      // 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。\n      <MyContext.Consumer>\n        {value => /* 基于 context 值进行渲染*/}\n      </MyContext.Consumer>\n      // or \n      <Consumer>\n      \t{value => /* 基于 context 值进行渲染*/}\n      </Consumer>\n      ```\n\n      \n\n","slug":"react","published":1,"date":"2021-08-25T01:38:07.000Z","updated":"2021-10-14T01:22:47.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9ky000ki024a0hehacj","content":"<h2 id=\"一、react的基本使用\"><a href=\"#一、react的基本使用\" class=\"headerlink\" title=\"一、react的基本使用\"></a>一、react的基本使用</h2><h4 id=\"1-react的安装：\"><a href=\"#1-react的安装：\" class=\"headerlink\" title=\"1.react的安装：\"></a>1.react的安装：</h4><p>安装命令： npm i react react-dom</p>\n<ul>\n<li>react包是核心，提供创建元素、组建等功能</li>\n<li>react-dom包提供DOM相关功能</li>\n</ul>\n<h4 id=\"2-react的使用\"><a href=\"#2-react的使用\" class=\"headerlink\" title=\"2.react的使用\"></a>2.react的使用</h4><ul>\n<li>引入react和react-dom</li>\n<li>创建react元素<ul>\n<li>const title = react.createElement(‘h1’, null, ‘hello react’)</li>\n<li>第一个参数：创建的元素名称</li>\n<li>第二个参数： 元素的属性</li>\n<li>第三个和以后的参数： 元素的子节点</li>\n</ul>\n</li>\n<li>渲染react元素到页面中<ul>\n<li>ReactDom.render(title, document.querySelector(‘#app’) )</li>\n<li>第一个参数：要渲染的元素</li>\n<li>第二个参数：DOM对象，用于指定渲染到页面中的位置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、react脚手架的使用\"><a href=\"#二、react脚手架的使用\" class=\"headerlink\" title=\"二、react脚手架的使用\"></a>二、react脚手架的使用</h2><h4 id=\"1-使用react脚手架初始化项目\"><a href=\"#1-使用react脚手架初始化项目\" class=\"headerlink\" title=\"1.使用react脚手架初始化项目\"></a>1.使用react脚手架初始化项目</h4><ul>\n<li>命令：npx create-react-app my-app</li>\n</ul>\n<h4 id=\"2-npx命令介绍\"><a href=\"#2-npx命令介绍\" class=\"headerlink\" title=\"2.npx命令介绍\"></a>2.npx命令介绍</h4><p>目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令</p>\n<h2 id=\"三、JSX语法的基本使用\"><a href=\"#三、JSX语法的基本使用\" class=\"headerlink\" title=\"三、JSX语法的基本使用\"></a>三、JSX语法的基本使用</h2><h4 id=\"1-使用步骤\"><a href=\"#1-使用步骤\" class=\"headerlink\" title=\"1.使用步骤\"></a>1.使用步骤</h4><ul>\n<li>使用JSX语法创建react元素</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const title = &lt;h1&gt;hello JSX&lt;h1&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>使用ReactDOM.render()方法渲染元素到页面中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">ReactDOM.render(title, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-为什么脚手架中可以使用JSX语法\"><a href=\"#2-为什么脚手架中可以使用JSX语法\" class=\"headerlink\" title=\"2.为什么脚手架中可以使用JSX语法\"></a>2.为什么脚手架中可以使用JSX语法</h4><p>create-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译</p>\n<h4 id=\"3-注意点\"><a href=\"#3-注意点\" class=\"headerlink\" title=\"3.注意点\"></a>3.注意点</h4><ul>\n<li>元素的属性名使用驼峰命名法</li>\n<li>特殊属性名： class -&gt; className, for -&gt; htmlFor, table index -&gt; tabIndex</li>\n<li>没有子节点的React元素可以用/&gt;结束</li>\n<li>推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱</li>\n</ul>\n<h2 id=\"四、JSX中使用javascript表达式\"><a href=\"#四、JSX中使用javascript表达式\" class=\"headerlink\" title=\"四、JSX中使用javascript表达式\"></a>四、JSX中使用javascript表达式</h2><ul>\n<li><p>数据存储在js中</p>\n</li>\n<li><p>语法： { javascript表达式 }</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const name = &#x27;jack&#x27;<br>const div = (<br>\t&lt;div&gt;hello &#123;name&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意点</p>\n<ul>\n<li>单大括号中可以使用任意的JavaScript表达式</li>\n<li>JSX自身也是JS表达式，可以在单大括号中使用</li>\n<li>js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中</li>\n<li>不能在{}中出现语句（如if/for语句等 ）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五、JSX的条件渲染\"><a href=\"#五、JSX的条件渲染\" class=\"headerlink\" title=\"五、JSX的条件渲染\"></a>五、JSX的条件渲染</h2><ul>\n<li><p>场景：loading效果</p>\n</li>\n<li><p>条件渲染：根据条件渲染特定的JSX结构</p>\n</li>\n<li><p>可以使用if/else或三元运算符或逻辑于运算符来实现</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const isLoading = false<br>const loadData = () =&gt; &#123;<br>  return isLoading ?  (&lt;div&gt;加载中...&lt;/div&gt;) : (&lt;div&gt;加载完成&lt;/div&gt;)<br>&#125;<br>const title = (<br>  &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、JSX的列表渲染\"><a href=\"#六、JSX的列表渲染\" class=\"headerlink\" title=\"六、JSX的列表渲染\"></a>六、JSX的列表渲染</h2><ul>\n<li><p>如果要渲染一组数据，应该使用数组的map方法</p>\n</li>\n<li><p>渲染列表时应该添加key属性，key属性的值应该要保证唯一</p>\n</li>\n<li><p>尽量避免使用索引作为key</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const songs = [<br>  &#123;id: 1, name: &#x27;痴心绝对&#x27;&#125;,<br>  &#123;id: 2, name: &#x27;童话&#x27;&#125;,<br>  &#123;id: 3, name: &#x27;演员&#x27;&#125;,<br>]<br>const title = (<br>  &lt;ul&gt;<br>    &#123;songs.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;<br>  &lt;/ul&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、JSX的样式处理\"><a href=\"#七、JSX的样式处理\" class=\"headerlink\" title=\"七、JSX的样式处理\"></a>七、JSX的样式处理</h2><ol>\n<li>行内样式</li>\n<li>类名</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#x27;./index.css&#x27;<br>const name = &#x27;kobe&#x27;<br><br>const title = (<br>  &lt;h1 className=&quot;title&quot; style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;blue&#x27;&#125;&#125;&gt;<br>    我是&#123;name&#125;<br>  &lt;/h1&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、react组件的两种创建方式\"><a href=\"#八、react组件的两种创建方式\" class=\"headerlink\" title=\"八、react组件的两种创建方式\"></a>八、react组件的两种创建方式</h2><h4 id=\"1-使用函数创建组件\"><a href=\"#1-使用函数创建组件\" class=\"headerlink\" title=\"1.使用函数创建组件\"></a>1.使用函数创建组件</h4><ul>\n<li><p>使用JS中的函数创建的组件叫做函数组件</p>\n</li>\n<li><p>函数组件必须有返回值</p>\n</li>\n<li><p>组件名称必须以大写字母开头，react据此区分组件和普通的react元素</p>\n</li>\n<li><p>使用函数名作为组件标签名</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function Hello() &#123;<br>\treturn(<br>\t\t&lt;div&gt;这是我的第一个函数组件&lt;/div&gt;<br>\t)<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用类创建组件\"><a href=\"#2-使用类创建组件\" class=\"headerlink\" title=\"2.使用类创建组件\"></a>2.使用类创建组件</h4><ul>\n<li><p>类组件：使用ES6的class创建的组件</p>\n</li>\n<li><p>约定1：类名称必须以大写字母开头</p>\n</li>\n<li><p>约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性</p>\n</li>\n<li><p>约定3：类组件必须提供render（）方法</p>\n</li>\n<li><p>约定4：render（）方法必须有返回值，表示该组件的结构</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\trender() &#123;<br>\t\treturn &lt;div&gt;我是类组件&lt;div&gt;<br>\t&#125;<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-抽离为独立的js模块\"><a href=\"#3-抽离为独立的js模块\" class=\"headerlink\" title=\"3.抽离为独立的js模块\"></a>3.抽离为独立的js模块</h4><ol>\n<li><p>创建Hello.js</p>\n</li>\n<li><p>在Hello.js中导入react</p>\n</li>\n<li><p>创建组件（函数或类组件）</p>\n</li>\n<li><p>在Hello.js中到处该组件</p>\n</li>\n<li><p>在index.js中导入Hello组件</p>\n</li>\n<li><p>渲染组件</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Hello.js<br>import React from &#x27;react&#x27;<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return &lt;div&gt;我是Hello组件&lt;/div&gt;<br>  &#125;<br>&#125;<br>// index.js<br>import Hello from &#x27;./Hello&#x27;<br>ReactDOM.render(&lt;Hello/&gt;, root)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、react事件处理\"><a href=\"#九、react事件处理\" class=\"headerlink\" title=\"九、react事件处理\"></a>九、react事件处理</h2><ul>\n<li><p>react事件绑定语法与DOM事件语法相似</p>\n</li>\n<li><p>语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () =&gt; {} }</p>\n</li>\n<li><p>注意：react事件才用驼峰命名法</p>\n</li>\n<li><p>类组件中绑定事件</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>\trender() &#123;<br>    return &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>函数组件中绑定事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function App () &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>  return &lt;button onClick=&#123;handleClick&#125;&gt;点击&lt;/button&gt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件对象</p>\n<ul>\n<li><p>可以通过事件处理程序的参数获取到事件对象</p>\n</li>\n<li><p>react中的事件对象叫做：合成事件（对象）</p>\n</li>\n<li><p>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  handleClick(e) &#123;<br>    e.preventDefault()<br>  &#125;<br>  render() &#123;<br>    return &lt;a onClick=&#123;this.handleClick&#125; href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"十、有状态组件和无状态组件\"><a href=\"#十、有状态组件和无状态组件\" class=\"headerlink\" title=\"十、有状态组件和无状态组件\"></a>十、有状态组件和无状态组件</h2><ul>\n<li>函数组件又叫做无状态组件，类组件又叫做有状态组件</li>\n<li>状态（state）即数据</li>\n<li>函数组件没有自己的状态，只负责数据展示（静）</li>\n<li>类组件有自己的状态，负责更新UI，让页面动起来</li>\n</ul>\n<h2 id=\"十一、组件中的state和setState\"><a href=\"#十一、组件中的state和setState\" class=\"headerlink\" title=\"十一、组件中的state和setState\"></a>十一、组件中的state和setState</h2><h4 id=\"1-state的基本使用\"><a href=\"#1-state的基本使用\" class=\"headerlink\" title=\"1.state的基本使用\"></a>1.state的基本使用</h4><ul>\n<li><p>状态即数据</p>\n</li>\n<li><p>状态是私有的，只能在组件内部使用</p>\n</li>\n<li><p>通过this.state来获取状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  // constructor() &#123;<br>  //  super(); //<br>  //  this.state = &#123;<br>  //    count: 1<br>  // &#125;<br>  // &#125;<br>  // 简写<br>  state = &#123;<br>\t\tcount: 1<br>  &#125;<br>  render() &#123;<br>    return &lt;h2&gt;计数器： &#123;this.state.count&#125;&lt;/h2&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-setState-修改状态\"><a href=\"#2-setState-修改状态\" class=\"headerlink\" title=\"2.setState()修改状态\"></a>2.setState()修改状态</h4><ul>\n<li><p>状态是可变的</p>\n</li>\n<li><p>语法：this.setState({要修改的数据})</p>\n</li>\n<li><p>注意：不要直接修改state的值</p>\n</li>\n<li><p>setState()作用：修改state、更新UI</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">this.setState(&#123;<br>  count: this.state.count + 1<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"十二、事件绑定this指向\"><a href=\"#十二、事件绑定this指向\" class=\"headerlink\" title=\"十二、事件绑定this指向\"></a>十二、事件绑定this指向</h2><ol>\n<li>利用箭头函数改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    count: 1<br>  &#125;<br>\trender() &#123;<br>    return (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;+1&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\thandleClick() &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>利用bind改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick() &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick = () =&gt; &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、表单处理\"><a href=\"#十三、表单处理\" class=\"headerlink\" title=\"十三、表单处理\"></a>十三、表单处理</h2><h4 id=\"1-受控组件（常用）\"><a href=\"#1-受控组件（常用）\" class=\"headerlink\" title=\"1.受控组件（常用）\"></a>1.受控组件（常用）</h4><p>其值收到react控制的表单元素</p>\n<p>实现一个受控组件（类似于vue中的v-model）：</p>\n<p>1.表单value绑定state中的状态</p>\n<p>2.监听表单的change事件，修改state中的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    text: &#x27;&#x27;<br>  &#125;<br>\trender() &#123;<br>    return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onClick=&#123; this.inputChange &#125;&gt;&lt;/input&gt;<br>  &#125;<br>\tinputChange = e =&gt; &#123;<br>    this.setState(&#123;<br>      text: e.target.value<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-非受控组件（不常用）\"><a href=\"#2-非受控组件（不常用）\" class=\"headerlink\" title=\"2.非受控组件（不常用）\"></a>2.非受控组件（不常用）</h4><ul>\n<li>通过React.createRef()方法创建ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">constructor() &#123;<br>  super()<br>  this.txtRef = React.createRef()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>表单使用ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">render() &#123;<br>  return (<br>  \t&lt;div&gt;<br>    \t&lt;input type=&quot;text&quot; ref=&#123; this.txtRef &#125;&gt;&lt;/input&gt;<br>      &lt;button onClick=&#123; this.getValue &#125;&gt;获取value&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过ref对象获取表单的值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">getValue = () =&gt; &#123;<br>\tconsole.log(this.txtRef.current.value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、组件通讯\"><a href=\"#十四、组件通讯\" class=\"headerlink\" title=\"十四、组件通讯\"></a>十四、组件通讯</h2><h4 id=\"1-组件的props\"><a href=\"#1-组件的props\" class=\"headerlink\" title=\"1.组件的props\"></a>1.组件的props</h4><ul>\n<li><p>props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据</p>\n</li>\n<li><p>接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 1.函数组件props<br>const Hello = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;func props: &#123; props.name &#125;&lt;/h2&gt;<br>  )<br>&#125;<br>// 2.类组件props<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;h2&gt;class props: &#123; this.props.name &#125;&lt;/h2&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(&lt;Hello name=&quot;component props&quot; /&gt;, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>特点：</p>\n<ul>\n<li>可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）</li>\n<li>props只读属性，只能读取属性的值，无法修改对象</li>\n<li>⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-父组件传递数据给子组件\"><a href=\"#2-父组件传递数据给子组件\" class=\"headerlink\" title=\"2.父组件传递数据给子组件\"></a>2.父组件传递数据给子组件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  state = &#123;<br>    name: &#x27;kobe&#x27;<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        父组件<br>        &lt;Child name=&#123; this.state.name &#125;&gt;&lt;/Child&gt;<br>        &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>class Child extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;父组件传递给子组件的数据: &#123; this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;Parent/&gt;,<br>  document.querySelector(&quot;#root&quot;)<br>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-子组件传递数据给父组件\"><a href=\"#3-子组件传递数据给父组件\" class=\"headerlink\" title=\"3.子组件传递数据给父组件\"></a>3.子组件传递数据给父组件</h4><p>思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Father extends React.Component &#123;<br>  state = &#123;<br>    childMsg: &#x27;&#x27;<br>  &#125;<br>  render() &#123;<br>\t\treturn (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;子组件传递的数据: &#123; this.state.childMsg &#125;&lt;/h2&gt;<br>        &lt;Child getMsg=&#123; this.getChildMsg &#125;&gt;&lt;/Child&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\tgetChildMsg(childMsg) &#123;<br>\t\tthis.setState(&#123;<br>      childMsg:  childMsg<br>    &#125;)<br>  &#125;<br>&#125;<br>class Son extends React.Component &#123;<br>\tstate = &#123;<br>\t\tchildMsg: &#x27;child&#x27;<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>    \t&lt;button onClick=&#123; this.emitMsg &#125;&gt;&lt;/button&gt;<br>    )<br>  &#125;<br>\temitMsg = () =&gt; &#123;<br>\t\tthis.props.getMsg(this.state.childMsg)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错</p>\n<h4 id=\"4-兄弟组件通讯\"><a href=\"#4-兄弟组件通讯\" class=\"headerlink\" title=\"4.兄弟组件通讯\"></a>4.兄弟组件通讯</h4><ul>\n<li><p>将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态</p>\n</li>\n<li><p>父组件：提供共享状态、提供操作共享状态的方法</p>\n</li>\n<li><p>子组件：通过props获取共享状态和操作共享状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  // 状态提升<br>  state = &#123;<br>    count: 1<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;Child1 count=&#123; this.state.count &#125;&gt;&lt;/Child1&gt;<br>        &lt;Child2 increment = &#123; this.increment&#125;&gt;&lt;/Child2&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>  // 提供修改状态的方法<br>  increment = () =&gt; &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br><br>const Child1 = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;计数器: &#123; props.count &#125;&lt;/h2&gt;<br>  )<br>&#125;<br><br>const Child2 = props =&gt; &#123;<br>  const increment = () =&gt; &#123;<br>    props.increment()<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123; increment &#125;&gt;+1&lt;/button&gt;<br>  )<br><br>&#125;<br>  ReactDOM.render(<br>    &lt;Parent/&gt;,<br>    document.querySelector(&quot;#root&quot;)<br>  )<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"5-组件树传递数据\"><a href=\"#5-组件树传递数据\" class=\"headerlink\" title=\"5.组件树传递数据\"></a>5.组件树传递数据</h4><ul>\n<li><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>\n</li>\n<li><p>使用 context, 我们可以避免通过中间元素传递 props：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。<br>// 为当前的 theme 创建一个 context（“light”为默认值）。<br>const ThemeContext = React.createContext(&#x27;light&#x27;);<br>class App extends React.Component &#123;<br>  render() &#123;<br>    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。<br>    // 无论多深，任何组件都能读取这个值。<br>    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。<br>    return (<br>      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/ThemeContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br><br>// 中间的组件再也不必指明往下传递 theme 了。<br>function Toolbar() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;ThemedButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br>class ThemedButton extends React.Component &#123;<br>  // 指定 contextType 读取当前的 theme context。<br>  // React 会往上找到最近的 theme Provider，然后使用它的值。<br>  // 在这个例子中，当前的 theme 值为 “dark”。<br>  static contextType = ThemeContext;<br>  render() &#123;<br>    return &lt;Button theme=&#123;this.context&#125; /&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用方法：</p>\n<ul>\n<li>1.React.createContext方法创建context</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const MyContext = React.createContext(defaultValue)<br>// 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。<br>// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效<br>// or<br>const &#123; Provider, Consumer &#125; = React.creactContext()<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>2.使用Context.Provider提供数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125; /&gt;<br>// or<br>&lt;Provider value=&#123;&#125; /&gt;<br>// 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。<br><br>// Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。<br><br>// 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。<br><br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>value提供为对象时注意事项：</p>\n</li>\n<li><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;&#123;something: &#x27;something&#x27;&#125;&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>为了防止这种情况，将 value 状态提升到父节点的 state 里：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props);<br>    this.state = &#123;<br>      value: &#123;something: &#x27;something&#x27;&#125;,<br>    &#125;;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;this.state.value&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>3.消费数据</p>\n<ul>\n<li>方式1：Class.contextType</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。<br>class MyClass extends React.Component &#123;<br>  static contextType = MyContext;<br>  render() &#123;<br>    let value = this.context;<br>    /* 基于这个值进行渲染工作 */<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>方式2：Context.Consumer</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。<br><br>// 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。<br>&lt;MyContext.Consumer&gt;<br>  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/MyContext.Consumer&gt;<br>// or <br>&lt;Consumer&gt;<br>\t&#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/Consumer&gt;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":12108,"excerpt":"","more":"<h2 id=\"一、react的基本使用\"><a href=\"#一、react的基本使用\" class=\"headerlink\" title=\"一、react的基本使用\"></a>一、react的基本使用</h2><h4 id=\"1-react的安装：\"><a href=\"#1-react的安装：\" class=\"headerlink\" title=\"1.react的安装：\"></a>1.react的安装：</h4><p>安装命令： npm i react react-dom</p>\n<ul>\n<li>react包是核心，提供创建元素、组建等功能</li>\n<li>react-dom包提供DOM相关功能</li>\n</ul>\n<h4 id=\"2-react的使用\"><a href=\"#2-react的使用\" class=\"headerlink\" title=\"2.react的使用\"></a>2.react的使用</h4><ul>\n<li>引入react和react-dom</li>\n<li>创建react元素<ul>\n<li>const title = react.createElement(‘h1’, null, ‘hello react’)</li>\n<li>第一个参数：创建的元素名称</li>\n<li>第二个参数： 元素的属性</li>\n<li>第三个和以后的参数： 元素的子节点</li>\n</ul>\n</li>\n<li>渲染react元素到页面中<ul>\n<li>ReactDom.render(title, document.querySelector(‘#app’) )</li>\n<li>第一个参数：要渲染的元素</li>\n<li>第二个参数：DOM对象，用于指定渲染到页面中的位置</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、react脚手架的使用\"><a href=\"#二、react脚手架的使用\" class=\"headerlink\" title=\"二、react脚手架的使用\"></a>二、react脚手架的使用</h2><h4 id=\"1-使用react脚手架初始化项目\"><a href=\"#1-使用react脚手架初始化项目\" class=\"headerlink\" title=\"1.使用react脚手架初始化项目\"></a>1.使用react脚手架初始化项目</h4><ul>\n<li>命令：npx create-react-app my-app</li>\n</ul>\n<h4 id=\"2-npx命令介绍\"><a href=\"#2-npx命令介绍\" class=\"headerlink\" title=\"2.npx命令介绍\"></a>2.npx命令介绍</h4><p>目的：提升包内提供的命令行工具的使用体验。无需安装脚手架包，就可以直接使用这个包提供的命令</p>\n<h2 id=\"三、JSX语法的基本使用\"><a href=\"#三、JSX语法的基本使用\" class=\"headerlink\" title=\"三、JSX语法的基本使用\"></a>三、JSX语法的基本使用</h2><h4 id=\"1-使用步骤\"><a href=\"#1-使用步骤\" class=\"headerlink\" title=\"1.使用步骤\"></a>1.使用步骤</h4><ul>\n<li>使用JSX语法创建react元素</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const title = &lt;h1&gt;hello JSX&lt;h1&gt;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>使用ReactDOM.render()方法渲染元素到页面中</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">ReactDOM.render(title, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-为什么脚手架中可以使用JSX语法\"><a href=\"#2-为什么脚手架中可以使用JSX语法\" class=\"headerlink\" title=\"2.为什么脚手架中可以使用JSX语法\"></a>2.为什么脚手架中可以使用JSX语法</h4><p>create-react-app脚手架中默认有@babel/preset-react，会对项目中的JSX语法进行编译</p>\n<h4 id=\"3-注意点\"><a href=\"#3-注意点\" class=\"headerlink\" title=\"3.注意点\"></a>3.注意点</h4><ul>\n<li>元素的属性名使用驼峰命名法</li>\n<li>特殊属性名： class -&gt; className, for -&gt; htmlFor, table index -&gt; tabIndex</li>\n<li>没有子节点的React元素可以用/&gt;结束</li>\n<li>推荐：使用小括号包裹JSX，从而避免js中的自动插入分号陷阱</li>\n</ul>\n<h2 id=\"四、JSX中使用javascript表达式\"><a href=\"#四、JSX中使用javascript表达式\" class=\"headerlink\" title=\"四、JSX中使用javascript表达式\"></a>四、JSX中使用javascript表达式</h2><ul>\n<li><p>数据存储在js中</p>\n</li>\n<li><p>语法： { javascript表达式 }</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const name = &#x27;jack&#x27;<br>const div = (<br>\t&lt;div&gt;hello &#123;name&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意点</p>\n<ul>\n<li>单大括号中可以使用任意的JavaScript表达式</li>\n<li>JSX自身也是JS表达式，可以在单大括号中使用</li>\n<li>js中的对象不是表达式，不能直接在单大括号中使用，一般只会出现在style属性中</li>\n<li>不能在{}中出现语句（如if/for语句等 ）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"五、JSX的条件渲染\"><a href=\"#五、JSX的条件渲染\" class=\"headerlink\" title=\"五、JSX的条件渲染\"></a>五、JSX的条件渲染</h2><ul>\n<li><p>场景：loading效果</p>\n</li>\n<li><p>条件渲染：根据条件渲染特定的JSX结构</p>\n</li>\n<li><p>可以使用if/else或三元运算符或逻辑于运算符来实现</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const isLoading = false<br>const loadData = () =&gt; &#123;<br>  return isLoading ?  (&lt;div&gt;加载中...&lt;/div&gt;) : (&lt;div&gt;加载完成&lt;/div&gt;)<br>&#125;<br>const title = (<br>  &lt;div&gt;&#123;loadData()&#125;&lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、JSX的列表渲染\"><a href=\"#六、JSX的列表渲染\" class=\"headerlink\" title=\"六、JSX的列表渲染\"></a>六、JSX的列表渲染</h2><ul>\n<li><p>如果要渲染一组数据，应该使用数组的map方法</p>\n</li>\n<li><p>渲染列表时应该添加key属性，key属性的值应该要保证唯一</p>\n</li>\n<li><p>尽量避免使用索引作为key</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const songs = [<br>  &#123;id: 1, name: &#x27;痴心绝对&#x27;&#125;,<br>  &#123;id: 2, name: &#x27;童话&#x27;&#125;,<br>  &#123;id: 3, name: &#x27;演员&#x27;&#125;,<br>]<br>const title = (<br>  &lt;ul&gt;<br>    &#123;songs.map(item =&gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125;<br>  &lt;/ul&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、JSX的样式处理\"><a href=\"#七、JSX的样式处理\" class=\"headerlink\" title=\"七、JSX的样式处理\"></a>七、JSX的样式处理</h2><ol>\n<li>行内样式</li>\n<li>类名</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">import &#x27;./index.css&#x27;<br>const name = &#x27;kobe&#x27;<br><br>const title = (<br>  &lt;h1 className=&quot;title&quot; style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;blue&#x27;&#125;&#125;&gt;<br>    我是&#123;name&#125;<br>  &lt;/h1&gt;<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、react组件的两种创建方式\"><a href=\"#八、react组件的两种创建方式\" class=\"headerlink\" title=\"八、react组件的两种创建方式\"></a>八、react组件的两种创建方式</h2><h4 id=\"1-使用函数创建组件\"><a href=\"#1-使用函数创建组件\" class=\"headerlink\" title=\"1.使用函数创建组件\"></a>1.使用函数创建组件</h4><ul>\n<li><p>使用JS中的函数创建的组件叫做函数组件</p>\n</li>\n<li><p>函数组件必须有返回值</p>\n</li>\n<li><p>组件名称必须以大写字母开头，react据此区分组件和普通的react元素</p>\n</li>\n<li><p>使用函数名作为组件标签名</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function Hello() &#123;<br>\treturn(<br>\t\t&lt;div&gt;这是我的第一个函数组件&lt;/div&gt;<br>\t)<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用类创建组件\"><a href=\"#2-使用类创建组件\" class=\"headerlink\" title=\"2.使用类创建组件\"></a>2.使用类创建组件</h4><ul>\n<li><p>类组件：使用ES6的class创建的组件</p>\n</li>\n<li><p>约定1：类名称必须以大写字母开头</p>\n</li>\n<li><p>约定2：类组件应该继承React.Component父类，从而可以使用父类中提供的方法和属性</p>\n</li>\n<li><p>约定3：类组件必须提供render（）方法</p>\n</li>\n<li><p>约定4：render（）方法必须有返回值，表示该组件的结构</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\trender() &#123;<br>\t\treturn &lt;div&gt;我是类组件&lt;div&gt;<br>\t&#125;<br>&#125;<br>ReactDOM.render(&lt;Hello/&gt;, document.getElementById(&#x27;root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-抽离为独立的js模块\"><a href=\"#3-抽离为独立的js模块\" class=\"headerlink\" title=\"3.抽离为独立的js模块\"></a>3.抽离为独立的js模块</h4><ol>\n<li><p>创建Hello.js</p>\n</li>\n<li><p>在Hello.js中导入react</p>\n</li>\n<li><p>创建组件（函数或类组件）</p>\n</li>\n<li><p>在Hello.js中到处该组件</p>\n</li>\n<li><p>在index.js中导入Hello组件</p>\n</li>\n<li><p>渲染组件</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Hello.js<br>import React from &#x27;react&#x27;<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return &lt;div&gt;我是Hello组件&lt;/div&gt;<br>  &#125;<br>&#125;<br>// index.js<br>import Hello from &#x27;./Hello&#x27;<br>ReactDOM.render(&lt;Hello/&gt;, root)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"九、react事件处理\"><a href=\"#九、react事件处理\" class=\"headerlink\" title=\"九、react事件处理\"></a>九、react事件处理</h2><ul>\n<li><p>react事件绑定语法与DOM事件语法相似</p>\n</li>\n<li><p>语法：on + 事件名称 = {事件处理程序}，比如： onClick = { () =&gt; {} }</p>\n</li>\n<li><p>注意：react事件才用驼峰命名法</p>\n</li>\n<li><p>类组件中绑定事件</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>\trender() &#123;<br>    return &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>函数组件中绑定事件</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">function App () &#123;<br>  handleClick() &#123;<br>    console.log(&#x27;click&#x27;)<br>  &#125;<br>  return &lt;button onClick=&#123;handleClick&#125;&gt;点击&lt;/button&gt;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件对象</p>\n<ul>\n<li><p>可以通过事件处理程序的参数获取到事件对象</p>\n</li>\n<li><p>react中的事件对象叫做：合成事件（对象）</p>\n</li>\n<li><p>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  handleClick(e) &#123;<br>    e.preventDefault()<br>  &#125;<br>  render() &#123;<br>    return &lt;a onClick=&#123;this.handleClick&#125; href=&quot;http://www.baidu.com&quot;&gt;百度一下&lt;/a&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"十、有状态组件和无状态组件\"><a href=\"#十、有状态组件和无状态组件\" class=\"headerlink\" title=\"十、有状态组件和无状态组件\"></a>十、有状态组件和无状态组件</h2><ul>\n<li>函数组件又叫做无状态组件，类组件又叫做有状态组件</li>\n<li>状态（state）即数据</li>\n<li>函数组件没有自己的状态，只负责数据展示（静）</li>\n<li>类组件有自己的状态，负责更新UI，让页面动起来</li>\n</ul>\n<h2 id=\"十一、组件中的state和setState\"><a href=\"#十一、组件中的state和setState\" class=\"headerlink\" title=\"十一、组件中的state和setState\"></a>十一、组件中的state和setState</h2><h4 id=\"1-state的基本使用\"><a href=\"#1-state的基本使用\" class=\"headerlink\" title=\"1.state的基本使用\"></a>1.state的基本使用</h4><ul>\n<li><p>状态即数据</p>\n</li>\n<li><p>状态是私有的，只能在组件内部使用</p>\n</li>\n<li><p>通过this.state来获取状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>  // constructor() &#123;<br>  //  super(); //<br>  //  this.state = &#123;<br>  //    count: 1<br>  // &#125;<br>  // &#125;<br>  // 简写<br>  state = &#123;<br>\t\tcount: 1<br>  &#125;<br>  render() &#123;<br>    return &lt;h2&gt;计数器： &#123;this.state.count&#125;&lt;/h2&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-setState-修改状态\"><a href=\"#2-setState-修改状态\" class=\"headerlink\" title=\"2.setState()修改状态\"></a>2.setState()修改状态</h4><ul>\n<li><p>状态是可变的</p>\n</li>\n<li><p>语法：this.setState({要修改的数据})</p>\n</li>\n<li><p>注意：不要直接修改state的值</p>\n</li>\n<li><p>setState()作用：修改state、更新UI</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">this.setState(&#123;<br>  count: this.state.count + 1<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"十二、事件绑定this指向\"><a href=\"#十二、事件绑定this指向\" class=\"headerlink\" title=\"十二、事件绑定this指向\"></a>十二、事件绑定this指向</h2><ol>\n<li>利用箭头函数改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    count: 1<br>  &#125;<br>\trender() &#123;<br>    return (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;+1&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\thandleClick() &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>利用bind改变this指向</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick() &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>class的箭头函数实例方法（推荐方式，脚手架配置的babel对这种语法进行了转换）</li>\n</ol>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tconstructor() &#123;<br>    this.state = &#123;<br>\t\t\tcount: 1<br>    &#125;<br>    this.handleClick = this.handleClick.bind(this)<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>\t\t\t&lt;div&gt;<br>      \t&lt;h2&gt;计数器：&#123;this.state.count&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;this.handleClick&#125;&gt;-1&lt;/button&gt;<br>      &lt;/div&gt;<br>\t\t)<br>\t&#125;<br>\thandleClick = () =&gt; &#123;<br>\t\tthis.setState(&#123;<br>      count: this.state.count - 1<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十三、表单处理\"><a href=\"#十三、表单处理\" class=\"headerlink\" title=\"十三、表单处理\"></a>十三、表单处理</h2><h4 id=\"1-受控组件（常用）\"><a href=\"#1-受控组件（常用）\" class=\"headerlink\" title=\"1.受控组件（常用）\"></a>1.受控组件（常用）</h4><p>其值收到react控制的表单元素</p>\n<p>实现一个受控组件（类似于vue中的v-model）：</p>\n<p>1.表单value绑定state中的状态</p>\n<p>2.监听表单的change事件，修改state中的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Hello extends React.Component &#123;<br>\tstate = &#123;<br>    text: &#x27;&#x27;<br>  &#125;<br>\trender() &#123;<br>    return &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onClick=&#123; this.inputChange &#125;&gt;&lt;/input&gt;<br>  &#125;<br>\tinputChange = e =&gt; &#123;<br>    this.setState(&#123;<br>      text: e.target.value<br>    &#125;)<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-非受控组件（不常用）\"><a href=\"#2-非受控组件（不常用）\" class=\"headerlink\" title=\"2.非受控组件（不常用）\"></a>2.非受控组件（不常用）</h4><ul>\n<li>通过React.createRef()方法创建ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">constructor() &#123;<br>  super()<br>  this.txtRef = React.createRef()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>表单使用ref对象</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">render() &#123;<br>  return (<br>  \t&lt;div&gt;<br>    \t&lt;input type=&quot;text&quot; ref=&#123; this.txtRef &#125;&gt;&lt;/input&gt;<br>      &lt;button onClick=&#123; this.getValue &#125;&gt;获取value&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过ref对象获取表单的值</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">getValue = () =&gt; &#123;<br>\tconsole.log(this.txtRef.current.value)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"十四、组件通讯\"><a href=\"#十四、组件通讯\" class=\"headerlink\" title=\"十四、组件通讯\"></a>十四、组件通讯</h2><h4 id=\"1-组件的props\"><a href=\"#1-组件的props\" class=\"headerlink\" title=\"1.组件的props\"></a>1.组件的props</h4><ul>\n<li><p>props的作用： 与vue的props类似，父组件向子组件传递数据，子组件用来接收数据</p>\n</li>\n<li><p>接收数据：函数组件直接用props，类组件用this.props（和作用域有关，类组件的props加在实例上，函数组件直接通过参数接收）</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 1.函数组件props<br>const Hello = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;func props: &#123; props.name &#125;&lt;/h2&gt;<br>  )<br>&#125;<br>// 2.类组件props<br>class Hello extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;h2&gt;class props: &#123; this.props.name &#125;&lt;/h2&gt;<br>    )<br>  &#125;<br>&#125;<br><br>ReactDOM.render(&lt;Hello name=&quot;component props&quot; /&gt;, document.querySelector(&#x27;#root&#x27;))<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>特点：</p>\n<ul>\n<li>可以给组件穿任意类型的数据（数组、对象、jsx表达式、函数等）</li>\n<li>props只读属性，只能读取属性的值，无法修改对象</li>\n<li>⚠️在constructor中使用props时，需要接收props并传递给super，否则无法在构造函数中获取到props</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-父组件传递数据给子组件\"><a href=\"#2-父组件传递数据给子组件\" class=\"headerlink\" title=\"2.父组件传递数据给子组件\"></a>2.父组件传递数据给子组件</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  state = &#123;<br>    name: &#x27;kobe&#x27;<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        父组件<br>        &lt;Child name=&#123; this.state.name &#125;&gt;&lt;/Child&gt;<br>        &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>class Child extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;父组件传递给子组件的数据: &#123; this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;Parent/&gt;,<br>  document.querySelector(&quot;#root&quot;)<br>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-子组件传递数据给父组件\"><a href=\"#3-子组件传递数据给父组件\" class=\"headerlink\" title=\"3.子组件传递数据给父组件\"></a>3.子组件传递数据给父组件</h4><p>思路：父组件提供回调函数，同时将回调通过props传递给子组件，子组件通过props接收回调，执行回调并将需要传递的数据作为回调的参数传递给父组件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Father extends React.Component &#123;<br>  state = &#123;<br>    childMsg: &#x27;&#x27;<br>  &#125;<br>  render() &#123;<br>\t\treturn (<br>    \t&lt;div&gt;<br>      \t&lt;h2&gt;子组件传递的数据: &#123; this.state.childMsg &#125;&lt;/h2&gt;<br>        &lt;Child getMsg=&#123; this.getChildMsg &#125;&gt;&lt;/Child&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>\tgetChildMsg(childMsg) &#123;<br>\t\tthis.setState(&#123;<br>      childMsg:  childMsg<br>    &#125;)<br>  &#125;<br>&#125;<br>class Son extends React.Component &#123;<br>\tstate = &#123;<br>\t\tchildMsg: &#x27;child&#x27;<br>  &#125;<br>\trender() &#123;<br>\t\treturn (<br>    \t&lt;button onClick=&#123; this.emitMsg &#125;&gt;&lt;/button&gt;<br>    )<br>  &#125;<br>\temitMsg = () =&gt; &#123;<br>\t\tthis.props.getMsg(this.state.childMsg)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注意：此处在Child组件中，render函数的onClick上不能直接调用this.props.getMsg()，而要在抽离到实例方法中。原因：react会在props和state改变的时候调用render对DOM进行diff后更新渲染，如果在render中再次调用getMsg修改state，会陷入死循环并报错</p>\n<h4 id=\"4-兄弟组件通讯\"><a href=\"#4-兄弟组件通讯\" class=\"headerlink\" title=\"4.兄弟组件通讯\"></a>4.兄弟组件通讯</h4><ul>\n<li><p>将共享状态提升到最近的公共的父组件中，又公告父组件管理这个状态</p>\n</li>\n<li><p>父组件：提供共享状态、提供操作共享状态的方法</p>\n</li>\n<li><p>子组件：通过props获取共享状态和操作共享状态</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class Parent extends React.Component &#123;<br>  // 状态提升<br>  state = &#123;<br>    count: 1<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;<br>        &lt;Child1 count=&#123; this.state.count &#125;&gt;&lt;/Child1&gt;<br>        &lt;Child2 increment = &#123; this.increment&#125;&gt;&lt;/Child2&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>  // 提供修改状态的方法<br>  increment = () =&gt; &#123;<br>    this.setState(&#123;<br>      count: this.state.count + 1<br>    &#125;)<br>  &#125;<br>&#125;<br><br>const Child1 = props =&gt; &#123;<br>  return (<br>    &lt;h2&gt;计数器: &#123; props.count &#125;&lt;/h2&gt;<br>  )<br>&#125;<br><br>const Child2 = props =&gt; &#123;<br>  const increment = () =&gt; &#123;<br>    props.increment()<br>  &#125;<br>  return (<br>    &lt;button onClick=&#123; increment &#125;&gt;+1&lt;/button&gt;<br>  )<br><br>&#125;<br>  ReactDOM.render(<br>    &lt;Parent/&gt;,<br>    document.querySelector(&quot;#root&quot;)<br>  )<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"5-组件树传递数据\"><a href=\"#5-组件树传递数据\" class=\"headerlink\" title=\"5.组件树传递数据\"></a>5.组件树传递数据</h4><ul>\n<li><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。</p>\n</li>\n<li><p>使用 context, 我们可以避免通过中间元素传递 props：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。<br>// 为当前的 theme 创建一个 context（“light”为默认值）。<br>const ThemeContext = React.createContext(&#x27;light&#x27;);<br>class App extends React.Component &#123;<br>  render() &#123;<br>    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。<br>    // 无论多深，任何组件都能读取这个值。<br>    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。<br>    return (<br>      &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/ThemeContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br><br>// 中间的组件再也不必指明往下传递 theme 了。<br>function Toolbar() &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;ThemedButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br>class ThemedButton extends React.Component &#123;<br>  // 指定 contextType 读取当前的 theme context。<br>  // React 会往上找到最近的 theme Provider，然后使用它的值。<br>  // 在这个例子中，当前的 theme 值为 “dark”。<br>  static contextType = ThemeContext;<br>  render() &#123;<br>    return &lt;Button theme=&#123;this.context&#125; /&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>使用方法：</p>\n<ul>\n<li>1.React.createContext方法创建context</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">const MyContext = React.createContext(defaultValue)<br>// 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。<br>// 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效<br>// or<br>const &#123; Provider, Consumer &#125; = React.creactContext()<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>2.使用Context.Provider提供数据</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">&lt;MyContext.Provider value=&#123;/* 某个值 */&#125; /&gt;<br>// or<br>&lt;Provider value=&#123;&#125; /&gt;<br>// 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。<br><br>// Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。<br><br>// 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。<br><br><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>value提供为对象时注意事项：</p>\n</li>\n<li><p>因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 <code>value</code> 属性总是被赋值为新的对象：</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;&#123;something: &#x27;something&#x27;&#125;&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>为了防止这种情况，将 value 状态提升到父节点的 state 里：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props);<br>    this.state = &#123;<br>      value: &#123;something: &#x27;something&#x27;&#125;,<br>    &#125;;<br>  &#125;<br><br>  render() &#123;<br>    return (<br>      &lt;MyContext.Provider value=&#123;this.state.value&#125;&gt;<br>        &lt;Toolbar /&gt;<br>      &lt;/MyContext.Provider&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>3.消费数据</p>\n<ul>\n<li>方式1：Class.contextType</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\"> // 挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。此属性能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。<br>class MyClass extends React.Component &#123;<br>  static contextType = MyContext;<br>  render() &#123;<br>    let value = this.context;<br>    /* 基于这个值进行渲染工作 */<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>方式2：Context.Consumer</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs react\">// 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。<br><br>// 这种方法需要一个函数作为子元素（function as a child）。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。<br>&lt;MyContext.Consumer&gt;<br>  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/MyContext.Consumer&gt;<br>// or <br>&lt;Consumer&gt;<br>\t&#123;value =&gt; /* 基于 context 值进行渲染*/&#125;<br>&lt;/Consumer&gt;<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"svg相关笔记","keywords":"svg","_content":"## 一、入门指南\n\n### 1. 图形系统\n\n计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。\n\n### 2. SVG(Scalable Vector Graphics)\n\nSVG` 是一种 `XML` 应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的 `XML` 和 `SVG` 版本都为 `1.1\n\nSVG文档结构是标准的 `XML` 文档，根元素 `svg` 定义图形的大小，根元素中包含各种的形状元素。`SVG` 允许使用单独的属性指定元素的样式。\n\n`SVG` 使用 `g` 元素对图形进行分组，使用 `use` 元素实现元素的复用。\n\n## 二、在网页中使用\n\n### 1. 将SVG作为图像\n\n将 `svg` 作为图像包含在HTML标记的 `img` 元素内，但是这样有一定的局限性：\n\n**`SVG`转为栅格图像时与主页面分离，并且无法在两者之间通信( `SVG` 渲染过程与主页面独立)。主页面上的样式对 `SVG` 无效，运行在主页面上的脚本无法感知或者修改 `SVG` 文档结构。**\n\n在 `CSS` 中包含 `SVG`，最常用的是 `background-image` 属性，应该避免 `SVG` 元素文件太大。\n\n###  2. 将SVG作为应用程序\n\n使用 `object` 元素将 `SVG` 嵌入 `HTML` 文档中，`object`元素的 `type` 属性表示要嵌入的文档类型，对用 `SVG` 应该是`type=\"image/svg+xml\"`。`object` 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。\n\n## 三、坐标系统\n\n###  1. 视口\n\n视口是指文档打算使用的画布区域。在 `svg` 元素上使用 `width` 和 `height` 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为`em`、`ex`、`px`、`pt`、`pc`、`cm`、`mm` 和 `in`)也可以为百分比。\n\n### 2. 默认用户坐标\n\n`SVG` 阅读器会设置一个坐标系统，即原点 `(0,0)` 位于视口的左上角，`x` 向右递增，`y` 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。\n\n在 `SVG` 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 `SVG` 文档中各个元素的单位可以不统一。\n\n### 3. 指定用户坐标\n\n摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 `svg` 元素上设置 `viewBox` 属性。\n\n`viewBox` 属性由 `4` 个数值组成，分别代表要叠加在视口上的最小 `x`、最小 `y`，宽度、高度。\n\n既然可以对 `svg` 自定义用户坐标，那么肯定要解决 `svg` 视口长宽比例和 `viewBox` 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 `preserveAspectRatio` 属性了。\n\n如果 `viewBox` 的长宽比例与视口的长宽比例不同，那么 `svg` 可以有以下三种选择：\n\n- 按较小的尺寸等比例缩放图形，使图形完全填充视口\n- 按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分\n- 拉伸和压缩绘图以使其恰好填充视口\n\n```\npreserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = \"alignment[meet|slice]\"\n```\n\n默认值为 `\"xMidYMid meet\"`\n\n`alignment`指定轴和位置，`x` 和 `y` 方向都有 `min`, `mid`, `max` 三种方式，分别表示 `x` 和 `y` 方向的对齐方式，对齐方式由 `x` 和 `y` 组合指定，共 `9` 中方式，也就是 `alignment` 共有如下 `9` 个取值：\n\n| y\\x      | xMin     | xMid     | xMax     |\n| -------- | -------- | -------- | -------- |\n| **yMin** | xMinYMin | xMidYMin | xMaxYMin |\n| **yMid** | xMinYMid | xMidYMid | xMaxYMid |\n| **yMax** | xMinYMax | xMidYMax | xMaxYMax |\n\n`meet` 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间\n\n`slice` 说明符直接裁剪超出视口的部分\n\n除了上述操作之外，还可以指定 `preserveAspectRatio=\"none\"`，用于在 `viewBox` 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。\n\n### 4. 嵌套坐标系统\n\n可以将另一个 `svg` 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 `svg` 中可以嵌套另一个 `svg`，每个 `svg` 都有自己独立的视口和坐标系统\n\n## 四、基本形状\n\n###  1. 线段\n\n`line` 元素，使用 `x1`, `y1`, `x2`, `y2` 属性指定线段的起止点坐标。有如下特性:\n\n| 特性               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `stroke-width`     | 笔画宽度，坐标网格线位于笔画的正中间，可以使用 `css` 的 `shape-rendering` 值来控制反锯齿特性 |\n| `stroke`           | 笔画颜色                                                     |\n| `stroke-opacity`   | 线条的不透明度                                               |\n| `stroke-dasharray` | 虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙... |\n\n### 2. 矩形\n\n`rect`元素，使用`x`,`y`,`width`,`height`表示一个矩形\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内 |\n| `rx`/`ry`      | 圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值 |\n\n### 3. 圆和椭圆\n\n`circle` 元素表示圆,由 `cx`,`cy`,`r` 属性界定 `ellipse` 元素表示椭圆,由 `cx`,`cy`,`rx`,`ry` 界定\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内 |\n\n### 4. 多边形\n\n`polygon` 元素指定一个多边形,由 `points` 属性指定的一系列坐标点界定，会自动封闭\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度                                                     |\n| `fill-rule`    | 填充规则，如果多边形的边有交叉时，需要指定，可以取 `mozero`(默认)和 `evenodd` 两个值。 |\n\n`fill-rule` 值为 `nonzero` 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 `1`，如果是从左往右则总数减 `1`. 如果最后总数为 `0` 则认为改点在图形外部，否则在内部。\n\n`fill-rule` 值为 `evenodd` 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。\n\n### 5. 折线\n\n`polyline` 元素表示一个折线，使用 `points` 属性指定一系列点，不自动封闭图形。\n\n### 6. 特性总结\n\n| 特性                | 说明                                               |\n| ------------------- | -------------------------------------------------- |\n| `stroke`            | 笔画颜色                                           |\n| `stroke-width`      | 笔画宽度                                           |\n| `stroke-opacity`    | 笔画不透明度                                       |\n| `stroke-dasharray`  | 虚线笔画                                           |\n| `stroke-linecap`    | 笔画头的形状 `butt`(默认),`round`,`square`         |\n| `stroke-linejoin`   | 图形棱角，有`miter`(默认),`round`和`bevel`三个取值 |\n| `stroke-miterlimit` | 相交处显示宽度与线宽的最大比例，默认为`4`          |\n| `fill`              | 填充颜色 默认`black`                               |\n| `fill-opacity`      | 填充不透明度                                       |\n| `fill-rule`         | 填充规则                                           |\n\n## 五、文档结构\n\n### 1. 结构和表现\n\n`SVG` 允许文档表现和文档结构分离，`SVG` 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性\n\n| 表现方式   | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 内联样式   | 元素内部使用 `style` 属性                                    |\n| 内部样式表 | 内部样式定义在 `defs` 元素内部                               |\n| 外部样式表 | 与 `html` 类似，将样式定义在 `css` 文件中，使用选择器来设置相应的元素样式 |\n| 表现属性   | `SVG` 允许以属性的形式指定表现样式，但是**表现属性的优先级最低**，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式 |\n\n内部样式表示例：\n\n```xml\n<svg width=\"200px\" height=\"200px\" xmlns=\"http://www.w3.org/2000/svg>\n    <defs>\n        <style type=\"text/css\"><![CDATA[\n            circle{\n                fill:#ccc\n            }\n        ]]></style>\n    </defs>\n    <circle cx=\"10\" cy=\"10\" r=\"5\"/>\n</svg>\n```\n\n### 2. 分组和引用\n\n`g` 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。\n\n`use` 元素用来复用图形中重复出现的元素，需要为 `use` 标签的 `xlink:href` 指定 `URI` 来引用指定的图形元素。同时还要指定`x`和`y`属性以表示组合应该移动到哪个位置。`use`元素并不限制只能使用同一个文件内的对象，`xlink:href`属性可以指定任何有效的文件或`URI`。\n\n`defs`元素用来定义复用的元素，但是定义在`defs`内的元素并不会被显示，而是作为模板供其他地方使用。\n\n`symbol`元素与g元素不同，`symbol`永远不会被显示，也可以用来指定被后续使用的元素，`symbol`元素可以指定 `viewBox` 和`preserveAspectRatio` 属性。在引用时通过为 `use` 元素指定 `width` 和 `height` 属性就可以让 `symbol` 元素适配视口大小。\n\n`image` 可以用来包含一个完整的 `SVG` 或栅格文件。如果包含一个 `SVG` 文件，则视口会基于引用的文件的 `x`,`y`,`width`,`height` 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。\n\n`SVG`规范要求 `SVG` 阅读器支持 `JPEG` 和 `PNG` 两种栅格文件。\n\n## 六、坐标系统变换\n\n### 1. translate变换\n\n`translate` 变换用来对用户坐标进行平移，通过制定 `transform` 属性值来设置: `transform = \"translate(x,y)\"`。\n\n`translate` 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。\n\n### 2. scale变换\n\n缩放坐标系统。`transform = \"scale(value)\"` 或者 `transform=\"scale(x-value,y-value)\"`。\n\n仅仅使用 `scale(n)` 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 `n` 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。\n\n*技巧：如果从其他系统传输数据到 `SVG`，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，`y`向上递增，`x`向右递增。而 `SVG` 坐标原点位于左上角，此时使用 `scale(1,-1)` 就可以完成两者之间的转换。*\n\n**缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。**\n\n### 3. rotate变换\n\n根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，`0` 度为 `3` 点钟方向。\n\n注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： `translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)`\n\n但是有个更简单的方式：`rotate(angle,centerX,centerY)`\n\n### 4. 围绕中心点缩放\n\n上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：\n\n```\ntranslate(-centerX*(factor-1),-centerY*(factor-1)) scale(factor)\n```\n\n### 5. skewX和skewY变换\n\n这两个变换用来倾斜某个轴，一般形式为 `skewX(angle),skewY(angle)`。这样的结果就是使得 `x` 轴和 `y` 轴不再垂直。\n\n### 6. 矩阵变换\n\n计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 `matrix(a,b,c,d,e,f)`，此时指定的变换矩阵为:\n\n```text\na  c  e\nb  d  f\n0  0  1\n```\n\n## 七、路径\n\n### 1. path命令\n\n`SVG` 中所有基本形状都是 `path` 的简写形式，但是建议使用简写形式，因为这样可以使 `SVG` 文档更可读。\n\n`path` 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。\n\n下表为 `path` 命令总结，其中大写表示绝对坐标，小写表示相对坐标：\n\n| 命令    | 参数                                        | 说明                                                         |\n| ------- | ------------------------------------------- | ------------------------------------------------------------ |\n| `M` `m` | `x y`                                       | 移动画笔到制定坐标                                           |\n| `L` `l` | `x y`                                       | 绘制一条到给定坐标的线                                       |\n| `H` `h` | `x`                                         | 绘制一条到给定 `x` 坐标的横线                                |\n| `V` `v` | `y`                                         | 绘制一条到给定`y`坐标的垂线                                  |\n| `A` `a` | `rx ry x-axis-rotation large-arc sweep x y` | 圆弧曲线命令有7个参数，依次表示`x`方向半径、`y`方向半径、旋转角度、大圆标识、顺逆时针标识、目标点`x`、目标点`y`。大圆标识和顺逆时针以`0`和`1`表示。`0`表示小圆、逆时针 |\n| `Q` `q` | `x1 y1 x y`                                 | 绘制一条从当前点到`x, y`控制点为`x1, y1`的二次贝塞尔曲线     |\n| `T` `t` | `x y`                                       | 绘制一条从当前点到`x`,`y`的光滑二次贝塞尔曲线，控制点为前一个`Q`命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。 |\n| `C` `c` | `x1 y1 x2 y2 x y`                           | 绘制一条从当前点到 `x`,`y`控制点为`x1,y1` `x2,y2`的三次贝塞尔曲线 |\n| `S` `s` | `x2 y2 x y`                                 | 绘制一条从当前点到`x,y`的光滑三次贝塞尔曲线。第一个控制点为前一个`C`命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。 |\n\n路径的填充同样可以使用 `fill-rule` 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。\n\n## 八、渐变\n\n### 1. 线性渐变\n\n线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。\n\n线性渐变使用`linearGradient`元素表示：\n\n```xml\n<defs>\n\t<linearGradient id=\"linear\">\n\t\t<stop offset=\"0%\" style=\"stop-color:#ffcc00;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#0099cc;\"></stop>\n\t</linearGradient>\n</defs>\n\t<rect x=\"20\" y=\"20\" width=\"200\" height=\"100\" style=\"fill:url(#linear);stroke:black;\"></rect>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg)\n\n`stop`元素有两个必要属性：`offset`和`stop-color`。`offset`属性用来指定在哪个点的颜色应该等于`stop-color`。`offset`的取值范围0%-100%。\n\n`stop`元素的属性：\n\n| 属性           | 说明                             |\n| -------------- | -------------------------------- |\n| `offset`       | 必需，取值范围 `0%-100%`         |\n| `stop-color`   | 必需，对应 `offset` 位置点的颜色 |\n| `stop-opacity` | 对应 `offset` 位置点的不透明度   |\n\n`linearGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `x1`,`y1`      | 渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右     |\n| `x2`,`y2`      | 渐变的终点位置，使用百分比表示                               |\n| `spreadMethod` | 如果设置的`offset`不能覆盖整个对象，该怎么填充。`pad`: 起点或终点颜色会扩展到对象边缘。`repeat`: 渐变重复起点到终点的过程。`reflect`: 渐变按终点-起点-终点的排列重复。 |\n\n### 2. 径向渐变\n\n径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。\n\n```xml\n<defs>\n\t<radialGradient id=\"radial\" cx=\"50%\" cy=\"50%\" >\n\t\t<stop offset=\"0%\" style=\"stop-color:#f00;\"></stop>\n\t\t<stop offset=\"50%\" style=\"stop-color:#0f0;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#00f;\"></stop>\n\t</radialGradient>\n</defs>\n<rect x=\"20\" y=\"20\" width=\"200\" height=\"200\" style=\"fill:url(#radial);stroke:black;\"></rect>\t\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg)\n\n`radialGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `cx`,`cy`,`r`  | 定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为`50%` |\n| `fx`,`fy`      | `0%`点所处的圆路径的圆心，默认和`cx`,`cy`一样                |\n| `spreadMethod` | `pad`,`repeat`,`reflect` 三个值，用来解决绘制范围没有到达图形边缘的情况。 |\n\n## 九、文本\n\n### 1. 相关术语\n\n| 术语                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 字符                  | `XML`中，字符是指带有一个数字值得一个或多个字节，数字值与`Unidode`标准对应 |\n| 符号                  | 字符的视觉呈现。每个字符可以有多种视觉呈现                   |\n| 字体                  | 代表某个字符集合的一组符号                                   |\n| 基线                  | 字体中所有符号以基线对齐                                     |\n| 上坡度                | 基线到字体中最高字符的顶部距离                               |\n| 下坡度                | 基线到最深字符底部的距离                                     |\n| 大写字母高度、`x`高度 | 大写字母高度是指基线上大写字母的高度，`x`高度是基线到小写字母`x`顶部的高度 |\n\n### 2. 文本元素的基本属性\n\n`text` 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。\n\n| 属性              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| `font-family`     | 以空格分割的一系列字体名称或通用字体名称                     |\n| `font-size`       | 如果有多行文本，则 `font-size` 为平行的两条基线的距离        |\n| `font-weight`     | 两个值：`bold`(粗体)和`nromal`(默认)                         |\n| `font-style`      | 常用的两个值:`italic`(斜体)和`normal`                        |\n| `text-decoration` | 可能的值:`none`,`underline`(下划线),`overline`(上划线),`line-through`(删除线) |\n| `word-spacing`    | 单词之间的距离                                               |\n| `letter-spacing`  | 字母之间的间距                                               |\n| `text-anchor`     | 对齐方式：`start`,`middle`,`end`                             |\n| `textLength`      | 设置文本的长度                                               |\n| `lengthAdjust`    | 在指定了`textLength`时，可以通过`lengthAdjust`属性设置字符的调整方式，值为 `spacing`(默认)时,只调整字符的间距。当值为`spacingAndGlyphs`时，同时调整字符间距和字符本身的大小 |\n\n### 3. tspan元素\n\n`text` 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入`tspan` 元素。`tspan` 元素与`html`的`span`元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。\n\n`tspan`元素除大小，颜色等表现样式之外，还可以设置以下属性：\n\n| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `dx`,`dy`        | `x`和`y`方向的偏移                                           |\n| `x`,`y`          | 对`tspan`进行绝对定位                                        |\n| `rotate`         | 旋转字符，可以同时设置多个值，这些值会依次作用在`tspan`包裹的字母上 |\n| `baseline-shift` | 与`dy`属性设置上下标相比，这个属性更方便，当为`super`时，会上标。`sub` 时为下标。仅仅在所在的`tspan`内有效 |\n\n### 4. 纵向文本\n\n文本一般从左到右排列，如果需要上下排列，则需要使用`writing-mode`属性。\n\n设置`writing-mode`属性值为`tb`(top to bottom)，可以将文本上下排列。\n\n## 5. 文本路径\n\n如果要使得文本沿着某条路径排列，则需要使用`textPath`元素。需要将文本放在`textPath`元素内部，然后使用`textPath`元素的`xlink:href`属性引用一个定义好的`path`元素。\n\n```xml\n<defs>\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n</defs>\n<g transform=\"translate(10,50)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n<g transform=\"translate(10,100)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\" startOffset=\"50%\" text-anchor=\"middle\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg)\n\n`startOffset`属性用来指定文本的起点，当设置为`50%`，并且设置`text-anchor`为`middle`时，文本会被定为在`path`的中间。","source":"_posts/svg.md","raw":"---\ntitle: svg相关笔记\ntag: svg\nkeywords: svg\ncategories: 前端可视化库\n---\n## 一、入门指南\n\n### 1. 图形系统\n\n计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。\n\n### 2. SVG(Scalable Vector Graphics)\n\nSVG` 是一种 `XML` 应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的 `XML` 和 `SVG` 版本都为 `1.1\n\nSVG文档结构是标准的 `XML` 文档，根元素 `svg` 定义图形的大小，根元素中包含各种的形状元素。`SVG` 允许使用单独的属性指定元素的样式。\n\n`SVG` 使用 `g` 元素对图形进行分组，使用 `use` 元素实现元素的复用。\n\n## 二、在网页中使用\n\n### 1. 将SVG作为图像\n\n将 `svg` 作为图像包含在HTML标记的 `img` 元素内，但是这样有一定的局限性：\n\n**`SVG`转为栅格图像时与主页面分离，并且无法在两者之间通信( `SVG` 渲染过程与主页面独立)。主页面上的样式对 `SVG` 无效，运行在主页面上的脚本无法感知或者修改 `SVG` 文档结构。**\n\n在 `CSS` 中包含 `SVG`，最常用的是 `background-image` 属性，应该避免 `SVG` 元素文件太大。\n\n###  2. 将SVG作为应用程序\n\n使用 `object` 元素将 `SVG` 嵌入 `HTML` 文档中，`object`元素的 `type` 属性表示要嵌入的文档类型，对用 `SVG` 应该是`type=\"image/svg+xml\"`。`object` 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。\n\n## 三、坐标系统\n\n###  1. 视口\n\n视口是指文档打算使用的画布区域。在 `svg` 元素上使用 `width` 和 `height` 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为`em`、`ex`、`px`、`pt`、`pc`、`cm`、`mm` 和 `in`)也可以为百分比。\n\n### 2. 默认用户坐标\n\n`SVG` 阅读器会设置一个坐标系统，即原点 `(0,0)` 位于视口的左上角，`x` 向右递增，`y` 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。\n\n在 `SVG` 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 `SVG` 文档中各个元素的单位可以不统一。\n\n### 3. 指定用户坐标\n\n摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 `svg` 元素上设置 `viewBox` 属性。\n\n`viewBox` 属性由 `4` 个数值组成，分别代表要叠加在视口上的最小 `x`、最小 `y`，宽度、高度。\n\n既然可以对 `svg` 自定义用户坐标，那么肯定要解决 `svg` 视口长宽比例和 `viewBox` 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 `preserveAspectRatio` 属性了。\n\n如果 `viewBox` 的长宽比例与视口的长宽比例不同，那么 `svg` 可以有以下三种选择：\n\n- 按较小的尺寸等比例缩放图形，使图形完全填充视口\n- 按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分\n- 拉伸和压缩绘图以使其恰好填充视口\n\n```\npreserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = \"alignment[meet|slice]\"\n```\n\n默认值为 `\"xMidYMid meet\"`\n\n`alignment`指定轴和位置，`x` 和 `y` 方向都有 `min`, `mid`, `max` 三种方式，分别表示 `x` 和 `y` 方向的对齐方式，对齐方式由 `x` 和 `y` 组合指定，共 `9` 中方式，也就是 `alignment` 共有如下 `9` 个取值：\n\n| y\\x      | xMin     | xMid     | xMax     |\n| -------- | -------- | -------- | -------- |\n| **yMin** | xMinYMin | xMidYMin | xMaxYMin |\n| **yMid** | xMinYMid | xMidYMid | xMaxYMid |\n| **yMax** | xMinYMax | xMidYMax | xMaxYMax |\n\n`meet` 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间\n\n`slice` 说明符直接裁剪超出视口的部分\n\n除了上述操作之外，还可以指定 `preserveAspectRatio=\"none\"`，用于在 `viewBox` 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。\n\n### 4. 嵌套坐标系统\n\n可以将另一个 `svg` 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 `svg` 中可以嵌套另一个 `svg`，每个 `svg` 都有自己独立的视口和坐标系统\n\n## 四、基本形状\n\n###  1. 线段\n\n`line` 元素，使用 `x1`, `y1`, `x2`, `y2` 属性指定线段的起止点坐标。有如下特性:\n\n| 特性               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| `stroke-width`     | 笔画宽度，坐标网格线位于笔画的正中间，可以使用 `css` 的 `shape-rendering` 值来控制反锯齿特性 |\n| `stroke`           | 笔画颜色                                                     |\n| `stroke-opacity`   | 线条的不透明度                                               |\n| `stroke-dasharray` | 虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙... |\n\n### 2. 矩形\n\n`rect`元素，使用`x`,`y`,`width`,`height`表示一个矩形\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内 |\n| `rx`/`ry`      | 圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值 |\n\n### 3. 圆和椭圆\n\n`circle` 元素表示圆,由 `cx`,`cy`,`r` 属性界定 `ellipse` 元素表示椭圆,由 `cx`,`cy`,`rx`,`ry` 界定\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内 |\n\n### 4. 多边形\n\n`polygon` 元素指定一个多边形,由 `points` 属性指定的一系列坐标点界定，会自动封闭\n\n| 特性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `fill`         | 填充颜色                                                     |\n| `fill-opacity` | 填充不透明度                                                 |\n| `stroke`       | 边框颜色                                                     |\n| `stroke-width` | 边框宽度                                                     |\n| `fill-rule`    | 填充规则，如果多边形的边有交叉时，需要指定，可以取 `mozero`(默认)和 `evenodd` 两个值。 |\n\n`fill-rule` 值为 `nonzero` 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 `1`，如果是从左往右则总数减 `1`. 如果最后总数为 `0` 则认为改点在图形外部，否则在内部。\n\n`fill-rule` 值为 `evenodd` 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。\n\n### 5. 折线\n\n`polyline` 元素表示一个折线，使用 `points` 属性指定一系列点，不自动封闭图形。\n\n### 6. 特性总结\n\n| 特性                | 说明                                               |\n| ------------------- | -------------------------------------------------- |\n| `stroke`            | 笔画颜色                                           |\n| `stroke-width`      | 笔画宽度                                           |\n| `stroke-opacity`    | 笔画不透明度                                       |\n| `stroke-dasharray`  | 虚线笔画                                           |\n| `stroke-linecap`    | 笔画头的形状 `butt`(默认),`round`,`square`         |\n| `stroke-linejoin`   | 图形棱角，有`miter`(默认),`round`和`bevel`三个取值 |\n| `stroke-miterlimit` | 相交处显示宽度与线宽的最大比例，默认为`4`          |\n| `fill`              | 填充颜色 默认`black`                               |\n| `fill-opacity`      | 填充不透明度                                       |\n| `fill-rule`         | 填充规则                                           |\n\n## 五、文档结构\n\n### 1. 结构和表现\n\n`SVG` 允许文档表现和文档结构分离，`SVG` 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性\n\n| 表现方式   | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| 内联样式   | 元素内部使用 `style` 属性                                    |\n| 内部样式表 | 内部样式定义在 `defs` 元素内部                               |\n| 外部样式表 | 与 `html` 类似，将样式定义在 `css` 文件中，使用选择器来设置相应的元素样式 |\n| 表现属性   | `SVG` 允许以属性的形式指定表现样式，但是**表现属性的优先级最低**，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式 |\n\n内部样式表示例：\n\n```xml\n<svg width=\"200px\" height=\"200px\" xmlns=\"http://www.w3.org/2000/svg>\n    <defs>\n        <style type=\"text/css\"><![CDATA[\n            circle{\n                fill:#ccc\n            }\n        ]]></style>\n    </defs>\n    <circle cx=\"10\" cy=\"10\" r=\"5\"/>\n</svg>\n```\n\n### 2. 分组和引用\n\n`g` 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。\n\n`use` 元素用来复用图形中重复出现的元素，需要为 `use` 标签的 `xlink:href` 指定 `URI` 来引用指定的图形元素。同时还要指定`x`和`y`属性以表示组合应该移动到哪个位置。`use`元素并不限制只能使用同一个文件内的对象，`xlink:href`属性可以指定任何有效的文件或`URI`。\n\n`defs`元素用来定义复用的元素，但是定义在`defs`内的元素并不会被显示，而是作为模板供其他地方使用。\n\n`symbol`元素与g元素不同，`symbol`永远不会被显示，也可以用来指定被后续使用的元素，`symbol`元素可以指定 `viewBox` 和`preserveAspectRatio` 属性。在引用时通过为 `use` 元素指定 `width` 和 `height` 属性就可以让 `symbol` 元素适配视口大小。\n\n`image` 可以用来包含一个完整的 `SVG` 或栅格文件。如果包含一个 `SVG` 文件，则视口会基于引用的文件的 `x`,`y`,`width`,`height` 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。\n\n`SVG`规范要求 `SVG` 阅读器支持 `JPEG` 和 `PNG` 两种栅格文件。\n\n## 六、坐标系统变换\n\n### 1. translate变换\n\n`translate` 变换用来对用户坐标进行平移，通过制定 `transform` 属性值来设置: `transform = \"translate(x,y)\"`。\n\n`translate` 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。\n\n### 2. scale变换\n\n缩放坐标系统。`transform = \"scale(value)\"` 或者 `transform=\"scale(x-value,y-value)\"`。\n\n仅仅使用 `scale(n)` 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 `n` 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。\n\n*技巧：如果从其他系统传输数据到 `SVG`，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，`y`向上递增，`x`向右递增。而 `SVG` 坐标原点位于左上角，此时使用 `scale(1,-1)` 就可以完成两者之间的转换。*\n\n**缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。**\n\n### 3. rotate变换\n\n根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，`0` 度为 `3` 点钟方向。\n\n注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： `translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)`\n\n但是有个更简单的方式：`rotate(angle,centerX,centerY)`\n\n### 4. 围绕中心点缩放\n\n上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：\n\n```\ntranslate(-centerX*(factor-1),-centerY*(factor-1)) scale(factor)\n```\n\n### 5. skewX和skewY变换\n\n这两个变换用来倾斜某个轴，一般形式为 `skewX(angle),skewY(angle)`。这样的结果就是使得 `x` 轴和 `y` 轴不再垂直。\n\n### 6. 矩阵变换\n\n计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 `matrix(a,b,c,d,e,f)`，此时指定的变换矩阵为:\n\n```text\na  c  e\nb  d  f\n0  0  1\n```\n\n## 七、路径\n\n### 1. path命令\n\n`SVG` 中所有基本形状都是 `path` 的简写形式，但是建议使用简写形式，因为这样可以使 `SVG` 文档更可读。\n\n`path` 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。\n\n下表为 `path` 命令总结，其中大写表示绝对坐标，小写表示相对坐标：\n\n| 命令    | 参数                                        | 说明                                                         |\n| ------- | ------------------------------------------- | ------------------------------------------------------------ |\n| `M` `m` | `x y`                                       | 移动画笔到制定坐标                                           |\n| `L` `l` | `x y`                                       | 绘制一条到给定坐标的线                                       |\n| `H` `h` | `x`                                         | 绘制一条到给定 `x` 坐标的横线                                |\n| `V` `v` | `y`                                         | 绘制一条到给定`y`坐标的垂线                                  |\n| `A` `a` | `rx ry x-axis-rotation large-arc sweep x y` | 圆弧曲线命令有7个参数，依次表示`x`方向半径、`y`方向半径、旋转角度、大圆标识、顺逆时针标识、目标点`x`、目标点`y`。大圆标识和顺逆时针以`0`和`1`表示。`0`表示小圆、逆时针 |\n| `Q` `q` | `x1 y1 x y`                                 | 绘制一条从当前点到`x, y`控制点为`x1, y1`的二次贝塞尔曲线     |\n| `T` `t` | `x y`                                       | 绘制一条从当前点到`x`,`y`的光滑二次贝塞尔曲线，控制点为前一个`Q`命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。 |\n| `C` `c` | `x1 y1 x2 y2 x y`                           | 绘制一条从当前点到 `x`,`y`控制点为`x1,y1` `x2,y2`的三次贝塞尔曲线 |\n| `S` `s` | `x2 y2 x y`                                 | 绘制一条从当前点到`x,y`的光滑三次贝塞尔曲线。第一个控制点为前一个`C`命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。 |\n\n路径的填充同样可以使用 `fill-rule` 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。\n\n## 八、渐变\n\n### 1. 线性渐变\n\n线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。\n\n线性渐变使用`linearGradient`元素表示：\n\n```xml\n<defs>\n\t<linearGradient id=\"linear\">\n\t\t<stop offset=\"0%\" style=\"stop-color:#ffcc00;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#0099cc;\"></stop>\n\t</linearGradient>\n</defs>\n\t<rect x=\"20\" y=\"20\" width=\"200\" height=\"100\" style=\"fill:url(#linear);stroke:black;\"></rect>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg)\n\n`stop`元素有两个必要属性：`offset`和`stop-color`。`offset`属性用来指定在哪个点的颜色应该等于`stop-color`。`offset`的取值范围0%-100%。\n\n`stop`元素的属性：\n\n| 属性           | 说明                             |\n| -------------- | -------------------------------- |\n| `offset`       | 必需，取值范围 `0%-100%`         |\n| `stop-color`   | 必需，对应 `offset` 位置点的颜色 |\n| `stop-opacity` | 对应 `offset` 位置点的不透明度   |\n\n`linearGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `x1`,`y1`      | 渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右     |\n| `x2`,`y2`      | 渐变的终点位置，使用百分比表示                               |\n| `spreadMethod` | 如果设置的`offset`不能覆盖整个对象，该怎么填充。`pad`: 起点或终点颜色会扩展到对象边缘。`repeat`: 渐变重复起点到终点的过程。`reflect`: 渐变按终点-起点-终点的排列重复。 |\n\n### 2. 径向渐变\n\n径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。\n\n```xml\n<defs>\n\t<radialGradient id=\"radial\" cx=\"50%\" cy=\"50%\" >\n\t\t<stop offset=\"0%\" style=\"stop-color:#f00;\"></stop>\n\t\t<stop offset=\"50%\" style=\"stop-color:#0f0;\"></stop>\n\t\t<stop offset=\"100%\" style=\"stop-color:#00f;\"></stop>\n\t</radialGradient>\n</defs>\n<rect x=\"20\" y=\"20\" width=\"200\" height=\"200\" style=\"fill:url(#radial);stroke:black;\"></rect>\t\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg)\n\n`radialGradient`元素属性：\n\n| 属性           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `cx`,`cy`,`r`  | 定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为`50%` |\n| `fx`,`fy`      | `0%`点所处的圆路径的圆心，默认和`cx`,`cy`一样                |\n| `spreadMethod` | `pad`,`repeat`,`reflect` 三个值，用来解决绘制范围没有到达图形边缘的情况。 |\n\n## 九、文本\n\n### 1. 相关术语\n\n| 术语                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| 字符                  | `XML`中，字符是指带有一个数字值得一个或多个字节，数字值与`Unidode`标准对应 |\n| 符号                  | 字符的视觉呈现。每个字符可以有多种视觉呈现                   |\n| 字体                  | 代表某个字符集合的一组符号                                   |\n| 基线                  | 字体中所有符号以基线对齐                                     |\n| 上坡度                | 基线到字体中最高字符的顶部距离                               |\n| 下坡度                | 基线到最深字符底部的距离                                     |\n| 大写字母高度、`x`高度 | 大写字母高度是指基线上大写字母的高度，`x`高度是基线到小写字母`x`顶部的高度 |\n\n### 2. 文本元素的基本属性\n\n`text` 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。\n\n| 属性              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| `font-family`     | 以空格分割的一系列字体名称或通用字体名称                     |\n| `font-size`       | 如果有多行文本，则 `font-size` 为平行的两条基线的距离        |\n| `font-weight`     | 两个值：`bold`(粗体)和`nromal`(默认)                         |\n| `font-style`      | 常用的两个值:`italic`(斜体)和`normal`                        |\n| `text-decoration` | 可能的值:`none`,`underline`(下划线),`overline`(上划线),`line-through`(删除线) |\n| `word-spacing`    | 单词之间的距离                                               |\n| `letter-spacing`  | 字母之间的间距                                               |\n| `text-anchor`     | 对齐方式：`start`,`middle`,`end`                             |\n| `textLength`      | 设置文本的长度                                               |\n| `lengthAdjust`    | 在指定了`textLength`时，可以通过`lengthAdjust`属性设置字符的调整方式，值为 `spacing`(默认)时,只调整字符的间距。当值为`spacingAndGlyphs`时，同时调整字符间距和字符本身的大小 |\n\n### 3. tspan元素\n\n`text` 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入`tspan` 元素。`tspan` 元素与`html`的`span`元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。\n\n`tspan`元素除大小，颜色等表现样式之外，还可以设置以下属性：\n\n| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `dx`,`dy`        | `x`和`y`方向的偏移                                           |\n| `x`,`y`          | 对`tspan`进行绝对定位                                        |\n| `rotate`         | 旋转字符，可以同时设置多个值，这些值会依次作用在`tspan`包裹的字母上 |\n| `baseline-shift` | 与`dy`属性设置上下标相比，这个属性更方便，当为`super`时，会上标。`sub` 时为下标。仅仅在所在的`tspan`内有效 |\n\n### 4. 纵向文本\n\n文本一般从左到右排列，如果需要上下排列，则需要使用`writing-mode`属性。\n\n设置`writing-mode`属性值为`tb`(top to bottom)，可以将文本上下排列。\n\n## 5. 文本路径\n\n如果要使得文本沿着某条路径排列，则需要使用`textPath`元素。需要将文本放在`textPath`元素内部，然后使用`textPath`元素的`xlink:href`属性引用一个定义好的`path`元素。\n\n```xml\n<defs>\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n</defs>\n<g transform=\"translate(10,50)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n<g transform=\"translate(10,100)\">\n\t<path id=\"path\" d=\"M30 40 C 50 10 ,70 10,120 40 S150 0,200 40\" style=\"fill:none;stroke:black\"></path>\n\t<text>\n\t\t<textPath xlink:href=\"#path\" startOffset=\"50%\" text-anchor=\"middle\">\n\t\t\thello world\n\t\t</textPath>\n\t</text>\n</g>\n```\n\n![img](http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg)\n\n`startOffset`属性用来指定文本的起点，当设置为`50%`，并且设置`text-anchor`为`middle`时，文本会被定为在`path`的中间。","slug":"svg","published":1,"date":"2021-09-22T03:34:56.188Z","updated":"2021-10-12T03:01:44.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9ky000li02488sz67n4","content":"<h2 id=\"一、入门指南\"><a href=\"#一、入门指南\" class=\"headerlink\" title=\"一、入门指南\"></a>一、入门指南</h2><h3 id=\"1-图形系统\"><a href=\"#1-图形系统\" class=\"headerlink\" title=\"1. 图形系统\"></a>1. 图形系统</h3><p>计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。</p>\n<h3 id=\"2-SVG-Scalable-Vector-Graphics\"><a href=\"#2-SVG-Scalable-Vector-Graphics\" class=\"headerlink\" title=\"2. SVG(Scalable Vector Graphics)\"></a>2. SVG(Scalable Vector Graphics)</h3><p>SVG<code>是一种</code>XML<code>应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的</code>XML<code>和</code>SVG<code>版本都为</code>1.1</p>\n<p>SVG文档结构是标准的 <code>XML</code> 文档，根元素 <code>svg</code> 定义图形的大小，根元素中包含各种的形状元素。<code>SVG</code> 允许使用单独的属性指定元素的样式。</p>\n<p><code>SVG</code> 使用 <code>g</code> 元素对图形进行分组，使用 <code>use</code> 元素实现元素的复用。</p>\n<h2 id=\"二、在网页中使用\"><a href=\"#二、在网页中使用\" class=\"headerlink\" title=\"二、在网页中使用\"></a>二、在网页中使用</h2><h3 id=\"1-将SVG作为图像\"><a href=\"#1-将SVG作为图像\" class=\"headerlink\" title=\"1. 将SVG作为图像\"></a>1. 将SVG作为图像</h3><p>将 <code>svg</code> 作为图像包含在HTML标记的 <code>img</code> 元素内，但是这样有一定的局限性：</p>\n<p><strong><code>SVG</code>转为栅格图像时与主页面分离，并且无法在两者之间通信( <code>SVG</code> 渲染过程与主页面独立)。主页面上的样式对 <code>SVG</code> 无效，运行在主页面上的脚本无法感知或者修改 <code>SVG</code> 文档结构。</strong></p>\n<p>在 <code>CSS</code> 中包含 <code>SVG</code>，最常用的是 <code>background-image</code> 属性，应该避免 <code>SVG</code> 元素文件太大。</p>\n<h3 id=\"2-将SVG作为应用程序\"><a href=\"#2-将SVG作为应用程序\" class=\"headerlink\" title=\"2. 将SVG作为应用程序\"></a>2. 将SVG作为应用程序</h3><p>使用 <code>object</code> 元素将 <code>SVG</code> 嵌入 <code>HTML</code> 文档中，<code>object</code>元素的 <code>type</code> 属性表示要嵌入的文档类型，对用 <code>SVG</code> 应该是<code>type=&quot;image/svg+xml&quot;</code>。<code>object</code> 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。</p>\n<h2 id=\"三、坐标系统\"><a href=\"#三、坐标系统\" class=\"headerlink\" title=\"三、坐标系统\"></a>三、坐标系统</h2><h3 id=\"1-视口\"><a href=\"#1-视口\" class=\"headerlink\" title=\"1. 视口\"></a>1. 视口</h3><p>视口是指文档打算使用的画布区域。在 <code>svg</code> 元素上使用 <code>width</code> 和 <code>height</code> 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为<code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code> 和 <code>in</code>)也可以为百分比。</p>\n<h3 id=\"2-默认用户坐标\"><a href=\"#2-默认用户坐标\" class=\"headerlink\" title=\"2. 默认用户坐标\"></a>2. 默认用户坐标</h3><p><code>SVG</code> 阅读器会设置一个坐标系统，即原点 <code>(0,0)</code> 位于视口的左上角，<code>x</code> 向右递增，<code>y</code> 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。</p>\n<p>在 <code>SVG</code> 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 <code>SVG</code> 文档中各个元素的单位可以不统一。</p>\n<h3 id=\"3-指定用户坐标\"><a href=\"#3-指定用户坐标\" class=\"headerlink\" title=\"3. 指定用户坐标\"></a>3. 指定用户坐标</h3><p>摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 <code>svg</code> 元素上设置 <code>viewBox</code> 属性。</p>\n<p><code>viewBox</code> 属性由 <code>4</code> 个数值组成，分别代表要叠加在视口上的最小 <code>x</code>、最小 <code>y</code>，宽度、高度。</p>\n<p>既然可以对 <code>svg</code> 自定义用户坐标，那么肯定要解决 <code>svg</code> 视口长宽比例和 <code>viewBox</code> 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 <code>preserveAspectRatio</code> 属性了。</p>\n<p>如果 <code>viewBox</code> 的长宽比例与视口的长宽比例不同，那么 <code>svg</code> 可以有以下三种选择：</p>\n<ul>\n<li>按较小的尺寸等比例缩放图形，使图形完全填充视口</li>\n<li>按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分</li>\n<li>拉伸和压缩绘图以使其恰好填充视口</li>\n</ul>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">preserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = <span class=\"hljs-string\">&quot;alignment[meet|slice]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>默认值为 <code>&quot;xMidYMid meet&quot;</code></p>\n<p><code>alignment</code>指定轴和位置，<code>x</code> 和 <code>y</code> 方向都有 <code>min</code>, <code>mid</code>, <code>max</code> 三种方式，分别表示 <code>x</code> 和 <code>y</code> 方向的对齐方式，对齐方式由 <code>x</code> 和 <code>y</code> 组合指定，共 <code>9</code> 中方式，也就是 <code>alignment</code> 共有如下 <code>9</code> 个取值：</p>\n<table>\n<thead>\n<tr>\n<th>y\\x</th>\n<th>xMin</th>\n<th>xMid</th>\n<th>xMax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>yMin</strong></td>\n<td>xMinYMin</td>\n<td>xMidYMin</td>\n<td>xMaxYMin</td>\n</tr>\n<tr>\n<td><strong>yMid</strong></td>\n<td>xMinYMid</td>\n<td>xMidYMid</td>\n<td>xMaxYMid</td>\n</tr>\n<tr>\n<td><strong>yMax</strong></td>\n<td>xMinYMax</td>\n<td>xMidYMax</td>\n<td>xMaxYMax</td>\n</tr>\n</tbody></table>\n<p><code>meet</code> 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间</p>\n<p><code>slice</code> 说明符直接裁剪超出视口的部分</p>\n<p>除了上述操作之外，还可以指定 <code>preserveAspectRatio=&quot;none&quot;</code>，用于在 <code>viewBox</code> 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。</p>\n<h3 id=\"4-嵌套坐标系统\"><a href=\"#4-嵌套坐标系统\" class=\"headerlink\" title=\"4. 嵌套坐标系统\"></a>4. 嵌套坐标系统</h3><p>可以将另一个 <code>svg</code> 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 <code>svg</code> 中可以嵌套另一个 <code>svg</code>，每个 <code>svg</code> 都有自己独立的视口和坐标系统</p>\n<h2 id=\"四、基本形状\"><a href=\"#四、基本形状\" class=\"headerlink\" title=\"四、基本形状\"></a>四、基本形状</h2><h3 id=\"1-线段\"><a href=\"#1-线段\" class=\"headerlink\" title=\"1. 线段\"></a>1. 线段</h3><p><code>line</code> 元素，使用 <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> 属性指定线段的起止点坐标。有如下特性:</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度，坐标网格线位于笔画的正中间，可以使用 <code>css</code> 的 <code>shape-rendering</code> 值来控制反锯齿特性</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>线条的不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙…</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-矩形\"><a href=\"#2-矩形\" class=\"headerlink\" title=\"2. 矩形\"></a>2. 矩形</h3><p><code>rect</code>元素，使用<code>x</code>,<code>y</code>,<code>width</code>,<code>height</code>表示一个矩形</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内</td>\n</tr>\n<tr>\n<td><code>rx</code>/<code>ry</code></td>\n<td>圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-圆和椭圆\"><a href=\"#3-圆和椭圆\" class=\"headerlink\" title=\"3. 圆和椭圆\"></a>3. 圆和椭圆</h3><p><code>circle</code> 元素表示圆,由 <code>cx</code>,<code>cy</code>,<code>r</code> 属性界定 <code>ellipse</code> 元素表示椭圆,由 <code>cx</code>,<code>cy</code>,<code>rx</code>,<code>ry</code> 界定</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-多边形\"><a href=\"#4-多边形\" class=\"headerlink\" title=\"4. 多边形\"></a>4. 多边形</h3><p><code>polygon</code> 元素指定一个多边形,由 <code>points</code> 属性指定的一系列坐标点界定，会自动封闭</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则，如果多边形的边有交叉时，需要指定，可以取 <code>mozero</code>(默认)和 <code>evenodd</code> 两个值。</td>\n</tr>\n</tbody></table>\n<p><code>fill-rule</code> 值为 <code>nonzero</code> 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 <code>1</code>，如果是从左往右则总数减 <code>1</code>. 如果最后总数为 <code>0</code> 则认为改点在图形外部，否则在内部。</p>\n<p><code>fill-rule</code> 值为 <code>evenodd</code> 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。</p>\n<h3 id=\"5-折线\"><a href=\"#5-折线\" class=\"headerlink\" title=\"5. 折线\"></a>5. 折线</h3><p><code>polyline</code> 元素表示一个折线，使用 <code>points</code> 属性指定一系列点，不自动封闭图形。</p>\n<h3 id=\"6-特性总结\"><a href=\"#6-特性总结\" class=\"headerlink\" title=\"6. 特性总结\"></a>6. 特性总结</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>笔画不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线笔画</td>\n</tr>\n<tr>\n<td><code>stroke-linecap</code></td>\n<td>笔画头的形状 <code>butt</code>(默认),<code>round</code>,<code>square</code></td>\n</tr>\n<tr>\n<td><code>stroke-linejoin</code></td>\n<td>图形棱角，有<code>miter</code>(默认),<code>round</code>和<code>bevel</code>三个取值</td>\n</tr>\n<tr>\n<td><code>stroke-miterlimit</code></td>\n<td>相交处显示宽度与线宽的最大比例，默认为<code>4</code></td>\n</tr>\n<tr>\n<td><code>fill</code></td>\n<td>填充颜色 默认<code>black</code></td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、文档结构\"><a href=\"#五、文档结构\" class=\"headerlink\" title=\"五、文档结构\"></a>五、文档结构</h2><h3 id=\"1-结构和表现\"><a href=\"#1-结构和表现\" class=\"headerlink\" title=\"1. 结构和表现\"></a>1. 结构和表现</h3><p><code>SVG</code> 允许文档表现和文档结构分离，<code>SVG</code> 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性</p>\n<table>\n<thead>\n<tr>\n<th>表现方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内联样式</td>\n<td>元素内部使用 <code>style</code> 属性</td>\n</tr>\n<tr>\n<td>内部样式表</td>\n<td>内部样式定义在 <code>defs</code> 元素内部</td>\n</tr>\n<tr>\n<td>外部样式表</td>\n<td>与 <code>html</code> 类似，将样式定义在 <code>css</code> 文件中，使用选择器来设置相应的元素样式</td>\n</tr>\n<tr>\n<td>表现属性</td>\n<td><code>SVG</code> 允许以属性的形式指定表现样式，但是<strong>表现属性的优先级最低</strong>，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式</td>\n</tr>\n</tbody></table>\n<p>内部样式表示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2000/svg&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    &lt;defs&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">        &lt;style type=&quot;</span><span class=\"hljs-attr\">text</span>/<span class=\"hljs-attr\">css</span>&quot;&gt;</span>&lt;![CDATA[<br>            circle&#123;<br>                fill:#ccc<br>            &#125;<br>        ]]&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;5&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-分组和引用\"><a href=\"#2-分组和引用\" class=\"headerlink\" title=\"2. 分组和引用\"></a>2. 分组和引用</h3><p><code>g</code> 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。</p>\n<p><code>use</code> 元素用来复用图形中重复出现的元素，需要为 <code>use</code> 标签的 <code>xlink:href</code> 指定 <code>URI</code> 来引用指定的图形元素。同时还要指定<code>x</code>和<code>y</code>属性以表示组合应该移动到哪个位置。<code>use</code>元素并不限制只能使用同一个文件内的对象，<code>xlink:href</code>属性可以指定任何有效的文件或<code>URI</code>。</p>\n<p><code>defs</code>元素用来定义复用的元素，但是定义在<code>defs</code>内的元素并不会被显示，而是作为模板供其他地方使用。</p>\n<p><code>symbol</code>元素与g元素不同，<code>symbol</code>永远不会被显示，也可以用来指定被后续使用的元素，<code>symbol</code>元素可以指定 <code>viewBox</code> 和<code>preserveAspectRatio</code> 属性。在引用时通过为 <code>use</code> 元素指定 <code>width</code> 和 <code>height</code> 属性就可以让 <code>symbol</code> 元素适配视口大小。</p>\n<p><code>image</code> 可以用来包含一个完整的 <code>SVG</code> 或栅格文件。如果包含一个 <code>SVG</code> 文件，则视口会基于引用的文件的 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。</p>\n<p><code>SVG</code>规范要求 <code>SVG</code> 阅读器支持 <code>JPEG</code> 和 <code>PNG</code> 两种栅格文件。</p>\n<h2 id=\"六、坐标系统变换\"><a href=\"#六、坐标系统变换\" class=\"headerlink\" title=\"六、坐标系统变换\"></a>六、坐标系统变换</h2><h3 id=\"1-translate变换\"><a href=\"#1-translate变换\" class=\"headerlink\" title=\"1. translate变换\"></a>1. translate变换</h3><p><code>translate</code> 变换用来对用户坐标进行平移，通过制定 <code>transform</code> 属性值来设置: <code>transform = &quot;translate(x,y)&quot;</code>。</p>\n<p><code>translate</code> 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。</p>\n<h3 id=\"2-scale变换\"><a href=\"#2-scale变换\" class=\"headerlink\" title=\"2. scale变换\"></a>2. scale变换</h3><p>缩放坐标系统。<code>transform = &quot;scale(value)&quot;</code> 或者 <code>transform=&quot;scale(x-value,y-value)&quot;</code>。</p>\n<p>仅仅使用 <code>scale(n)</code> 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 <code>n</code> 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。</p>\n<p><em>技巧：如果从其他系统传输数据到 <code>SVG</code>，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，<code>y</code>向上递增，<code>x</code>向右递增。而 <code>SVG</code> 坐标原点位于左上角，此时使用 <code>scale(1,-1)</code> 就可以完成两者之间的转换。</em></p>\n<p><strong>缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。</strong></p>\n<h3 id=\"3-rotate变换\"><a href=\"#3-rotate变换\" class=\"headerlink\" title=\"3. rotate变换\"></a>3. rotate变换</h3><p>根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，<code>0</code> 度为 <code>3</code> 点钟方向。</p>\n<p>注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： <code>translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)</code></p>\n<p>但是有个更简单的方式：<code>rotate(angle,centerX,centerY)</code></p>\n<h3 id=\"4-围绕中心点缩放\"><a href=\"#4-围绕中心点缩放\" class=\"headerlink\" title=\"4. 围绕中心点缩放\"></a>4. 围绕中心点缩放</h3><p>上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">translate</span>(-centerX*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>),-centerY*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>)) <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-built_in\">factor</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-skewX和skewY变换\"><a href=\"#5-skewX和skewY变换\" class=\"headerlink\" title=\"5. skewX和skewY变换\"></a>5. skewX和skewY变换</h3><p>这两个变换用来倾斜某个轴，一般形式为 <code>skewX(angle),skewY(angle)</code>。这样的结果就是使得 <code>x</code> 轴和 <code>y</code> 轴不再垂直。</p>\n<h3 id=\"6-矩阵变换\"><a href=\"#6-矩阵变换\" class=\"headerlink\" title=\"6. 矩阵变换\"></a>6. 矩阵变换</h3><p>计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 <code>matrix(a,b,c,d,e,f)</code>，此时指定的变换矩阵为:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">a  c  e<br>b  d  f<br>0  0  1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、路径\"><a href=\"#七、路径\" class=\"headerlink\" title=\"七、路径\"></a>七、路径</h2><h3 id=\"1-path命令\"><a href=\"#1-path命令\" class=\"headerlink\" title=\"1. path命令\"></a>1. path命令</h3><p><code>SVG</code> 中所有基本形状都是 <code>path</code> 的简写形式，但是建议使用简写形式，因为这样可以使 <code>SVG</code> 文档更可读。</p>\n<p><code>path</code> 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。</p>\n<p>下表为 <code>path</code> 命令总结，其中大写表示绝对坐标，小写表示相对坐标：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>M</code> <code>m</code></td>\n<td><code>x y</code></td>\n<td>移动画笔到制定坐标</td>\n</tr>\n<tr>\n<td><code>L</code> <code>l</code></td>\n<td><code>x y</code></td>\n<td>绘制一条到给定坐标的线</td>\n</tr>\n<tr>\n<td><code>H</code> <code>h</code></td>\n<td><code>x</code></td>\n<td>绘制一条到给定 <code>x</code> 坐标的横线</td>\n</tr>\n<tr>\n<td><code>V</code> <code>v</code></td>\n<td><code>y</code></td>\n<td>绘制一条到给定<code>y</code>坐标的垂线</td>\n</tr>\n<tr>\n<td><code>A</code> <code>a</code></td>\n<td><code>rx ry x-axis-rotation large-arc sweep x y</code></td>\n<td>圆弧曲线命令有7个参数，依次表示<code>x</code>方向半径、<code>y</code>方向半径、旋转角度、大圆标识、顺逆时针标识、目标点<code>x</code>、目标点<code>y</code>。大圆标识和顺逆时针以<code>0</code>和<code>1</code>表示。<code>0</code>表示小圆、逆时针</td>\n</tr>\n<tr>\n<td><code>Q</code> <code>q</code></td>\n<td><code>x1 y1 x y</code></td>\n<td>绘制一条从当前点到<code>x, y</code>控制点为<code>x1, y1</code>的二次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>T</code> <code>t</code></td>\n<td><code>x y</code></td>\n<td>绘制一条从当前点到<code>x</code>,<code>y</code>的光滑二次贝塞尔曲线，控制点为前一个<code>Q</code>命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。</td>\n</tr>\n<tr>\n<td><code>C</code> <code>c</code></td>\n<td><code>x1 y1 x2 y2 x y</code></td>\n<td>绘制一条从当前点到 <code>x</code>,<code>y</code>控制点为<code>x1,y1</code> <code>x2,y2</code>的三次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>S</code> <code>s</code></td>\n<td><code>x2 y2 x y</code></td>\n<td>绘制一条从当前点到<code>x,y</code>的光滑三次贝塞尔曲线。第一个控制点为前一个<code>C</code>命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。</td>\n</tr>\n</tbody></table>\n<p>路径的填充同样可以使用 <code>fill-rule</code> 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。</p>\n<h2 id=\"八、渐变\"><a href=\"#八、渐变\" class=\"headerlink\" title=\"八、渐变\"></a>八、渐变</h2><h3 id=\"1-线性渐变\"><a href=\"#1-线性渐变\" class=\"headerlink\" title=\"1. 线性渐变\"></a>1. 线性渐变</h3><p>线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。</p>\n<p>线性渐变使用<code>linearGradient</code>元素表示：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">linearGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;linear&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#ffcc00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0099cc;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">linearGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#linear);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg\" alt=\"img\"></p>\n<p><code>stop</code>元素有两个必要属性：<code>offset</code>和<code>stop-color</code>。<code>offset</code>属性用来指定在哪个点的颜色应该等于<code>stop-color</code>。<code>offset</code>的取值范围0%-100%。</p>\n<p><code>stop</code>元素的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>offset</code></td>\n<td>必需，取值范围 <code>0%-100%</code></td>\n</tr>\n<tr>\n<td><code>stop-color</code></td>\n<td>必需，对应 <code>offset</code> 位置点的颜色</td>\n</tr>\n<tr>\n<td><code>stop-opacity</code></td>\n<td>对应 <code>offset</code> 位置点的不透明度</td>\n</tr>\n</tbody></table>\n<p><code>linearGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>x1</code>,<code>y1</code></td>\n<td>渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右</td>\n</tr>\n<tr>\n<td><code>x2</code>,<code>y2</code></td>\n<td>渐变的终点位置，使用百分比表示</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td>如果设置的<code>offset</code>不能覆盖整个对象，该怎么填充。<code>pad</code>: 起点或终点颜色会扩展到对象边缘。<code>repeat</code>: 渐变重复起点到终点的过程。<code>reflect</code>: 渐变按终点-起点-终点的排列重复。</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-径向渐变\"><a href=\"#2-径向渐变\" class=\"headerlink\" title=\"2. 径向渐变\"></a>2. 径向渐变</h3><p>径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">radialGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;radial&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> &gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#f00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0f0;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#00f;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">radialGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#radial);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\t<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg\" alt=\"img\"></p>\n<p><code>radialGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cx</code>,<code>cy</code>,<code>r</code></td>\n<td>定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为<code>50%</code></td>\n</tr>\n<tr>\n<td><code>fx</code>,<code>fy</code></td>\n<td><code>0%</code>点所处的圆路径的圆心，默认和<code>cx</code>,<code>cy</code>一样</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td><code>pad</code>,<code>repeat</code>,<code>reflect</code> 三个值，用来解决绘制范围没有到达图形边缘的情况。</td>\n</tr>\n</tbody></table>\n<h2 id=\"九、文本\"><a href=\"#九、文本\" class=\"headerlink\" title=\"九、文本\"></a>九、文本</h2><h3 id=\"1-相关术语\"><a href=\"#1-相关术语\" class=\"headerlink\" title=\"1. 相关术语\"></a>1. 相关术语</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符</td>\n<td><code>XML</code>中，字符是指带有一个数字值得一个或多个字节，数字值与<code>Unidode</code>标准对应</td>\n</tr>\n<tr>\n<td>符号</td>\n<td>字符的视觉呈现。每个字符可以有多种视觉呈现</td>\n</tr>\n<tr>\n<td>字体</td>\n<td>代表某个字符集合的一组符号</td>\n</tr>\n<tr>\n<td>基线</td>\n<td>字体中所有符号以基线对齐</td>\n</tr>\n<tr>\n<td>上坡度</td>\n<td>基线到字体中最高字符的顶部距离</td>\n</tr>\n<tr>\n<td>下坡度</td>\n<td>基线到最深字符底部的距离</td>\n</tr>\n<tr>\n<td>大写字母高度、<code>x</code>高度</td>\n<td>大写字母高度是指基线上大写字母的高度，<code>x</code>高度是基线到小写字母<code>x</code>顶部的高度</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-文本元素的基本属性\"><a href=\"#2-文本元素的基本属性\" class=\"headerlink\" title=\"2. 文本元素的基本属性\"></a>2. 文本元素的基本属性</h3><p><code>text</code> 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>font-family</code></td>\n<td>以空格分割的一系列字体名称或通用字体名称</td>\n</tr>\n<tr>\n<td><code>font-size</code></td>\n<td>如果有多行文本，则 <code>font-size</code> 为平行的两条基线的距离</td>\n</tr>\n<tr>\n<td><code>font-weight</code></td>\n<td>两个值：<code>bold</code>(粗体)和<code>nromal</code>(默认)</td>\n</tr>\n<tr>\n<td><code>font-style</code></td>\n<td>常用的两个值:<code>italic</code>(斜体)和<code>normal</code></td>\n</tr>\n<tr>\n<td><code>text-decoration</code></td>\n<td>可能的值:<code>none</code>,<code>underline</code>(下划线),<code>overline</code>(上划线),<code>line-through</code>(删除线)</td>\n</tr>\n<tr>\n<td><code>word-spacing</code></td>\n<td>单词之间的距离</td>\n</tr>\n<tr>\n<td><code>letter-spacing</code></td>\n<td>字母之间的间距</td>\n</tr>\n<tr>\n<td><code>text-anchor</code></td>\n<td>对齐方式：<code>start</code>,<code>middle</code>,<code>end</code></td>\n</tr>\n<tr>\n<td><code>textLength</code></td>\n<td>设置文本的长度</td>\n</tr>\n<tr>\n<td><code>lengthAdjust</code></td>\n<td>在指定了<code>textLength</code>时，可以通过<code>lengthAdjust</code>属性设置字符的调整方式，值为 <code>spacing</code>(默认)时,只调整字符的间距。当值为<code>spacingAndGlyphs</code>时，同时调整字符间距和字符本身的大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-tspan元素\"><a href=\"#3-tspan元素\" class=\"headerlink\" title=\"3. tspan元素\"></a>3. tspan元素</h3><p><code>text</code> 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入<code>tspan</code> 元素。<code>tspan</code> 元素与<code>html</code>的<code>span</code>元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。</p>\n<p><code>tspan</code>元素除大小，颜色等表现样式之外，还可以设置以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dx</code>,<code>dy</code></td>\n<td><code>x</code>和<code>y</code>方向的偏移</td>\n</tr>\n<tr>\n<td><code>x</code>,<code>y</code></td>\n<td>对<code>tspan</code>进行绝对定位</td>\n</tr>\n<tr>\n<td><code>rotate</code></td>\n<td>旋转字符，可以同时设置多个值，这些值会依次作用在<code>tspan</code>包裹的字母上</td>\n</tr>\n<tr>\n<td><code>baseline-shift</code></td>\n<td>与<code>dy</code>属性设置上下标相比，这个属性更方便，当为<code>super</code>时，会上标。<code>sub</code> 时为下标。仅仅在所在的<code>tspan</code>内有效</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-纵向文本\"><a href=\"#4-纵向文本\" class=\"headerlink\" title=\"4. 纵向文本\"></a>4. 纵向文本</h3><p>文本一般从左到右排列，如果需要上下排列，则需要使用<code>writing-mode</code>属性。</p>\n<p>设置<code>writing-mode</code>属性值为<code>tb</code>(top to bottom)，可以将文本上下排列。</p>\n<h2 id=\"5-文本路径\"><a href=\"#5-文本路径\" class=\"headerlink\" title=\"5. 文本路径\"></a>5. 文本路径</h2><p>如果要使得文本沿着某条路径排列，则需要使用<code>textPath</code>元素。需要将文本放在<code>textPath</code>元素内部，然后使用<code>textPath</code>元素的<code>xlink:href</code>属性引用一个定义好的<code>path</code>元素。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,50)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,100)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span> <span class=\"hljs-attr\">startOffset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">text-anchor</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg\" alt=\"img\"></p>\n<p><code>startOffset</code>属性用来指定文本的起点，当设置为<code>50%</code>，并且设置<code>text-anchor</code>为<code>middle</code>时，文本会被定为在<code>path</code>的中间。</p>\n","site":{"data":{}},"wordcount":9311,"excerpt":"","more":"<h2 id=\"一、入门指南\"><a href=\"#一、入门指南\" class=\"headerlink\" title=\"一、入门指南\"></a>一、入门指南</h2><h3 id=\"1-图形系统\"><a href=\"#1-图形系统\" class=\"headerlink\" title=\"1. 图形系统\"></a>1. 图形系统</h3><p>计算机中描述图形信息的两大图形系统：栅格图形和矢量图形。栅格图形中图形被表示为图片元素或者像素的长方形数组。矢量图形中图形被描述为一系列几何形状，通过矢量图形阅读器在指定的坐标集上绘制形状。</p>\n<h3 id=\"2-SVG-Scalable-Vector-Graphics\"><a href=\"#2-SVG-Scalable-Vector-Graphics\" class=\"headerlink\" title=\"2. SVG(Scalable Vector Graphics)\"></a>2. SVG(Scalable Vector Graphics)</h3><p>SVG<code>是一种</code>XML<code>应用，用来表示矢量图形。所有的图形有关信息被存储为纯文本，具有XML的开放性、可移植性和可交互性。当前稳定的</code>XML<code>和</code>SVG<code>版本都为</code>1.1</p>\n<p>SVG文档结构是标准的 <code>XML</code> 文档，根元素 <code>svg</code> 定义图形的大小，根元素中包含各种的形状元素。<code>SVG</code> 允许使用单独的属性指定元素的样式。</p>\n<p><code>SVG</code> 使用 <code>g</code> 元素对图形进行分组，使用 <code>use</code> 元素实现元素的复用。</p>\n<h2 id=\"二、在网页中使用\"><a href=\"#二、在网页中使用\" class=\"headerlink\" title=\"二、在网页中使用\"></a>二、在网页中使用</h2><h3 id=\"1-将SVG作为图像\"><a href=\"#1-将SVG作为图像\" class=\"headerlink\" title=\"1. 将SVG作为图像\"></a>1. 将SVG作为图像</h3><p>将 <code>svg</code> 作为图像包含在HTML标记的 <code>img</code> 元素内，但是这样有一定的局限性：</p>\n<p><strong><code>SVG</code>转为栅格图像时与主页面分离，并且无法在两者之间通信( <code>SVG</code> 渲染过程与主页面独立)。主页面上的样式对 <code>SVG</code> 无效，运行在主页面上的脚本无法感知或者修改 <code>SVG</code> 文档结构。</strong></p>\n<p>在 <code>CSS</code> 中包含 <code>SVG</code>，最常用的是 <code>background-image</code> 属性，应该避免 <code>SVG</code> 元素文件太大。</p>\n<h3 id=\"2-将SVG作为应用程序\"><a href=\"#2-将SVG作为应用程序\" class=\"headerlink\" title=\"2. 将SVG作为应用程序\"></a>2. 将SVG作为应用程序</h3><p>使用 <code>object</code> 元素将 <code>SVG</code> 嵌入 <code>HTML</code> 文档中，<code>object</code>元素的 <code>type</code> 属性表示要嵌入的文档类型，对用 <code>SVG</code> 应该是<code>type=&quot;image/svg+xml&quot;</code>。<code>object</code> 元素必须有起始标签和结束标签，这两个标签之间的内容为对象数据本身不能被渲染时显示。</p>\n<h2 id=\"三、坐标系统\"><a href=\"#三、坐标系统\" class=\"headerlink\" title=\"三、坐标系统\"></a>三、坐标系统</h2><h3 id=\"1-视口\"><a href=\"#1-视口\" class=\"headerlink\" title=\"1. 视口\"></a>1. 视口</h3><p>视口是指文档打算使用的画布区域。在 <code>svg</code> 元素上使用 <code>width</code> 和 <code>height</code> 属性确定视口的大小，属性值可以仅仅是为数字也可以为带单位的数字(单位可以为<code>em</code>、<code>ex</code>、<code>px</code>、<code>pt</code>、<code>pc</code>、<code>cm</code>、<code>mm</code> 和 <code>in</code>)也可以为百分比。</p>\n<h3 id=\"2-默认用户坐标\"><a href=\"#2-默认用户坐标\" class=\"headerlink\" title=\"2. 默认用户坐标\"></a>2. 默认用户坐标</h3><p><code>SVG</code> 阅读器会设置一个坐标系统，即原点 <code>(0,0)</code> 位于视口的左上角，<code>x</code> 向右递增，<code>y</code> 向下递增。这个坐标系统是一个纯粹的几何系统，点没有大小，网格线被认为是无限细。</p>\n<p>在 <code>SVG</code> 中指定单位并不会影响其他元素中给定单位的坐标，也就是说 <code>SVG</code> 文档中各个元素的单位可以不统一。</p>\n<h3 id=\"3-指定用户坐标\"><a href=\"#3-指定用户坐标\" class=\"headerlink\" title=\"3. 指定用户坐标\"></a>3. 指定用户坐标</h3><p>摒弃阅读器设置的默认用户坐标，可以自己为视口设置一个用户坐标。通过在 <code>svg</code> 元素上设置 <code>viewBox</code> 属性。</p>\n<p><code>viewBox</code> 属性由 <code>4</code> 个数值组成，分别代表要叠加在视口上的最小 <code>x</code>、最小 <code>y</code>，宽度、高度。</p>\n<p>既然可以对 <code>svg</code> 自定义用户坐标，那么肯定要解决 <code>svg</code> 视口长宽比例和 <code>viewBox</code> 定义的长宽比例不同的问题以及如何对齐问题。这个时候就需要 <code>preserveAspectRatio</code> 属性了。</p>\n<p>如果 <code>viewBox</code> 的长宽比例与视口的长宽比例不同，那么 <code>svg</code> 可以有以下三种选择：</p>\n<ul>\n<li>按较小的尺寸等比例缩放图形，使图形完全填充视口</li>\n<li>按较大的尺寸等比例缩放图形，病裁减掉超出视口的部分</li>\n<li>拉伸和压缩绘图以使其恰好填充视口</li>\n</ul>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\">preserveAspectRatio` 属性允许指定被缩放的图形相对视口的对齐方式,格式为 `preserveAspectRatio = <span class=\"hljs-string\">&quot;alignment[meet|slice]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>默认值为 <code>&quot;xMidYMid meet&quot;</code></p>\n<p><code>alignment</code>指定轴和位置，<code>x</code> 和 <code>y</code> 方向都有 <code>min</code>, <code>mid</code>, <code>max</code> 三种方式，分别表示 <code>x</code> 和 <code>y</code> 方向的对齐方式，对齐方式由 <code>x</code> 和 <code>y</code> 组合指定，共 <code>9</code> 中方式，也就是 <code>alignment</code> 共有如下 <code>9</code> 个取值：</p>\n<table>\n<thead>\n<tr>\n<th>y\\x</th>\n<th>xMin</th>\n<th>xMid</th>\n<th>xMax</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>yMin</strong></td>\n<td>xMinYMin</td>\n<td>xMidYMin</td>\n<td>xMaxYMin</td>\n</tr>\n<tr>\n<td><strong>yMid</strong></td>\n<td>xMinYMid</td>\n<td>xMidYMid</td>\n<td>xMaxYMid</td>\n</tr>\n<tr>\n<td><strong>yMax</strong></td>\n<td>xMinYMax</td>\n<td>xMidYMax</td>\n<td>xMaxYMax</td>\n</tr>\n</tbody></table>\n<p><code>meet</code> 说明符在图形超出视口时候会对图形适当缩小调整适配可用的空间</p>\n<p><code>slice</code> 说明符直接裁剪超出视口的部分</p>\n<p>除了上述操作之外，还可以指定 <code>preserveAspectRatio=&quot;none&quot;</code>，用于在 <code>viewBox</code> 和视口宽高比不同时缩放图像，此时图像不会被等比例缩放，会被拉伸、挤压、变形。</p>\n<h3 id=\"4-嵌套坐标系统\"><a href=\"#4-嵌套坐标系统\" class=\"headerlink\" title=\"4. 嵌套坐标系统\"></a>4. 嵌套坐标系统</h3><p>可以将另一个 <code>svg</code> 元素插入到文档中来建立一个新的视口和坐标系统，也就是说 <code>svg</code> 中可以嵌套另一个 <code>svg</code>，每个 <code>svg</code> 都有自己独立的视口和坐标系统</p>\n<h2 id=\"四、基本形状\"><a href=\"#四、基本形状\" class=\"headerlink\" title=\"四、基本形状\"></a>四、基本形状</h2><h3 id=\"1-线段\"><a href=\"#1-线段\" class=\"headerlink\" title=\"1. 线段\"></a>1. 线段</h3><p><code>line</code> 元素，使用 <code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code> 属性指定线段的起止点坐标。有如下特性:</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度，坐标网格线位于笔画的正中间，可以使用 <code>css</code> 的 <code>shape-rendering</code> 值来控制反锯齿特性</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>线条的不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线，由一系列数字组成，数字个数为偶数(负责会自动重复一遍使其为偶数),表示线长-间隙-线长-间隙…</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-矩形\"><a href=\"#2-矩形\" class=\"headerlink\" title=\"2. 矩形\"></a>2. 矩形</h3><p><code>rect</code>元素，使用<code>x</code>,<code>y</code>,<code>width</code>,<code>height</code>表示一个矩形</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在矩形边界上的，一半在矩形外，一半在矩形内</td>\n</tr>\n<tr>\n<td><code>rx</code>/<code>ry</code></td>\n<td>圆角矩形，最大值为矩形宽/高的一半，如果只指定了一个，则认为两个都为相同的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-圆和椭圆\"><a href=\"#3-圆和椭圆\" class=\"headerlink\" title=\"3. 圆和椭圆\"></a>3. 圆和椭圆</h3><p><code>circle</code> 元素表示圆,由 <code>cx</code>,<code>cy</code>,<code>r</code> 属性界定 <code>ellipse</code> 元素表示椭圆,由 <code>cx</code>,<code>cy</code>,<code>rx</code>,<code>ry</code> 界定</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度，边框是骑在圆的边界上的，一半在圆/椭圆外，一半在圆/椭圆内</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-多边形\"><a href=\"#4-多边形\" class=\"headerlink\" title=\"4. 多边形\"></a>4. 多边形</h3><p><code>polygon</code> 元素指定一个多边形,由 <code>points</code> 属性指定的一系列坐标点界定，会自动封闭</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fill</code></td>\n<td>填充颜色</td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>stroke</code></td>\n<td>边框颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>边框宽度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则，如果多边形的边有交叉时，需要指定，可以取 <code>mozero</code>(默认)和 <code>evenodd</code> 两个值。</td>\n</tr>\n</tbody></table>\n<p><code>fill-rule</code> 值为 <code>nonzero</code> 时的原理:判断一个点是在多边形内部还是外部时，从这个点画一条到无穷远的射线，然后数这个线和多边形的边有多少次交叉。如果交叉的边线是从右往左画，则总数加 <code>1</code>，如果是从左往右则总数减 <code>1</code>. 如果最后总数为 <code>0</code> 则认为改点在图形外部，否则在内部。</p>\n<p><code>fill-rule</code> 值为 <code>evenodd</code> 时只数射线与多边形边的交叉次数，如果为奇数则认为在多边形内部，否则认为在多边形外部。</p>\n<h3 id=\"5-折线\"><a href=\"#5-折线\" class=\"headerlink\" title=\"5. 折线\"></a>5. 折线</h3><p><code>polyline</code> 元素表示一个折线，使用 <code>points</code> 属性指定一系列点，不自动封闭图形。</p>\n<h3 id=\"6-特性总结\"><a href=\"#6-特性总结\" class=\"headerlink\" title=\"6. 特性总结\"></a>6. 特性总结</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>stroke</code></td>\n<td>笔画颜色</td>\n</tr>\n<tr>\n<td><code>stroke-width</code></td>\n<td>笔画宽度</td>\n</tr>\n<tr>\n<td><code>stroke-opacity</code></td>\n<td>笔画不透明度</td>\n</tr>\n<tr>\n<td><code>stroke-dasharray</code></td>\n<td>虚线笔画</td>\n</tr>\n<tr>\n<td><code>stroke-linecap</code></td>\n<td>笔画头的形状 <code>butt</code>(默认),<code>round</code>,<code>square</code></td>\n</tr>\n<tr>\n<td><code>stroke-linejoin</code></td>\n<td>图形棱角，有<code>miter</code>(默认),<code>round</code>和<code>bevel</code>三个取值</td>\n</tr>\n<tr>\n<td><code>stroke-miterlimit</code></td>\n<td>相交处显示宽度与线宽的最大比例，默认为<code>4</code></td>\n</tr>\n<tr>\n<td><code>fill</code></td>\n<td>填充颜色 默认<code>black</code></td>\n</tr>\n<tr>\n<td><code>fill-opacity</code></td>\n<td>填充不透明度</td>\n</tr>\n<tr>\n<td><code>fill-rule</code></td>\n<td>填充规则</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、文档结构\"><a href=\"#五、文档结构\" class=\"headerlink\" title=\"五、文档结构\"></a>五、文档结构</h2><h3 id=\"1-结构和表现\"><a href=\"#1-结构和表现\" class=\"headerlink\" title=\"1. 结构和表现\"></a>1. 结构和表现</h3><p><code>SVG</code> 允许文档表现和文档结构分离，<code>SVG</code> 支持四种方式指定表现信息：内联样式、内部样式表、外部样式表以及表现属性</p>\n<table>\n<thead>\n<tr>\n<th>表现方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内联样式</td>\n<td>元素内部使用 <code>style</code> 属性</td>\n</tr>\n<tr>\n<td>内部样式表</td>\n<td>内部样式定义在 <code>defs</code> 元素内部</td>\n</tr>\n<tr>\n<td>外部样式表</td>\n<td>与 <code>html</code> 类似，将样式定义在 <code>css</code> 文件中，使用选择器来设置相应的元素样式</td>\n</tr>\n<tr>\n<td>表现属性</td>\n<td><code>SVG</code> 允许以属性的形式指定表现样式，但是<strong>表现属性的优先级最低</strong>，如果以其他三种形式指定了相同的样式属性，则将覆盖通过表现属性指定的样式</td>\n</tr>\n</tbody></table>\n<p>内部样式表示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200px&quot;</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">&quot;http://www.w3.org/2000/svg&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">    &lt;defs&gt;</span></span><br><span class=\"hljs-string\"><span class=\"hljs-tag\">        &lt;style type=&quot;</span><span class=\"hljs-attr\">text</span>/<span class=\"hljs-attr\">css</span>&quot;&gt;</span>&lt;![CDATA[<br>            circle&#123;<br>                fill:#ccc<br>            &#125;<br>        ]]&gt;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">circle</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;10&quot;</span> <span class=\"hljs-attr\">r</span>=<span class=\"hljs-string\">&quot;5&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-分组和引用\"><a href=\"#2-分组和引用\" class=\"headerlink\" title=\"2. 分组和引用\"></a>2. 分组和引用</h3><p><code>g</code> 元素用来将其子元素作为一个组合，可以使文档结构更清晰。除此之外，在g标签中指定的所有样式会应用于组合内的所有子元素，可以不用在所有子元素上指定属性。</p>\n<p><code>use</code> 元素用来复用图形中重复出现的元素，需要为 <code>use</code> 标签的 <code>xlink:href</code> 指定 <code>URI</code> 来引用指定的图形元素。同时还要指定<code>x</code>和<code>y</code>属性以表示组合应该移动到哪个位置。<code>use</code>元素并不限制只能使用同一个文件内的对象，<code>xlink:href</code>属性可以指定任何有效的文件或<code>URI</code>。</p>\n<p><code>defs</code>元素用来定义复用的元素，但是定义在<code>defs</code>内的元素并不会被显示，而是作为模板供其他地方使用。</p>\n<p><code>symbol</code>元素与g元素不同，<code>symbol</code>永远不会被显示，也可以用来指定被后续使用的元素，<code>symbol</code>元素可以指定 <code>viewBox</code> 和<code>preserveAspectRatio</code> 属性。在引用时通过为 <code>use</code> 元素指定 <code>width</code> 和 <code>height</code> 属性就可以让 <code>symbol</code> 元素适配视口大小。</p>\n<p><code>image</code> 可以用来包含一个完整的 <code>SVG</code> 或栅格文件。如果包含一个 <code>SVG</code> 文件，则视口会基于引用的文件的 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 属性来建立。如果包含栅格文件则会被缩放以适配该属性指定的矩形。</p>\n<p><code>SVG</code>规范要求 <code>SVG</code> 阅读器支持 <code>JPEG</code> 和 <code>PNG</code> 两种栅格文件。</p>\n<h2 id=\"六、坐标系统变换\"><a href=\"#六、坐标系统变换\" class=\"headerlink\" title=\"六、坐标系统变换\"></a>六、坐标系统变换</h2><h3 id=\"1-translate变换\"><a href=\"#1-translate变换\" class=\"headerlink\" title=\"1. translate变换\"></a>1. translate变换</h3><p><code>translate</code> 变换用来对用户坐标进行平移，通过制定 <code>transform</code> 属性值来设置: <code>transform = &quot;translate(x,y)&quot;</code>。</p>\n<p><code>translate</code> 工作原理:首先获取整个网络，然后将其移动到画布的新位置而不是移动所在的元素，也就是说移动的是整个坐标系统而不是元素本身。看似比移动元素复杂，其实在使用其他一系列变换时，这种移动整个坐标系的方法从数学和概念上讲，更方便。</p>\n<h3 id=\"2-scale变换\"><a href=\"#2-scale变换\" class=\"headerlink\" title=\"2. scale变换\"></a>2. scale变换</h3><p>缩放坐标系统。<code>transform = &quot;scale(value)&quot;</code> 或者 <code>transform=&quot;scale(x-value,y-value)&quot;</code>。</p>\n<p>仅仅使用 <code>scale(n)</code> 变换时，网格系统的原点位置并没有变化，只是每个用户坐标都变成了原来的 <code>n</code> 倍，也就是网格变大了，因此线也会变粗(用户单位并没有变)。</p>\n<p><em>技巧：如果从其他系统传输数据到 <code>SVG</code>，则可能必须处理使用笛卡尔坐标表示的矢量图形，在笛卡尔坐标系统中，原点位于左下角，<code>y</code>向上递增，<code>x</code>向右递增。而 <code>SVG</code> 坐标原点位于左上角，此时使用 <code>scale(1,-1)</code> 就可以完成两者之间的转换。</em></p>\n<p><strong>缩放变换永远不会改变图形对象的网格坐标或者笔画宽度，仅仅改变对应画布上的坐标系统网格的大小。</strong></p>\n<h3 id=\"3-rotate变换\"><a href=\"#3-rotate变换\" class=\"headerlink\" title=\"3. rotate变换\"></a>3. rotate变换</h3><p>根据指定的角度旋转坐标系统，默认的坐标系统中，角度的测量顺时针增加，<code>0</code> 度为 <code>3</code> 点钟方向。</p>\n<p>注意，除非另行指定，否则旋转以原点为中心。 此时可以通过平移+旋转的方式来指定旋转中心： <code>translate(centerX,centerY) rotate(angle) translate(-centerX,-centerY)</code></p>\n<p>但是有个更简单的方式：<code>rotate(angle,centerX,centerY)</code></p>\n<h3 id=\"4-围绕中心点缩放\"><a href=\"#4-围绕中心点缩放\" class=\"headerlink\" title=\"4. 围绕中心点缩放\"></a>4. 围绕中心点缩放</h3><p>上面提到，缩放默认是以原点为基准的，这显然不能满足需求，那么可以通过如下方式指定缩放中心：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"><span class=\"hljs-built_in\">translate</span>(-centerX*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>),-centerY*(<span class=\"hljs-built_in\">factor</span>-<span class=\"hljs-number\">1</span>)) <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-built_in\">factor</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-skewX和skewY变换\"><a href=\"#5-skewX和skewY变换\" class=\"headerlink\" title=\"5. skewX和skewY变换\"></a>5. skewX和skewY变换</h3><p>这两个变换用来倾斜某个轴，一般形式为 <code>skewX(angle),skewY(angle)</code>。这样的结果就是使得 <code>x</code> 轴和 <code>y</code> 轴不再垂直。</p>\n<h3 id=\"6-矩阵变换\"><a href=\"#6-矩阵变换\" class=\"headerlink\" title=\"6. 矩阵变换\"></a>6. 矩阵变换</h3><p>计算机图形学中坐标变换都通过矩阵来实现，除上述变换方法之外，还可以直接为变换指定变换矩阵，变换矩阵为 <code>matrix(a,b,c,d,e,f)</code>，此时指定的变换矩阵为:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">a  c  e<br>b  d  f<br>0  0  1<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、路径\"><a href=\"#七、路径\" class=\"headerlink\" title=\"七、路径\"></a>七、路径</h2><h3 id=\"1-path命令\"><a href=\"#1-path命令\" class=\"headerlink\" title=\"1. path命令\"></a>1. path命令</h3><p><code>SVG</code> 中所有基本形状都是 <code>path</code> 的简写形式，但是建议使用简写形式，因为这样可以使 <code>SVG</code> 文档更可读。</p>\n<p><code>path</code> 元素更通用，可以通过制定一系列相互连接的线、弧、曲线来绘制任意形状的轮廓，这些轮廓也可以填充或者绘制轮廓线，也可以用来定义裁剪区域或蒙版。</p>\n<p>下表为 <code>path</code> 命令总结，其中大写表示绝对坐标，小写表示相对坐标：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>M</code> <code>m</code></td>\n<td><code>x y</code></td>\n<td>移动画笔到制定坐标</td>\n</tr>\n<tr>\n<td><code>L</code> <code>l</code></td>\n<td><code>x y</code></td>\n<td>绘制一条到给定坐标的线</td>\n</tr>\n<tr>\n<td><code>H</code> <code>h</code></td>\n<td><code>x</code></td>\n<td>绘制一条到给定 <code>x</code> 坐标的横线</td>\n</tr>\n<tr>\n<td><code>V</code> <code>v</code></td>\n<td><code>y</code></td>\n<td>绘制一条到给定<code>y</code>坐标的垂线</td>\n</tr>\n<tr>\n<td><code>A</code> <code>a</code></td>\n<td><code>rx ry x-axis-rotation large-arc sweep x y</code></td>\n<td>圆弧曲线命令有7个参数，依次表示<code>x</code>方向半径、<code>y</code>方向半径、旋转角度、大圆标识、顺逆时针标识、目标点<code>x</code>、目标点<code>y</code>。大圆标识和顺逆时针以<code>0</code>和<code>1</code>表示。<code>0</code>表示小圆、逆时针</td>\n</tr>\n<tr>\n<td><code>Q</code> <code>q</code></td>\n<td><code>x1 y1 x y</code></td>\n<td>绘制一条从当前点到<code>x, y</code>控制点为<code>x1, y1</code>的二次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>T</code> <code>t</code></td>\n<td><code>x y</code></td>\n<td>绘制一条从当前点到<code>x</code>,<code>y</code>的光滑二次贝塞尔曲线，控制点为前一个<code>Q</code>命令的控制点的中心对称点，如果没有前一条则已当前点为控制点。</td>\n</tr>\n<tr>\n<td><code>C</code> <code>c</code></td>\n<td><code>x1 y1 x2 y2 x y</code></td>\n<td>绘制一条从当前点到 <code>x</code>,<code>y</code>控制点为<code>x1,y1</code> <code>x2,y2</code>的三次贝塞尔曲线</td>\n</tr>\n<tr>\n<td><code>S</code> <code>s</code></td>\n<td><code>x2 y2 x y</code></td>\n<td>绘制一条从当前点到<code>x,y</code>的光滑三次贝塞尔曲线。第一个控制点为前一个<code>C</code>命令的第二个控制点的中心对称点，如果没有前一条曲线，则第一个控制点为当前的点。</td>\n</tr>\n</tbody></table>\n<p>路径的填充同样可以使用 <code>fill-rule</code> 属性指定填充规则，如果需要填充一个中空的形状，则只需要注意外侧路径顺逆时针方向和内侧空心区域顺逆时针方向即可。</p>\n<h2 id=\"八、渐变\"><a href=\"#八、渐变\" class=\"headerlink\" title=\"八、渐变\"></a>八、渐变</h2><h3 id=\"1-线性渐变\"><a href=\"#1-线性渐变\" class=\"headerlink\" title=\"1. 线性渐变\"></a>1. 线性渐变</h3><p>线性渐变是一系列颜色沿着一条直线过渡，在特定的位置指定想要的颜色，被称为渐变点。渐变点是渐变结构的一部分，颜色是表现的一部分。</p>\n<p>线性渐变使用<code>linearGradient</code>元素表示：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">linearGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;linear&quot;</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#ffcc00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0099cc;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">linearGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#linear);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.4.jpg\" alt=\"img\"></p>\n<p><code>stop</code>元素有两个必要属性：<code>offset</code>和<code>stop-color</code>。<code>offset</code>属性用来指定在哪个点的颜色应该等于<code>stop-color</code>。<code>offset</code>的取值范围0%-100%。</p>\n<p><code>stop</code>元素的属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>offset</code></td>\n<td>必需，取值范围 <code>0%-100%</code></td>\n</tr>\n<tr>\n<td><code>stop-color</code></td>\n<td>必需，对应 <code>offset</code> 位置点的颜色</td>\n</tr>\n<tr>\n<td><code>stop-opacity</code></td>\n<td>对应 <code>offset</code> 位置点的不透明度</td>\n</tr>\n</tbody></table>\n<p><code>linearGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>x1</code>,<code>y1</code></td>\n<td>渐变的起点位置，使用百分比表示，默认的渐变方向是从左到右</td>\n</tr>\n<tr>\n<td><code>x2</code>,<code>y2</code></td>\n<td>渐变的终点位置，使用百分比表示</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td>如果设置的<code>offset</code>不能覆盖整个对象，该怎么填充。<code>pad</code>: 起点或终点颜色会扩展到对象边缘。<code>repeat</code>: 渐变重复起点到终点的过程。<code>reflect</code>: 渐变按终点-起点-终点的排列重复。</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-径向渐变\"><a href=\"#2-径向渐变\" class=\"headerlink\" title=\"2. 径向渐变\"></a>2. 径向渐变</h3><p>径向渐变的每个渐变点是一个圆形路径，从中心点向外扩散。设置方式与线性渐变大致相同。如果填充对象边界框不是正方形的，则过渡路径会变成椭圆来匹配边界框的长宽比。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">radialGradient</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;radial&quot;</span> <span class=\"hljs-attr\">cx</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">cy</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> &gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;0%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#f00;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#0f0;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">stop</span> <span class=\"hljs-attr\">offset</span>=<span class=\"hljs-string\">&quot;100%&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;stop-color:#00f;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">stop</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">radialGradient</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">&quot;20&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;200&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:url(#radial);stroke:black;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rect</span>&gt;</span>\t<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.5.jpg\" alt=\"img\"></p>\n<p><code>radialGradient</code>元素属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>cx</code>,<code>cy</code>,<code>r</code></td>\n<td>定义渐变的范围，测量半径的单位是对象的宽高均值，而不是对角线，默认都为<code>50%</code></td>\n</tr>\n<tr>\n<td><code>fx</code>,<code>fy</code></td>\n<td><code>0%</code>点所处的圆路径的圆心，默认和<code>cx</code>,<code>cy</code>一样</td>\n</tr>\n<tr>\n<td><code>spreadMethod</code></td>\n<td><code>pad</code>,<code>repeat</code>,<code>reflect</code> 三个值，用来解决绘制范围没有到达图形边缘的情况。</td>\n</tr>\n</tbody></table>\n<h2 id=\"九、文本\"><a href=\"#九、文本\" class=\"headerlink\" title=\"九、文本\"></a>九、文本</h2><h3 id=\"1-相关术语\"><a href=\"#1-相关术语\" class=\"headerlink\" title=\"1. 相关术语\"></a>1. 相关术语</h3><table>\n<thead>\n<tr>\n<th>术语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字符</td>\n<td><code>XML</code>中，字符是指带有一个数字值得一个或多个字节，数字值与<code>Unidode</code>标准对应</td>\n</tr>\n<tr>\n<td>符号</td>\n<td>字符的视觉呈现。每个字符可以有多种视觉呈现</td>\n</tr>\n<tr>\n<td>字体</td>\n<td>代表某个字符集合的一组符号</td>\n</tr>\n<tr>\n<td>基线</td>\n<td>字体中所有符号以基线对齐</td>\n</tr>\n<tr>\n<td>上坡度</td>\n<td>基线到字体中最高字符的顶部距离</td>\n</tr>\n<tr>\n<td>下坡度</td>\n<td>基线到最深字符底部的距离</td>\n</tr>\n<tr>\n<td>大写字母高度、<code>x</code>高度</td>\n<td>大写字母高度是指基线上大写字母的高度，<code>x</code>高度是基线到小写字母<code>x</code>顶部的高度</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-文本元素的基本属性\"><a href=\"#2-文本元素的基本属性\" class=\"headerlink\" title=\"2. 文本元素的基本属性\"></a>2. 文本元素的基本属性</h3><p><code>text</code> 元素以指定的x和y值作为元素内容第一个字符的基线位置，默认样式黑色填充、没有轮廓。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>font-family</code></td>\n<td>以空格分割的一系列字体名称或通用字体名称</td>\n</tr>\n<tr>\n<td><code>font-size</code></td>\n<td>如果有多行文本，则 <code>font-size</code> 为平行的两条基线的距离</td>\n</tr>\n<tr>\n<td><code>font-weight</code></td>\n<td>两个值：<code>bold</code>(粗体)和<code>nromal</code>(默认)</td>\n</tr>\n<tr>\n<td><code>font-style</code></td>\n<td>常用的两个值:<code>italic</code>(斜体)和<code>normal</code></td>\n</tr>\n<tr>\n<td><code>text-decoration</code></td>\n<td>可能的值:<code>none</code>,<code>underline</code>(下划线),<code>overline</code>(上划线),<code>line-through</code>(删除线)</td>\n</tr>\n<tr>\n<td><code>word-spacing</code></td>\n<td>单词之间的距离</td>\n</tr>\n<tr>\n<td><code>letter-spacing</code></td>\n<td>字母之间的间距</td>\n</tr>\n<tr>\n<td><code>text-anchor</code></td>\n<td>对齐方式：<code>start</code>,<code>middle</code>,<code>end</code></td>\n</tr>\n<tr>\n<td><code>textLength</code></td>\n<td>设置文本的长度</td>\n</tr>\n<tr>\n<td><code>lengthAdjust</code></td>\n<td>在指定了<code>textLength</code>时，可以通过<code>lengthAdjust</code>属性设置字符的调整方式，值为 <code>spacing</code>(默认)时,只调整字符的间距。当值为<code>spacingAndGlyphs</code>时，同时调整字符间距和字符本身的大小</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-tspan元素\"><a href=\"#3-tspan元素\" class=\"headerlink\" title=\"3. tspan元素\"></a>3. tspan元素</h3><p><code>text</code> 元素无法对文本进行换行操作，如果需要分行显示文本，则需要使用在text元素里嵌入<code>tspan</code> 元素。<code>tspan</code> 元素与<code>html</code>的<code>span</code>元素类似，可以嵌套在文本内容中，并可以单独改变其内部文本内容的样式。</p>\n<p><code>tspan</code>元素除大小，颜色等表现样式之外，还可以设置以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>dx</code>,<code>dy</code></td>\n<td><code>x</code>和<code>y</code>方向的偏移</td>\n</tr>\n<tr>\n<td><code>x</code>,<code>y</code></td>\n<td>对<code>tspan</code>进行绝对定位</td>\n</tr>\n<tr>\n<td><code>rotate</code></td>\n<td>旋转字符，可以同时设置多个值，这些值会依次作用在<code>tspan</code>包裹的字母上</td>\n</tr>\n<tr>\n<td><code>baseline-shift</code></td>\n<td>与<code>dy</code>属性设置上下标相比，这个属性更方便，当为<code>super</code>时，会上标。<code>sub</code> 时为下标。仅仅在所在的<code>tspan</code>内有效</td>\n</tr>\n</tbody></table>\n<h3 id=\"4-纵向文本\"><a href=\"#4-纵向文本\" class=\"headerlink\" title=\"4. 纵向文本\"></a>4. 纵向文本</h3><p>文本一般从左到右排列，如果需要上下排列，则需要使用<code>writing-mode</code>属性。</p>\n<p>设置<code>writing-mode</code>属性值为<code>tb</code>(top to bottom)，可以将文本上下排列。</p>\n<h2 id=\"5-文本路径\"><a href=\"#5-文本路径\" class=\"headerlink\" title=\"5. 文本路径\"></a>5. 文本路径</h2><p>如果要使得文本沿着某条路径排列，则需要使用<code>textPath</code>元素。需要将文本放在<code>textPath</code>元素内部，然后使用<code>textPath</code>元素的<code>xlink:href</code>属性引用一个定义好的<code>path</code>元素。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">defs</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">defs</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,50)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">&quot;translate(10,100)&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;path&quot;</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">&quot;M30 40 C 50 10 ,70 10,120 40 S150 0,200 40&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;fill:none;stroke:black&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">path</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>&gt;</span><br>\t\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textPath</span> <span class=\"hljs-attr\">xlink:href</span>=<span class=\"hljs-string\">&quot;#path&quot;</span> <span class=\"hljs-attr\">startOffset</span>=<span class=\"hljs-string\">&quot;50%&quot;</span> <span class=\"hljs-attr\">text-anchor</span>=<span class=\"hljs-string\">&quot;middle&quot;</span>&gt;</span><br>\t\t\thello world<br>\t\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textPath</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"http://cdn.d3js.org.cn/images/doc/svg/8.6.jpg\" alt=\"img\"></p>\n<p><code>startOffset</code>属性用来指定文本的起点，当设置为<code>50%</code>，并且设置<code>text-anchor</code>为<code>middle</code>时，文本会被定为在<code>path</code>的中间。</p>\n"},{"title":"浏览器的进程和线程","keywords":"浏览器的进程和线程","_content":"# 浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\n\n> 引用自[链接](https://juejin.cn/post/7067725869598375967#heading-0)\n\n## 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。\n\n## 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\n```js\nA = 1+2\nB = 20/5\nC = 7*8\n复制代码\n```\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n- 任务 1 是计算 A=1+2；\n- 任务 2 是计算 B=20/5；\n- 任务 3 是计算 C=7*8；\n- 任务 4 是显示最后计算的结果。\n\n正常情况下程序可以使用**单线程**来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用**多线程**，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，**使用并行处理能大大提升性能。**\n\n## 线程 VS 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。那什么又是进程呢？\n\n**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。\n\n![进程中的单线程和多线程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看到，**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率**。总结来说，进程和线程之间的关系有以下 4 个特点。\n\n**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**\n\n我们可以模拟以下场景：\n\n```js\nA = 1+2\nB = 20/0\nC = 7*8\n复制代码\n```\n\n我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n**2. 线程之间共享进程中的数据。**\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n![线程之间共享进程中的数据](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。\n\n**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n**4. 进程之间的内容相互隔离。**\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了\n\n## 单进程浏览器时代\n\n顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：\n\n![单进程浏览器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器**不稳定、不流畅和不安全**的一个主要因素。\n\n**问题 1：不稳定**\n\n早期浏览器需要借助于**插件**来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，**渲染引擎模块**也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n**问题 2：不流畅**\n\n从上面的**单进程浏览器架构示意图**可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\n```js\nfunction freeze() { \n    while (1) { \n        console.log(\"freeze\"); \n    }\n}\nfreeze();\n```\n\n如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。\n\n除了上述**脚本**或者**插件**会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。\n\n**问题 3：不安全**\n\n不安全这里依然可以从插件和页面脚本两个方面来解释该问题。\n\n插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。\n\n## 多进程浏览器时代\n\n### **早期多进程架构**\n\n2008年Chrome发布时的进程架构：\n\n![早期多进程架构](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。\n\n**我们先看看如何解决不稳定的问题**。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。\n\n**接下来再来看看不流畅的问题是如何解决的**。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n**最后再来看看上面的不安全的问题是怎么解决的**。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n### 目前多进程架构\n\n最新的Chrome进程架构图：\n\n![目前多进程架构图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。\n\n**浏览器进程**只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。\n\n**渲染进程**（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。\n\n- **GUI渲染线程**负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。\n- **Javascript引擎线程**，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。\n  - **GUI渲染线程和Javascript引擎线程是互斥的**。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。\n- **定时触发器线程**，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。\n- **事件触发线程**，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n- **异步http请求线程**，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n\n**GPU进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n**网络进程**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n**插件进程**主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响","source":"_posts/浏览器进程和线程.md","raw":"---\ntitle:  浏览器的进程和线程\ntag: 浏览器的进程和线程\nkeywords: 浏览器的进程和线程\ncategories: 浏览器相关知识\n---\n# 浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\n\n> 引用自[链接](https://juejin.cn/post/7067725869598375967#heading-0)\n\n## 进程和线程\n\n不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。\n\n## 什么是并行处理\n\n计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。\n\n```js\nA = 1+2\nB = 20/5\nC = 7*8\n复制代码\n```\n\n在编写代码的时候，我们可以把这个过程拆分为四个任务：\n\n- 任务 1 是计算 A=1+2；\n- 任务 2 是计算 B=20/5；\n- 任务 3 是计算 C=7*8；\n- 任务 4 是显示最后计算的结果。\n\n正常情况下程序可以使用**单线程**来处理，也就是分四步按照顺序分别执行这四个任务。\n\n如果采用**多线程**，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n\n通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，**使用并行处理能大大提升性能。**\n\n## 线程 VS 进程\n\n多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。那什么又是进程呢？\n\n**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。\n\n![进程中的单线程和多线程](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看到，**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率**。总结来说，进程和线程之间的关系有以下 4 个特点。\n\n**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**\n\n我们可以模拟以下场景：\n\n```js\nA = 1+2\nB = 20/0\nC = 7*8\n复制代码\n```\n\n我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。\n\n**2. 线程之间共享进程中的数据。**\n\n如下图所示，线程之间可以对进程的公共数据进行读写操作。\n\n![线程之间共享进程中的数据](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。\n\n**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**\n\n当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n\n比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉\n\n**4. 进程之间的内容相互隔离。**\n\n进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了\n\n## 单进程浏览器时代\n\n顾名思义，**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：\n\n![单进程浏览器](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n如此多的功能模块运行在一个进程里，是导致单进程浏览器**不稳定、不流畅和不安全**的一个主要因素。\n\n**问题 1：不稳定**\n\n早期浏览器需要借助于**插件**来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n\n除了插件之外，**渲染引擎模块**也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃\n\n**问题 2：不流畅**\n\n从上面的**单进程浏览器架构示意图**可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n\n比如，下面这个无限循环的脚本：\n\n```js\nfunction freeze() { \n    while (1) { \n        console.log(\"freeze\"); \n    }\n}\nfreeze();\n```\n\n如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。\n\n除了上述**脚本**或者**插件**会让单进程浏览器变卡顿外，**页面的内存泄漏**也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。\n\n**问题 3：不安全**\n\n不安全这里依然可以从插件和页面脚本两个方面来解释该问题。\n\n插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n\n以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。\n\n## 多进程浏览器时代\n\n### **早期多进程架构**\n\n2008年Chrome发布时的进程架构：\n\n![早期多进程架构](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。\n\n**我们先看看如何解决不稳定的问题**。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。\n\n**接下来再来看看不流畅的问题是如何解决的**。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。\n\n**最后再来看看上面的不安全的问题是怎么解决的**。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n\n### 目前多进程架构\n\n最新的Chrome进程架构图：\n\n![目前多进程架构图](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)\n\n从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。\n\n**浏览器进程**只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。\n\n**渲染进程**（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。\n\n- **GUI渲染线程**负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。\n- **Javascript引擎线程**，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。\n  - **GUI渲染线程和Javascript引擎线程是互斥的**。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。\n- **定时触发器线程**，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。\n- **事件触发线程**，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n- **异步http请求线程**，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n\n**GPU进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。\n\n**网络进程**主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。\n\n**插件进程**主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响","slug":"浏览器进程和线程","published":1,"date":"2022-03-23T12:29:43.861Z","updated":"2022-03-23T14:44:36.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9kz000pi0242uwlejpx","content":"<h1 id=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"><a href=\"#浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\" class=\"headerlink\" title=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"></a>浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）</h1><blockquote>\n<p>引用自<a href=\"https://juejin.cn/post/7067725869598375967#heading-0\">链接</a></p>\n</blockquote>\n<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h2 id=\"什么是并行处理\"><a href=\"#什么是并行处理\" class=\"headerlink\" title=\"什么是并行处理\"></a>什么是并行处理</h2><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">5</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果。</li>\n</ul>\n<p>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，<strong>使用并行处理能大大提升性能。</strong></p>\n<h2 id=\"线程-VS-进程\"><a href=\"#线程-VS-进程\" class=\"headerlink\" title=\"线程 VS 进程\"></a>线程 VS 进程</h2><p>多线程可以并行处理任务，但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong>。那什么又是进程呢？</p>\n<p><strong>一个进程就是一个程序的运行实例</strong>。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"进程中的单线程和多线程\"></p>\n<p>从图中可以看到，<strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong>。总结来说，进程和线程之间的关系有以下 4 个特点。</p>\n<p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>\n<p>我们可以模拟以下场景：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">0</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。</p>\n<p><strong>2. 线程之间共享进程中的数据。</strong></p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"线程之间共享进程中的数据\"></p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n<p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n<p><strong>4. 进程之间的内容相互隔离。</strong></p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了</p>\n<h2 id=\"单进程浏览器时代\"><a href=\"#单进程浏览器时代\" class=\"headerlink\" title=\"单进程浏览器时代\"></a>单进程浏览器时代</h2><p>顾名思义，<strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"单进程浏览器\"></p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p>\n<p><strong>问题 1：不稳定</strong></p>\n<p>早期浏览器需要借助于<strong>插件</strong>来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，<strong>渲染引擎模块</strong>也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<p><strong>问题 2：不流畅</strong></p>\n<p>从上面的<strong>单进程浏览器架构示意图</strong>可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">freeze</span>(<span class=\"hljs-params\"></span>) &#123; <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123; <br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;freeze&quot;</span>); <br>    &#125;<br>&#125;<br><span class=\"hljs-title function_\">freeze</span>();<br></code></pre></td></tr></table></figure>\n\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p>\n<p>除了上述<strong>脚本</strong>或者<strong>插件</strong>会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<p><strong>问题 3：不安全</strong></p>\n<p>不安全这里依然可以从插件和页面脚本两个方面来解释该问题。</p>\n<p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。</p>\n<h2 id=\"多进程浏览器时代\"><a href=\"#多进程浏览器时代\" class=\"headerlink\" title=\"多进程浏览器时代\"></a>多进程浏览器时代</h2><h3 id=\"早期多进程架构\"><a href=\"#早期多进程架构\" class=\"headerlink\" title=\"早期多进程架构\"></a><strong>早期多进程架构</strong></h3><p>2008年Chrome发布时的进程架构：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"早期多进程架构\"></p>\n<p>从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后再来看看上面的不安全的问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<h3 id=\"目前多进程架构\"><a href=\"#目前多进程架构\" class=\"headerlink\" title=\"目前多进程架构\"></a>目前多进程架构</h3><p>最新的Chrome进程架构图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"目前多进程架构图\"></p>\n<p>从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。</p>\n<p><strong>浏览器进程</strong>只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。</p>\n<p><strong>渲染进程</strong>（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。</p>\n<ul>\n<li><strong>GUI渲染线程</strong>负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。</li>\n<li><strong>Javascript引擎线程</strong>，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。<ul>\n<li><strong>GUI渲染线程和Javascript引擎线程是互斥的</strong>。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</li>\n</ul>\n</li>\n<li><strong>定时触发器线程</strong>，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。</li>\n<li><strong>事件触发线程</strong>，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。</li>\n<li><strong>异步http请求线程</strong>，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</li>\n</ul>\n<p><strong>GPU进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n<p><strong>网络进程</strong>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n<p><strong>插件进程</strong>主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p>\n","site":{"data":{}},"wordcount":4281,"excerpt":"","more":"<h1 id=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"><a href=\"#浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\" class=\"headerlink\" title=\"浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）\"></a>浏览器的进程和线程（面试：为什么打开浏览器页面，会有四个进程？）</h1><blockquote>\n<p>引用自<a href=\"https://juejin.cn/post/7067725869598375967#heading-0\">链接</a></p>\n</blockquote>\n<h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>不过，在介绍进程和线程之前，我需要先讲解下，什么是并行处理。因为如果你理解了并行处理的概念，那么再理解进程和线程之间的关系就会变得轻松许多。</p>\n<h2 id=\"什么是并行处理\"><a href=\"#什么是并行处理\" class=\"headerlink\" title=\"什么是并行处理\"></a>什么是并行处理</h2><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算下面这三个表达式的值，并显示出结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">5</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>在编写代码的时候，我们可以把这个过程拆分为四个任务：</p>\n<ul>\n<li>任务 1 是计算 A=1+2；</li>\n<li>任务 2 是计算 B=20/5；</li>\n<li>任务 3 是计算 C=7*8；</li>\n<li>任务 4 是显示最后计算的结果。</li>\n</ul>\n<p>正常情况下程序可以使用<strong>单线程</strong>来处理，也就是分四步按照顺序分别执行这四个任务。</p>\n<p>如果采用<strong>多线程</strong>，会怎么样呢？我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。</p>\n<p>通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，<strong>使用并行处理能大大提升性能。</strong></p>\n<h2 id=\"线程-VS-进程\"><a href=\"#线程-VS-进程\" class=\"headerlink\" title=\"线程 VS 进程\"></a>线程 VS 进程</h2><p>多线程可以并行处理任务，但是<strong>线程是不能单独存在的，它是由进程来启动和管理的</strong>。那什么又是进程呢？</p>\n<p><strong>一个进程就是一个程序的运行实例</strong>。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03c20111e2b94345b039995084ee03db~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"进程中的单线程和多线程\"></p>\n<p>从图中可以看到，<strong>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</strong>。总结来说，进程和线程之间的关系有以下 4 个特点。</p>\n<p><strong>1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>\n<p>我们可以模拟以下场景：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">A = <span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span><br>B = <span class=\"hljs-number\">20</span>/<span class=\"hljs-number\">0</span><br>C = <span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span><br>复制代码<br></code></pre></td></tr></table></figure>\n\n<p>我把上述三个表达式稍作修改，在计算 B 的值的时候，我把表达式的分母改成 0，当线程执行到 B = 20/0 时，由于分母为 0，线程会执行出错，这样就会导致整个进程的崩溃，当然另外两个线程执行的结果也没有了。</p>\n<p><strong>2. 线程之间共享进程中的数据。</strong></p>\n<p>如下图所示，线程之间可以对进程的公共数据进行读写操作。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0a54836131420b983c12b6adf0e9f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"线程之间共享进程中的数据\"></p>\n<p>从上图可以看出，线程 1、线程 2、线程 3 分别把执行的结果写入 A、B、C 中，然后线程 2 继续从 A、B、C 中读取数据，用来显示执行结果。</p>\n<p><strong>3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。</strong></p>\n<p>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>\n<p>比如之前的 IE 浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存就都会被系统回收掉</p>\n<p><strong>4. 进程之间的内容相互隔离。</strong></p>\n<p>进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了</p>\n<h2 id=\"单进程浏览器时代\"><a href=\"#单进程浏览器时代\" class=\"headerlink\" title=\"单进程浏览器时代\"></a>单进程浏览器时代</h2><p>顾名思义，<strong>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</strong>，这些模块包含网络、插件、Javascript运行环境、渲染引擎和页面等。其实早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f13158e5fe114b79a2be3b1b168467a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"单进程浏览器\"></p>\n<p>如此多的功能模块运行在一个进程里，是导致单进程浏览器<strong>不稳定、不流畅和不安全</strong>的一个主要因素。</p>\n<p><strong>问题 1：不稳定</strong></p>\n<p>早期浏览器需要借助于<strong>插件</strong>来实现诸如Web视频、Web游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p>\n<p>除了插件之外，<strong>渲染引擎模块</strong>也是不稳定的，通常一些复杂的Javascript代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p>\n<p><strong>问题 2：不流畅</strong></p>\n<p>从上面的<strong>单进程浏览器架构示意图</strong>可以看出，所有页面的渲染模块、Javascript执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p>\n<p>比如，下面这个无限循环的脚本：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">freeze</span>(<span class=\"hljs-params\"></span>) &#123; <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123; <br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;freeze&quot;</span>); <br>    &#125;<br>&#125;<br><span class=\"hljs-title function_\">freeze</span>();<br></code></pre></td></tr></table></figure>\n\n<p>如果让这个脚本运行在一个单进程浏览器的页面里，因为这个脚本是无限循环的，所有当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为单进程浏览器中所有的页面都运行在该线程中，所以这些页面就没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。</p>\n<p>除了上述<strong>脚本</strong>或者<strong>插件</strong>会让单进程浏览器变卡顿外，<strong>页面的内存泄漏</strong>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p>\n<p><strong>问题 3：不安全</strong></p>\n<p>不安全这里依然可以从插件和页面脚本两个方面来解释该问题。</p>\n<p>插件可以使用C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也意味着这个插件能完全操作你的电脑。如果是一个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p>\n<p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p>\n<p>以上这些就是单进程浏览器的特点，不稳定、不流畅和不安全。</p>\n<h2 id=\"多进程浏览器时代\"><a href=\"#多进程浏览器时代\" class=\"headerlink\" title=\"多进程浏览器时代\"></a>多进程浏览器时代</h2><h3 id=\"早期多进程架构\"><a href=\"#早期多进程架构\" class=\"headerlink\" title=\"早期多进程架构\"></a><strong>早期多进程架构</strong></h3><p>2008年Chrome发布时的进程架构：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8114114a549c4346b6bc5134ec89e116~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"早期多进程架构\"></p>\n<p>从途中可以看出，Chrome的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程中的，进程之间通过IPC机制进行通信。</p>\n<p><strong>我们先看看如何解决不稳定的问题</strong>。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃导致整个浏览器崩溃，也就是不稳定的问题。</p>\n<p><strong>接下来再来看看不流畅的问题是如何解决的</strong>。同样，Javascript也是运行在渲染进程中的，所以即使Javascript阻塞了渲染进程，影响到的也是当前的页面渲染，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在他们自己的渲染进程中的。所以当我们再在Chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p>\n<p><strong>最后再来看看上面的不安全的问题是怎么解决的</strong>。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p>\n<h3 id=\"目前多进程架构\"><a href=\"#目前多进程架构\" class=\"headerlink\" title=\"目前多进程架构\"></a>目前多进程架构</h3><p>最新的Chrome进程架构图：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f48d1fbfe148a9b939296e23ae080e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"目前多进程架构图\"></p>\n<p>从图中可以看出，最新的Chrome浏览器包括：浏览器主进程（Browser Process）、GPU进程（GPU Process）、网络进程（Network Process）、渲染进程（Render Process）、插件进程（Plugin Process）。</p>\n<p><strong>浏览器进程</strong>只要负责页面显示、用户交互、子进程管理、资源下载、提供存储等功能。</p>\n<p><strong>渲染进程</strong>（浏览器内核）核心任务是将HTML、CSS和Javascript转换为用户可以与之交互的网页，排版引擎Blink和Javascript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程，通常由以下常驻线程构成：GUI渲染线程、Javascript引擎线程、定时触发器线程、事件触发线程、异步http请求线程。</p>\n<ul>\n<li><strong>GUI渲染线程</strong>负责渲染浏览器页面HTML元素，当界面需要重绘（repaint）或由于某种操作回流（reflow）时，该线程就会执行。在Javascript引擎运行脚本期间，GUI渲染引擎都是挂起状态，也就是说被冻结了。</li>\n<li><strong>Javascript引擎线程</strong>，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎是解析JS脚本，运行代码。<ul>\n<li><strong>GUI渲染线程和Javascript引擎线程是互斥的</strong>。由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。</li>\n</ul>\n</li>\n<li><strong>定时触发器线程</strong>，浏览器定时器（setTimeout和setInterval）并不是由Javascript引擎计数的，因为Javascript引擎是单线程的，如果处于阻塞状态就会影响计时的准确性，因此通过另外一个单独的定时触发器线程来计时是更为合理的方法。</li>\n<li><strong>事件触发线程</strong>，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。</li>\n<li><strong>异步http请求线程</strong>，在XMLHttpRequest连接后是通过浏览器开启一个线程请求，当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</li>\n</ul>\n<p><strong>GPU进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p>\n<p><strong>网络进程</strong>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p>\n<p><strong>插件进程</strong>主要负责插件的运行，因为插件容易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</p>\n"},{"title":"设计模式","keywords":"设计模式","_content":"\n## 1.设计模式概论\n\n### 1.1 代码与设计模式\n\n#### 🍅 我们写代码到底是在写什么？\n\n我们写项目其实就是写模块然后设计它们之间的沟通，设计模式说白了就是帮助我们更好的设计模块， 更好的组织它们之间的沟通。\n\n#### 🍅 设计模式扮演的角色\n\n- 帮助我们组织模块\n  - 通过一些设计模式，组织模块间的组成结构\n- 帮助我们设计沟通\n  - 有的设计模式可以帮助我们设计模块间如何沟通\n- 提高代码质量\n  - 通过设计模式，让代码更加优雅\n\n#### 🍅 设计原则\n\n1. 开闭原则\n\n   1. 我们的程序要对扩展开放，对修改关闭；我们的程序要给具体使用的时候扩展的接口，但是在具体使用的时候不能让其修改我们的源码，也就是说我们不用修改源码就能扩展功能，像 vue、react 等都有扩展的接口\n\n2. 单一职责原则\n\n   1. 我们的模块只做一件事情，模块的职责越单一越好\n\n3. 依赖倒置原则\n\n   1. 我们的上层模块不要依赖于具体的下层模块，应该依赖于抽象\n\n   2. 如下面的代码，我们在下层和上层之间加一个抽象层；下层如何变动都不会影响到上层，只需更改抽象层即可\n\n   3. ```javascript\n      // 具体层\n      function Food1() {}\n      function Food2() {}\n      function Food3() {}\n\n      // 抽象层\n      function foodList(food) {\n        const foodMap = {\n          food1: new Food1(),\n          food2: new Food2(),\n          food3: new Food3()\n        }\n        return foodMap[food]\n      }\n\n      // 上层\n      function order(food) {\n        return foodList(food)\n      }\n      ```\n\n4. 接口隔离原则\n\n   1. 我们的接口要细化，功能要单一，一个接口不要调用太多方法，使其能力单一，听起来像单一职责原则；但是 2 者的关注点不同， 单一职责原则主要关注于模块本身，接口隔离原则关注于接口；我们尽量细化接口，每个接口做的事情尽量单一化。\n\n5. 迪米特法则\n\n   1. 我们让 2 个对象之间产生沟通，我们最好让 2 个对象之间知道的越少越好，没必要 2 者之间非常的了解；我们的中介者模式是一个很好体现迪米特法则的设计模式，中介者模式让 2 个对象之间没必要直接的沟通，如果直接沟通需要了解 2 者之间的 api 和彼此的调用方式，这个时候我们可以采用一个中介者来转达我们的需求，而不用彼此知道\n\n6. 里氏替换原则\n\n   1. 它主要关注于继承，它的意义是任何使用父类的地方都可以用子类去替换，直白的说我们子类继承父类的时候，我们的子类必须完全保证继承父类的属性和方法，这样的话父类使用的地方，子类可以进行替换\n\n### 1.2 设计模式的分类\n\n1. 创建型\n\n   这些设计模式可以帮助我们优雅地创建对象\n\n   - 工厂模式-大量创建对象\n   - 单例模式-全局只有一个实例\n   - 建造者模式-精细化组合对象\n   - 原型模式-JavaScript 的灵魂\n\n2. 结构型\n\n   帮助优雅地设计代码结构\n\n   - 外观模式-给你的一个套餐\n   - 适配器模式-用适配代替更改\n   - 装饰着模式-更优雅地扩展需求\n   - 享元模式-共享来减少数量\n   - 桥接模式-独立出来，然后再对接出去\n\n3. 行为型\n\n   模块之间行为的模式总结，帮助组织模块行为\n\n   - 观察者模式-第三方转发\n   - 状态模式-用状态代替判断\n   - 策略模式-算法工厂\n   - 职责链模式-像生产线一样组织模块\n   - 命令模式-用命令去解耦\n   - 迭代器模式-告别 for 循环\n\n4. 技巧型\n\n   帮助优化代码的技巧\n\n   - 链模式-链式调用\n   - 委托模式\n   - 数据访问模式-一个方便的数据管理器\n   - 惰性模式-第一次执行完后把状态记录下来\n   - 等待着模式-等你们都回来再吃饭\n\n## 2.设计模式应用\n\n### 2.1.封装对象（创建型设计模式）\n\n#### 2.1.1 工厂模式(如：创建对象)\n\n**工厂模式的基本结构**\n\n```javascript\nfunction Factory (type) {\n    switch (type) {\n        case 'type1'\n        return new Type1()\n        case 'type2'\n        return new Type2()\n        case 'type3'\n        return new Type3()\n    }\n}\n```\n\n工厂模式就是写一个方法，只需调用这个方法，就能拿到想要的对象\n\n#### 2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）\n\n**建造者模式的基本结构**\n\n```javascript\n//  模块1\nfunction Mode1() {}\n// 模块2\nfunction Mode2() {}\n// 最终使用的类\nfunction Final() {\n  this.mode1 = new Model()\n  this.mode2 = new Mode2()\n}\n```\n\n建造者模式就是把一个复杂的类的各个部分，拆分成独立的类，然后再组合成一个最终的类\n\n#### 2.1.3 单例模式（如： Vuex、Vue-router）\n\n**单例模式的基本结构**\n\n单例模式的做法不是很固定，但是要保证全局只有一个对象的思想\n\n```javascript\n// 作为单例实例化的对象\nlet SingLeton = function (name) {\n  this.name = name\n}\n/*\n在SingLeton挂在一个getInstance方法，只能通过getInstance方法来获取\nSingLeton的实例化对象\n*/\nSingLeton.getInstance = function (name) {\n  if (this.instance) {\n    return this.instance\n  }\n  return (this.instance = new SingLeton(name))\n}\n```\n\n通过一个方法，使用时只允许通过此方法拿到存在内部的同一实例化的对象\n\n### 2.2 提高复用性\n\n#### 2.2.1 桥接模式\n\n这个模式和建造者模式很类似，拆分再组合。但是建造者模式的核心是如何去构造对象，桥接模式是把耦合功能抽离出去\n\n```javascript\n// 有三种形状，每种形状都有3种颜色\nfunction rect(color) {\n  //矩形\n  showcolor(color)\n}\nfunction circle(color) {\n  // 圆形\n  showcolor(color)\n}\nfunction delta(color) {\n  // 三角形\n  showcolor(color)\n}\n\nnew circle('red')\n```\n\n#### 2.2.2 享元模式\n\n提取出公有部分与私有部分，私有部分作为外部数据传入(抽离一个数组)，从而减少对象数量\n\n```javascript\n // 有一百种不同文字的弹窗，每种弹窗行为相同，但是文字和样式不同，我们没必要新间一百个弹窗对象\n    function Pop(){\n    }\n    // 保留同样的行为\n    Pop.prototype.action=function(){}\n    //显示\n    Pop.prototype.show=function(){}\n    // 提取出每个弹窗不同的部分作为一个外部数组\n    var popArr=[\n        {text:\"window1\",style:[400,400]}\n        {text:\"window2\",style:[400,200]}\n    ]\n\n    var poper=new Pop()\n\n    for(var i=0;i<100;i++){\n        poper.show(popArr[i])\n    }\n```\n\n### 2.3 提高可扩展性\n\n#### 2.3.1 适配器模式\n\n当面临两个新老模块间接口 api 不匹配，可以用适配来转化 api\n\n```javascript\n// A框架调用的方式\nA.c()\n// 假如我们项目中换成了jQuey，我们不想全部去替换A方法，就用适配器的方法\nA.c = function () {\n  return $.on.apply(this.arguments)\n}\n```\n\n#### 2.3.2 装饰者模式（如：Vue 重写数组方法）\n\n当老的方法，不方便去直接修改，可以通装饰者来增加功能\n\n```javascript\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator(...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n#### 2.3.3 命令模式\n\n解耦实现与具体命令，让是实现端和命令端扩展的更轻松\n\n```javascript\nvar createImg = (function () {\n  var action = {\n    create: function (obj) {\n      var htmlArr = []\n      var _htmlstring = ''\n      var _htmlTemplate = \"<div><img src='{{img-url}}' /></div><h2>{{title}}</h2>\"\n      var displayWay = {\n        normal: function (arr) {\n          return arr\n        },\n        reverse: function (arr) {\n          return arr.reverse\n        }\n      }\n\n      obj.imgArr.forEach((img) => {\n        var _html\n        _html = _htmlTemplate.replace('{{img-url}}', img.img).replace('{{title}}', img.title)\n        htmlArr.push(_html)\n      })\n      htmlArr = displayWay[obj.type](htmlArr)\n      _htmlstring = htmlArr.join('')\n      return '<div>' + _htmlstring + '</div>'\n    },\n    display: function (obj) {\n      var _html = this.create(obj)\n      obj.target.innerHTML = _html\n    }\n  }\n\n  return function excute(obj) {\n    var _default = {\n      imgArr: [{ img: 'xxxx', title: 'default title' }],\n      type: 'normal',\n      target: document.body\n    }\n    for (var item in _default) {\n      _default[item] = obj[item] || _default[item]\n    }\n    action.display(_default)\n  }\n})()\ncreateImg({\n  imgArr: [\n    { img: 'xxxx', title: 'default title1' },\n    { img: 'xxxx', title: 'default title2' }\n  ],\n  type: 'normal'\n})\n```\n\n#### 2.3.4 观察者模式\n\n适用于不适合直接沟通的模块之间的组织\n\n```javascript\nfunction observe {\n  this.message={}\n}\n\nobserve.prototype.regist=function(type,fn) {\n  this.message[type]=fn\n}\n\nobserve.prototype.fire=function(type){\n  this.message[type]()\n}\n\nobserve.prototype.remove=function(type){\n  this.message[type]=null\n}\n```\n\n#### 2.3.5 职责链模式\n\n组织同步模块，把要做的事情划分为模块，要做的事情一次传递\n\n```javascript\n// 表单事件绑定->表单前端验证->表单后端验证\n// 思想：把你要做的事情拆分为模块，模块之间只做自己模块的事情\n\ninput.onblur = function () {\n  var _value = input.value\n  var _arr = [font, middle, back, fontAgain]\n  async function test() {\n    var _result = _value\n    while (_arr.length > 0) {\n      _result = await _arr.shift()(_result)\n    }\n    return _result\n  }\n  test().then((res) => {\n    console.log(res)\n  })\n}\n\nfunction font(result) {}\n\nfunction middle(result) {}\n\nfunction back(result) {}\n\nfunction fontAgain(result) {}\n```\n\n#### 2.3.6 访问者模式\n\n解耦数据操作与数据结构\n\n```javascript\nvar data = []\n\nvar handler = function () {}\n\nhandler.prototype.get = function () {}\n\nvar vistor = function (handler, data) {\n  handler.get(data)\n}\n```\n\n### 2.4 提高代码质量\n\n#### 2.4.1 策略/状态模式\n\n帮助我们优化 if-else 结构\n\n```javascript\n  function Strategy (type,a,b) {\n    var Strategyer={\n      add:function (a,b){\n        return a+b\n      }\n      minus:function(a,b){\n        return a-b\n      }\n      division:function (a,b){\n        return a/b\n      }\n    }\n    return Strategyer[type](a,b)\n  }\n```\n\n#### 2.4.2 外观模式\n\n一种套餐化接口的思想，封装常用方法为一个统一的接口\n\n```javascript\n// 划分功能，给使用者一个统一的接口\nfunction tab() {\n  this.dom = null\n}\ntab.prototype.initHTML = function () {}\ntab.prototype.changeTab = function () {}\ntab.prototype.eventBind = function () {\n  var self = this\n  this.dom.onclick = function () {\n    self.changeTab()\n  }\n}\ntab.prototype.init = function (config) {\n  this.initHTML(config)\n  this.eventBind()\n}\n```\n\n#### 2.4.3 迭代器模式\n\n帮助更好的遍历数据\n\n#### 2.4.4 备忘录模式\n\n缓存回到过去的状态\n","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\ntag: 设计模式\nkeywords: 设计模式\ncategories: 设计模式\n---\n\n## 1.设计模式概论\n\n### 1.1 代码与设计模式\n\n#### 🍅 我们写代码到底是在写什么？\n\n我们写项目其实就是写模块然后设计它们之间的沟通，设计模式说白了就是帮助我们更好的设计模块， 更好的组织它们之间的沟通。\n\n#### 🍅 设计模式扮演的角色\n\n- 帮助我们组织模块\n  - 通过一些设计模式，组织模块间的组成结构\n- 帮助我们设计沟通\n  - 有的设计模式可以帮助我们设计模块间如何沟通\n- 提高代码质量\n  - 通过设计模式，让代码更加优雅\n\n#### 🍅 设计原则\n\n1. 开闭原则\n\n   1. 我们的程序要对扩展开放，对修改关闭；我们的程序要给具体使用的时候扩展的接口，但是在具体使用的时候不能让其修改我们的源码，也就是说我们不用修改源码就能扩展功能，像 vue、react 等都有扩展的接口\n\n2. 单一职责原则\n\n   1. 我们的模块只做一件事情，模块的职责越单一越好\n\n3. 依赖倒置原则\n\n   1. 我们的上层模块不要依赖于具体的下层模块，应该依赖于抽象\n\n   2. 如下面的代码，我们在下层和上层之间加一个抽象层；下层如何变动都不会影响到上层，只需更改抽象层即可\n\n   3. ```javascript\n      // 具体层\n      function Food1() {}\n      function Food2() {}\n      function Food3() {}\n\n      // 抽象层\n      function foodList(food) {\n        const foodMap = {\n          food1: new Food1(),\n          food2: new Food2(),\n          food3: new Food3()\n        }\n        return foodMap[food]\n      }\n\n      // 上层\n      function order(food) {\n        return foodList(food)\n      }\n      ```\n\n4. 接口隔离原则\n\n   1. 我们的接口要细化，功能要单一，一个接口不要调用太多方法，使其能力单一，听起来像单一职责原则；但是 2 者的关注点不同， 单一职责原则主要关注于模块本身，接口隔离原则关注于接口；我们尽量细化接口，每个接口做的事情尽量单一化。\n\n5. 迪米特法则\n\n   1. 我们让 2 个对象之间产生沟通，我们最好让 2 个对象之间知道的越少越好，没必要 2 者之间非常的了解；我们的中介者模式是一个很好体现迪米特法则的设计模式，中介者模式让 2 个对象之间没必要直接的沟通，如果直接沟通需要了解 2 者之间的 api 和彼此的调用方式，这个时候我们可以采用一个中介者来转达我们的需求，而不用彼此知道\n\n6. 里氏替换原则\n\n   1. 它主要关注于继承，它的意义是任何使用父类的地方都可以用子类去替换，直白的说我们子类继承父类的时候，我们的子类必须完全保证继承父类的属性和方法，这样的话父类使用的地方，子类可以进行替换\n\n### 1.2 设计模式的分类\n\n1. 创建型\n\n   这些设计模式可以帮助我们优雅地创建对象\n\n   - 工厂模式-大量创建对象\n   - 单例模式-全局只有一个实例\n   - 建造者模式-精细化组合对象\n   - 原型模式-JavaScript 的灵魂\n\n2. 结构型\n\n   帮助优雅地设计代码结构\n\n   - 外观模式-给你的一个套餐\n   - 适配器模式-用适配代替更改\n   - 装饰着模式-更优雅地扩展需求\n   - 享元模式-共享来减少数量\n   - 桥接模式-独立出来，然后再对接出去\n\n3. 行为型\n\n   模块之间行为的模式总结，帮助组织模块行为\n\n   - 观察者模式-第三方转发\n   - 状态模式-用状态代替判断\n   - 策略模式-算法工厂\n   - 职责链模式-像生产线一样组织模块\n   - 命令模式-用命令去解耦\n   - 迭代器模式-告别 for 循环\n\n4. 技巧型\n\n   帮助优化代码的技巧\n\n   - 链模式-链式调用\n   - 委托模式\n   - 数据访问模式-一个方便的数据管理器\n   - 惰性模式-第一次执行完后把状态记录下来\n   - 等待着模式-等你们都回来再吃饭\n\n## 2.设计模式应用\n\n### 2.1.封装对象（创建型设计模式）\n\n#### 2.1.1 工厂模式(如：创建对象)\n\n**工厂模式的基本结构**\n\n```javascript\nfunction Factory (type) {\n    switch (type) {\n        case 'type1'\n        return new Type1()\n        case 'type2'\n        return new Type2()\n        case 'type3'\n        return new Type3()\n    }\n}\n```\n\n工厂模式就是写一个方法，只需调用这个方法，就能拿到想要的对象\n\n#### 2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）\n\n**建造者模式的基本结构**\n\n```javascript\n//  模块1\nfunction Mode1() {}\n// 模块2\nfunction Mode2() {}\n// 最终使用的类\nfunction Final() {\n  this.mode1 = new Model()\n  this.mode2 = new Mode2()\n}\n```\n\n建造者模式就是把一个复杂的类的各个部分，拆分成独立的类，然后再组合成一个最终的类\n\n#### 2.1.3 单例模式（如： Vuex、Vue-router）\n\n**单例模式的基本结构**\n\n单例模式的做法不是很固定，但是要保证全局只有一个对象的思想\n\n```javascript\n// 作为单例实例化的对象\nlet SingLeton = function (name) {\n  this.name = name\n}\n/*\n在SingLeton挂在一个getInstance方法，只能通过getInstance方法来获取\nSingLeton的实例化对象\n*/\nSingLeton.getInstance = function (name) {\n  if (this.instance) {\n    return this.instance\n  }\n  return (this.instance = new SingLeton(name))\n}\n```\n\n通过一个方法，使用时只允许通过此方法拿到存在内部的同一实例化的对象\n\n### 2.2 提高复用性\n\n#### 2.2.1 桥接模式\n\n这个模式和建造者模式很类似，拆分再组合。但是建造者模式的核心是如何去构造对象，桥接模式是把耦合功能抽离出去\n\n```javascript\n// 有三种形状，每种形状都有3种颜色\nfunction rect(color) {\n  //矩形\n  showcolor(color)\n}\nfunction circle(color) {\n  // 圆形\n  showcolor(color)\n}\nfunction delta(color) {\n  // 三角形\n  showcolor(color)\n}\n\nnew circle('red')\n```\n\n#### 2.2.2 享元模式\n\n提取出公有部分与私有部分，私有部分作为外部数据传入(抽离一个数组)，从而减少对象数量\n\n```javascript\n // 有一百种不同文字的弹窗，每种弹窗行为相同，但是文字和样式不同，我们没必要新间一百个弹窗对象\n    function Pop(){\n    }\n    // 保留同样的行为\n    Pop.prototype.action=function(){}\n    //显示\n    Pop.prototype.show=function(){}\n    // 提取出每个弹窗不同的部分作为一个外部数组\n    var popArr=[\n        {text:\"window1\",style:[400,400]}\n        {text:\"window2\",style:[400,200]}\n    ]\n\n    var poper=new Pop()\n\n    for(var i=0;i<100;i++){\n        poper.show(popArr[i])\n    }\n```\n\n### 2.3 提高可扩展性\n\n#### 2.3.1 适配器模式\n\n当面临两个新老模块间接口 api 不匹配，可以用适配来转化 api\n\n```javascript\n// A框架调用的方式\nA.c()\n// 假如我们项目中换成了jQuey，我们不想全部去替换A方法，就用适配器的方法\nA.c = function () {\n  return $.on.apply(this.arguments)\n}\n```\n\n#### 2.3.2 装饰者模式（如：Vue 重写数组方法）\n\n当老的方法，不方便去直接修改，可以通装饰者来增加功能\n\n```javascript\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nimport { def } from '../util/index'\n\nconst arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\nconst methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator(...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.dep.notify()\n    return result\n  })\n})\n```\n\n#### 2.3.3 命令模式\n\n解耦实现与具体命令，让是实现端和命令端扩展的更轻松\n\n```javascript\nvar createImg = (function () {\n  var action = {\n    create: function (obj) {\n      var htmlArr = []\n      var _htmlstring = ''\n      var _htmlTemplate = \"<div><img src='{{img-url}}' /></div><h2>{{title}}</h2>\"\n      var displayWay = {\n        normal: function (arr) {\n          return arr\n        },\n        reverse: function (arr) {\n          return arr.reverse\n        }\n      }\n\n      obj.imgArr.forEach((img) => {\n        var _html\n        _html = _htmlTemplate.replace('{{img-url}}', img.img).replace('{{title}}', img.title)\n        htmlArr.push(_html)\n      })\n      htmlArr = displayWay[obj.type](htmlArr)\n      _htmlstring = htmlArr.join('')\n      return '<div>' + _htmlstring + '</div>'\n    },\n    display: function (obj) {\n      var _html = this.create(obj)\n      obj.target.innerHTML = _html\n    }\n  }\n\n  return function excute(obj) {\n    var _default = {\n      imgArr: [{ img: 'xxxx', title: 'default title' }],\n      type: 'normal',\n      target: document.body\n    }\n    for (var item in _default) {\n      _default[item] = obj[item] || _default[item]\n    }\n    action.display(_default)\n  }\n})()\ncreateImg({\n  imgArr: [\n    { img: 'xxxx', title: 'default title1' },\n    { img: 'xxxx', title: 'default title2' }\n  ],\n  type: 'normal'\n})\n```\n\n#### 2.3.4 观察者模式\n\n适用于不适合直接沟通的模块之间的组织\n\n```javascript\nfunction observe {\n  this.message={}\n}\n\nobserve.prototype.regist=function(type,fn) {\n  this.message[type]=fn\n}\n\nobserve.prototype.fire=function(type){\n  this.message[type]()\n}\n\nobserve.prototype.remove=function(type){\n  this.message[type]=null\n}\n```\n\n#### 2.3.5 职责链模式\n\n组织同步模块，把要做的事情划分为模块，要做的事情一次传递\n\n```javascript\n// 表单事件绑定->表单前端验证->表单后端验证\n// 思想：把你要做的事情拆分为模块，模块之间只做自己模块的事情\n\ninput.onblur = function () {\n  var _value = input.value\n  var _arr = [font, middle, back, fontAgain]\n  async function test() {\n    var _result = _value\n    while (_arr.length > 0) {\n      _result = await _arr.shift()(_result)\n    }\n    return _result\n  }\n  test().then((res) => {\n    console.log(res)\n  })\n}\n\nfunction font(result) {}\n\nfunction middle(result) {}\n\nfunction back(result) {}\n\nfunction fontAgain(result) {}\n```\n\n#### 2.3.6 访问者模式\n\n解耦数据操作与数据结构\n\n```javascript\nvar data = []\n\nvar handler = function () {}\n\nhandler.prototype.get = function () {}\n\nvar vistor = function (handler, data) {\n  handler.get(data)\n}\n```\n\n### 2.4 提高代码质量\n\n#### 2.4.1 策略/状态模式\n\n帮助我们优化 if-else 结构\n\n```javascript\n  function Strategy (type,a,b) {\n    var Strategyer={\n      add:function (a,b){\n        return a+b\n      }\n      minus:function(a,b){\n        return a-b\n      }\n      division:function (a,b){\n        return a/b\n      }\n    }\n    return Strategyer[type](a,b)\n  }\n```\n\n#### 2.4.2 外观模式\n\n一种套餐化接口的思想，封装常用方法为一个统一的接口\n\n```javascript\n// 划分功能，给使用者一个统一的接口\nfunction tab() {\n  this.dom = null\n}\ntab.prototype.initHTML = function () {}\ntab.prototype.changeTab = function () {}\ntab.prototype.eventBind = function () {\n  var self = this\n  this.dom.onclick = function () {\n    self.changeTab()\n  }\n}\ntab.prototype.init = function (config) {\n  this.initHTML(config)\n  this.eventBind()\n}\n```\n\n#### 2.4.3 迭代器模式\n\n帮助更好的遍历数据\n\n#### 2.4.4 备忘录模式\n\n缓存回到过去的状态\n","slug":"设计模式","published":1,"date":"2022-12-06T09:12:16.385Z","updated":"2023-02-02T07:10:28.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9l0000qi024ekbq2km7","content":"<h2 id=\"1-设计模式概论\"><a href=\"#1-设计模式概论\" class=\"headerlink\" title=\"1.设计模式概论\"></a>1.设计模式概论</h2><h3 id=\"1-1-代码与设计模式\"><a href=\"#1-1-代码与设计模式\" class=\"headerlink\" title=\"1.1 代码与设计模式\"></a>1.1 代码与设计模式</h3><h4 id=\"🍅-我们写代码到底是在写什么？\"><a href=\"#🍅-我们写代码到底是在写什么？\" class=\"headerlink\" title=\"🍅 我们写代码到底是在写什么？\"></a>🍅 我们写代码到底是在写什么？</h4><p>我们写项目其实就是写模块然后设计它们之间的沟通，设计模式说白了就是帮助我们更好的设计模块， 更好的组织它们之间的沟通。</p>\n<h4 id=\"🍅-设计模式扮演的角色\"><a href=\"#🍅-设计模式扮演的角色\" class=\"headerlink\" title=\"🍅 设计模式扮演的角色\"></a>🍅 设计模式扮演的角色</h4><ul>\n<li>帮助我们组织模块<ul>\n<li>通过一些设计模式，组织模块间的组成结构</li>\n</ul>\n</li>\n<li>帮助我们设计沟通<ul>\n<li>有的设计模式可以帮助我们设计模块间如何沟通</li>\n</ul>\n</li>\n<li>提高代码质量<ul>\n<li>通过设计模式，让代码更加优雅</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"🍅-设计原则\"><a href=\"#🍅-设计原则\" class=\"headerlink\" title=\"🍅 设计原则\"></a>🍅 设计原则</h4><ol>\n<li><p>开闭原则</p>\n<ol>\n<li>我们的程序要对扩展开放，对修改关闭；我们的程序要给具体使用的时候扩展的接口，但是在具体使用的时候不能让其修改我们的源码，也就是说我们不用修改源码就能扩展功能，像 vue、react 等都有扩展的接口</li>\n</ol>\n</li>\n<li><p>单一职责原则</p>\n<ol>\n<li>我们的模块只做一件事情，模块的职责越单一越好</li>\n</ol>\n</li>\n<li><p>依赖倒置原则</p>\n<ol>\n<li><p>我们的上层模块不要依赖于具体的下层模块，应该依赖于抽象</p>\n</li>\n<li><p>如下面的代码，我们在下层和上层之间加一个抽象层；下层如何变动都不会影响到上层，只需更改抽象层即可</p>\n</li>\n<li><p>```javascript<br>// 具体层<br>function Food1() {}<br>function Food2() {}<br>function Food3() {}</p>\n<p>// 抽象层<br>function foodList(food) {<br>  const foodMap = {</p>\n<pre><code class=\"hljs\">food1: new Food1(),\nfood2: new Food2(),\nfood3: new Food3()\n</code></pre>\n<p>  }<br>  return foodMap[food]<br>}</p>\n<p>// 上层<br>function order(food) {<br>  return foodList(food)<br>}</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><br><span class=\"hljs-bullet\">4.</span> 接口隔离原则<br><br><span class=\"hljs-bullet\">   1.</span> 我们的接口要细化，功能要单一，一个接口不要调用太多方法，使其能力单一，听起来像单一职责原则；但是 2 者的关注点不同， 单一职责原则主要关注于模块本身，接口隔离原则关注于接口；我们尽量细化接口，每个接口做的事情尽量单一化。<br><br><span class=\"hljs-bullet\">5.</span> 迪米特法则<br><br><span class=\"hljs-bullet\">   1.</span> 我们让 2 个对象之间产生沟通，我们最好让 2 个对象之间知道的越少越好，没必要 2 者之间非常的了解；我们的中介者模式是一个很好体现迪米特法则的设计模式，中介者模式让 2 个对象之间没必要直接的沟通，如果直接沟通需要了解 2 者之间的 api 和彼此的调用方式，这个时候我们可以采用一个中介者来转达我们的需求，而不用彼此知道<br><br><span class=\"hljs-bullet\">6.</span> 里氏替换原则<br><br><span class=\"hljs-bullet\">   1.</span> 它主要关注于继承，它的意义是任何使用父类的地方都可以用子类去替换，直白的说我们子类继承父类的时候，我们的子类必须完全保证继承父类的属性和方法，这样的话父类使用的地方，子类可以进行替换<br><br><span class=\"hljs-section\">### 1.2 设计模式的分类</span><br><br><span class=\"hljs-bullet\">1.</span> 创建型<br><br>   这些设计模式可以帮助我们优雅地创建对象<br><br><span class=\"hljs-bullet\">   -</span> 工厂模式-大量创建对象<br><span class=\"hljs-bullet\">   -</span> 单例模式-全局只有一个实例<br><span class=\"hljs-bullet\">   -</span> 建造者模式-精细化组合对象<br><span class=\"hljs-bullet\">   -</span> 原型模式-JavaScript 的灵魂<br><br><span class=\"hljs-bullet\">2.</span> 结构型<br><br>   帮助优雅地设计代码结构<br><br><span class=\"hljs-bullet\">   -</span> 外观模式-给你的一个套餐<br><span class=\"hljs-bullet\">   -</span> 适配器模式-用适配代替更改<br><span class=\"hljs-bullet\">   -</span> 装饰着模式-更优雅地扩展需求<br><span class=\"hljs-bullet\">   -</span> 享元模式-共享来减少数量<br><span class=\"hljs-bullet\">   -</span> 桥接模式-独立出来，然后再对接出去<br><br><span class=\"hljs-bullet\">3.</span> 行为型<br><br>   模块之间行为的模式总结，帮助组织模块行为<br><br><span class=\"hljs-bullet\">   -</span> 观察者模式-第三方转发<br><span class=\"hljs-bullet\">   -</span> 状态模式-用状态代替判断<br><span class=\"hljs-bullet\">   -</span> 策略模式-算法工厂<br><span class=\"hljs-bullet\">   -</span> 职责链模式-像生产线一样组织模块<br><span class=\"hljs-bullet\">   -</span> 命令模式-用命令去解耦<br><span class=\"hljs-bullet\">   -</span> 迭代器模式-告别 for 循环<br><br><span class=\"hljs-bullet\">4.</span> 技巧型<br><br>   帮助优化代码的技巧<br><br><span class=\"hljs-bullet\">   -</span> 链模式-链式调用<br><span class=\"hljs-bullet\">   -</span> 委托模式<br><span class=\"hljs-bullet\">   -</span> 数据访问模式-一个方便的数据管理器<br><span class=\"hljs-bullet\">   -</span> 惰性模式-第一次执行完后把状态记录下来<br><span class=\"hljs-bullet\">   -</span> 等待着模式-等你们都回来再吃饭<br><br><span class=\"hljs-section\">## 2.设计模式应用</span><br><br><span class=\"hljs-section\">### 2.1.封装对象（创建型设计模式）</span><br><br><span class=\"hljs-section\">#### 2.1.1 工厂模式(如：创建对象)</span><br><br><span class=\"hljs-strong\">**工厂模式的基本结构**</span><br><br><span class=\"hljs-code\">```javascript</span><br><span class=\"hljs-code\">function Factory (type) &#123;</span><br><span class=\"hljs-code\">    switch (type) &#123;</span><br><span class=\"hljs-code\">        case &#x27;type1&#x27;</span><br><span class=\"hljs-code\">        return new Type1()</span><br><span class=\"hljs-code\">        case &#x27;type2&#x27;</span><br><span class=\"hljs-code\">        return new Type2()</span><br><span class=\"hljs-code\">        case &#x27;type3&#x27;</span><br><span class=\"hljs-code\">        return new Type3()</span><br><span class=\"hljs-code\">    &#125;</span><br><span class=\"hljs-code\">&#125;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>工厂模式就是写一个方法，只需调用这个方法，就能拿到想要的对象</p>\n<h4 id=\"2-1-2-建造者模式（如：Vue2-源码中-Vue-类的初始化）\"><a href=\"#2-1-2-建造者模式（如：Vue2-源码中-Vue-类的初始化）\" class=\"headerlink\" title=\"2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）\"></a>2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）</h4><p><strong>建造者模式的基本结构</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//  模块1</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Mode1</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-comment\">// 模块2</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Mode2</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-comment\">// 最终使用的类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Final</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode1</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Model</span>()<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode2</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Mode2</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>建造者模式就是把一个复杂的类的各个部分，拆分成独立的类，然后再组合成一个最终的类</p>\n<h4 id=\"2-1-3-单例模式（如：-Vuex、Vue-router）\"><a href=\"#2-1-3-单例模式（如：-Vuex、Vue-router）\" class=\"headerlink\" title=\"2.1.3 单例模式（如： Vuex、Vue-router）\"></a>2.1.3 单例模式（如： Vuex、Vue-router）</h4><p><strong>单例模式的基本结构</strong></p>\n<p>单例模式的做法不是很固定，但是要保证全局只有一个对象的思想</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 作为单例实例化的对象</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">SingLeton</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">在SingLeton挂在一个getInstance方法，只能通过getInstance方法来获取</span><br><span class=\"hljs-comment\">SingLeton的实例化对象</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-title class_\">SingLeton</span>.<span class=\"hljs-property\">getInstance</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SingLeton</span>(name))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过一个方法，使用时只允许通过此方法拿到存在内部的同一实例化的对象</p>\n<h3 id=\"2-2-提高复用性\"><a href=\"#2-2-提高复用性\" class=\"headerlink\" title=\"2.2 提高复用性\"></a>2.2 提高复用性</h3><h4 id=\"2-2-1-桥接模式\"><a href=\"#2-2-1-桥接模式\" class=\"headerlink\" title=\"2.2.1 桥接模式\"></a>2.2.1 桥接模式</h4><p>这个模式和建造者模式很类似，拆分再组合。但是建造者模式的核心是如何去构造对象，桥接模式是把耦合功能抽离出去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有三种形状，每种形状都有3种颜色</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">//矩形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">// 圆形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">delta</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">// 三角形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-string\">&#x27;red&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-享元模式\"><a href=\"#2-2-2-享元模式\" class=\"headerlink\" title=\"2.2.2 享元模式\"></a>2.2.2 享元模式</h4><p>提取出公有部分与私有部分，私有部分作为外部数据传入(抽离一个数组)，从而减少对象数量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有一百种不同文字的弹窗，每种弹窗行为相同，但是文字和样式不同，我们没必要新间一百个弹窗对象</span><br>   <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Pop</span>(<span class=\"hljs-params\"></span>)&#123;<br>   &#125;<br>   <span class=\"hljs-comment\">// 保留同样的行为</span><br>   <span class=\"hljs-title class_\">Pop</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">action</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>   <span class=\"hljs-comment\">//显示</span><br>   <span class=\"hljs-title class_\">Pop</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">show</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>   <span class=\"hljs-comment\">// 提取出每个弹窗不同的部分作为一个外部数组</span><br>   <span class=\"hljs-keyword\">var</span> popArr=[<br>       &#123;<span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">&quot;window1&quot;</span>,<span class=\"hljs-attr\">style</span>:[<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>]&#125;<br>       &#123;<span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">&quot;window2&quot;</span>,<span class=\"hljs-attr\">style</span>:[<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">200</span>]&#125;<br>   ]<br><br>   <span class=\"hljs-keyword\">var</span> poper=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pop</span>()<br><br>   <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)&#123;<br>       poper.<span class=\"hljs-title function_\">show</span>(popArr[i])<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-提高可扩展性\"><a href=\"#2-3-提高可扩展性\" class=\"headerlink\" title=\"2.3 提高可扩展性\"></a>2.3 提高可扩展性</h3><h4 id=\"2-3-1-适配器模式\"><a href=\"#2-3-1-适配器模式\" class=\"headerlink\" title=\"2.3.1 适配器模式\"></a>2.3.1 适配器模式</h4><p>当面临两个新老模块间接口 api 不匹配，可以用适配来转化 api</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// A框架调用的方式</span><br>A.<span class=\"hljs-title function_\">c</span>()<br><span class=\"hljs-comment\">// 假如我们项目中换成了jQuey，我们不想全部去替换A方法，就用适配器的方法</span><br>A.<span class=\"hljs-property\">c</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> $.on.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arguments</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-装饰者模式（如：Vue-重写数组方法）\"><a href=\"#2-3-2-装饰者模式（如：Vue-重写数组方法）\" class=\"headerlink\" title=\"2.3.2 装饰者模式（如：Vue 重写数组方法）\"></a>2.3.2 装饰者模式（如：Vue 重写数组方法）</h4><p>当老的方法，不方便去直接修改，可以通装饰者来增加功能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * not type checking this file because flow doesn&#x27;t play well with</span><br><span class=\"hljs-comment\"> * dynamically accessing methods on Array prototype</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">import</span> &#123; def &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../util/index&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> arrayProto = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> arrayMethods = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(arrayProto)<br><br><span class=\"hljs-keyword\">const</span> methodsToPatch = [<span class=\"hljs-string\">&#x27;push&#x27;</span>, <span class=\"hljs-string\">&#x27;pop&#x27;</span>, <span class=\"hljs-string\">&#x27;shift&#x27;</span>, <span class=\"hljs-string\">&#x27;unshift&#x27;</span>, <span class=\"hljs-string\">&#x27;splice&#x27;</span>, <span class=\"hljs-string\">&#x27;sort&#x27;</span>, <span class=\"hljs-string\">&#x27;reverse&#x27;</span>]<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Intercept mutating methods and emit events</span><br><span class=\"hljs-comment\"> */</span><br>methodsToPatch.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) &#123;<br>  <span class=\"hljs-comment\">// cache original method</span><br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]<br>  <span class=\"hljs-title function_\">def</span>(arrayMethods, method, <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mutator</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> result = original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    <span class=\"hljs-keyword\">const</span> ob = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__ob__</span><br>    <span class=\"hljs-keyword\">let</span> inserted<br>    <span class=\"hljs-keyword\">switch</span> (method) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;push&#x27;</span>:<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;splice&#x27;</span>:<br>        inserted = args.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>)<br>        <span class=\"hljs-keyword\">break</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (inserted) ob.<span class=\"hljs-title function_\">observeArray</span>(inserted)<br>    <span class=\"hljs-comment\">// notify change</span><br>    ob.<span class=\"hljs-property\">dep</span>.<span class=\"hljs-title function_\">notify</span>()<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-命令模式\"><a href=\"#2-3-3-命令模式\" class=\"headerlink\" title=\"2.3.3 命令模式\"></a>2.3.3 命令模式</h4><p>解耦实现与具体命令，让是实现端和命令端扩展的更轻松</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> createImg = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> action = &#123;<br>    <span class=\"hljs-attr\">create</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) &#123;<br>      <span class=\"hljs-keyword\">var</span> htmlArr = []<br>      <span class=\"hljs-keyword\">var</span> _htmlstring = <span class=\"hljs-string\">&#x27;&#x27;</span><br>      <span class=\"hljs-keyword\">var</span> _htmlTemplate = <span class=\"hljs-string\">&quot;&lt;div&gt;&lt;img src=&#x27;&#123;&#123;img-url&#125;&#125;&#x27; /&gt;&lt;/div&gt;&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;&quot;</span><br>      <span class=\"hljs-keyword\">var</span> displayWay = &#123;<br>        <span class=\"hljs-attr\">normal</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> arr<br>        &#125;,<br>        <span class=\"hljs-attr\">reverse</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> arr.<span class=\"hljs-property\">reverse</span><br>        &#125;<br>      &#125;<br><br>      obj.<span class=\"hljs-property\">imgArr</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">img</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">var</span> _html<br>        _html = _htmlTemplate.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;&#123;&#123;img-url&#125;&#125;&#x27;</span>, img.<span class=\"hljs-property\">img</span>).<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;&#123;&#123;title&#125;&#125;&#x27;</span>, img.<span class=\"hljs-property\">title</span>)<br>        htmlArr.<span class=\"hljs-title function_\">push</span>(_html)<br>      &#125;)<br>      htmlArr = displayWay[obj.<span class=\"hljs-property\">type</span>](htmlArr)<br>      _htmlstring = htmlArr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&lt;div&gt;&#x27;</span> + _htmlstring + <span class=\"hljs-string\">&#x27;&lt;/div&gt;&#x27;</span><br>    &#125;,<br>    <span class=\"hljs-attr\">display</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) &#123;<br>      <span class=\"hljs-keyword\">var</span> _html = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">create</span>(obj)<br>      obj.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">innerHTML</span> = _html<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">excute</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> _default = &#123;<br>      <span class=\"hljs-attr\">imgArr</span>: [&#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title&#x27;</span> &#125;],<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;normal&#x27;</span>,<br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span><br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> item <span class=\"hljs-keyword\">in</span> _default) &#123;<br>      _default[item] = obj[item] || _default[item]<br>    &#125;<br>    action.<span class=\"hljs-title function_\">display</span>(_default)<br>  &#125;<br>&#125;)()<br><span class=\"hljs-title function_\">createImg</span>(&#123;<br>  <span class=\"hljs-attr\">imgArr</span>: [<br>    &#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title1&#x27;</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title2&#x27;</span> &#125;<br>  ],<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;normal&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-4-观察者模式\"><a href=\"#2-3-4-观察者模式\" class=\"headerlink\" title=\"2.3.4 观察者模式\"></a>2.3.4 观察者模式</h4><p>适用于不适合直接沟通的模块之间的组织</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> observe &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>=&#123;&#125;<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">regist</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type,fn</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]=fn<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">fire</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type</span>)&#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]()<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">remove</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type</span>)&#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]=<span class=\"hljs-literal\">null</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-5-职责链模式\"><a href=\"#2-3-5-职责链模式\" class=\"headerlink\" title=\"2.3.5 职责链模式\"></a>2.3.5 职责链模式</h4><p>组织同步模块，把要做的事情划分为模块，要做的事情一次传递</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 表单事件绑定-&gt;表单前端验证-&gt;表单后端验证</span><br><span class=\"hljs-comment\">// 思想：把你要做的事情拆分为模块，模块之间只做自己模块的事情</span><br><br>input.<span class=\"hljs-property\">onblur</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> _value = input.<span class=\"hljs-property\">value</span><br>  <span class=\"hljs-keyword\">var</span> _arr = [font, middle, back, fontAgain]<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> _result = _value<br>    <span class=\"hljs-keyword\">while</span> (_arr.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      _result = <span class=\"hljs-keyword\">await</span> _arr.<span class=\"hljs-title function_\">shift</span>()(_result)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> _result<br>  &#125;<br>  <span class=\"hljs-title function_\">test</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">font</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middle</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">back</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fontAgain</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-6-访问者模式\"><a href=\"#2-3-6-访问者模式\" class=\"headerlink\" title=\"2.3.6 访问者模式\"></a>2.3.6 访问者模式</h4><p>解耦数据操作与数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> data = []<br><br><span class=\"hljs-keyword\">var</span> handler = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>handler.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">get</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">var</span> vistor = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">handler, data</span>) &#123;<br>  handler.<span class=\"hljs-title function_\">get</span>(data)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-提高代码质量\"><a href=\"#2-4-提高代码质量\" class=\"headerlink\" title=\"2.4 提高代码质量\"></a>2.4 提高代码质量</h3><h4 id=\"2-4-1-策略-状态模式\"><a href=\"#2-4-1-策略-状态模式\" class=\"headerlink\" title=\"2.4.1 策略/状态模式\"></a>2.4.1 策略/状态模式</h4><p>帮助我们优化 if-else 结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Strategy</span> (type,a,b) &#123;<br>  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Strategyer</span>=&#123;<br>    <span class=\"hljs-attr\">add</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a+b<br>    &#125;<br>    <span class=\"hljs-attr\">minus</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a-b<br>    &#125;<br>    <span class=\"hljs-attr\">division</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a/b<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Strategyer</span>[type](a,b)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-外观模式\"><a href=\"#2-4-2-外观模式\" class=\"headerlink\" title=\"2.4.2 外观模式\"></a>2.4.2 外观模式</h4><p>一种套餐化接口的思想，封装常用方法为一个统一的接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 划分功能，给使用者一个统一的接口</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tab</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-literal\">null</span><br>&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">initHTML</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">changeTab</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eventBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    self.<span class=\"hljs-title function_\">changeTab</span>()<br>  &#125;<br>&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">init</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">config</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">initHTML</span>(config)<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">eventBind</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-3-迭代器模式\"><a href=\"#2-4-3-迭代器模式\" class=\"headerlink\" title=\"2.4.3 迭代器模式\"></a>2.4.3 迭代器模式</h4><p>帮助更好的遍历数据</p>\n<h4 id=\"2-4-4-备忘录模式\"><a href=\"#2-4-4-备忘录模式\" class=\"headerlink\" title=\"2.4.4 备忘录模式\"></a>2.4.4 备忘录模式</h4><p>缓存回到过去的状态</p>\n","site":{"data":{}},"wordcount":7492,"excerpt":"","more":"<h2 id=\"1-设计模式概论\"><a href=\"#1-设计模式概论\" class=\"headerlink\" title=\"1.设计模式概论\"></a>1.设计模式概论</h2><h3 id=\"1-1-代码与设计模式\"><a href=\"#1-1-代码与设计模式\" class=\"headerlink\" title=\"1.1 代码与设计模式\"></a>1.1 代码与设计模式</h3><h4 id=\"🍅-我们写代码到底是在写什么？\"><a href=\"#🍅-我们写代码到底是在写什么？\" class=\"headerlink\" title=\"🍅 我们写代码到底是在写什么？\"></a>🍅 我们写代码到底是在写什么？</h4><p>我们写项目其实就是写模块然后设计它们之间的沟通，设计模式说白了就是帮助我们更好的设计模块， 更好的组织它们之间的沟通。</p>\n<h4 id=\"🍅-设计模式扮演的角色\"><a href=\"#🍅-设计模式扮演的角色\" class=\"headerlink\" title=\"🍅 设计模式扮演的角色\"></a>🍅 设计模式扮演的角色</h4><ul>\n<li>帮助我们组织模块<ul>\n<li>通过一些设计模式，组织模块间的组成结构</li>\n</ul>\n</li>\n<li>帮助我们设计沟通<ul>\n<li>有的设计模式可以帮助我们设计模块间如何沟通</li>\n</ul>\n</li>\n<li>提高代码质量<ul>\n<li>通过设计模式，让代码更加优雅</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"🍅-设计原则\"><a href=\"#🍅-设计原则\" class=\"headerlink\" title=\"🍅 设计原则\"></a>🍅 设计原则</h4><ol>\n<li><p>开闭原则</p>\n<ol>\n<li>我们的程序要对扩展开放，对修改关闭；我们的程序要给具体使用的时候扩展的接口，但是在具体使用的时候不能让其修改我们的源码，也就是说我们不用修改源码就能扩展功能，像 vue、react 等都有扩展的接口</li>\n</ol>\n</li>\n<li><p>单一职责原则</p>\n<ol>\n<li>我们的模块只做一件事情，模块的职责越单一越好</li>\n</ol>\n</li>\n<li><p>依赖倒置原则</p>\n<ol>\n<li><p>我们的上层模块不要依赖于具体的下层模块，应该依赖于抽象</p>\n</li>\n<li><p>如下面的代码，我们在下层和上层之间加一个抽象层；下层如何变动都不会影响到上层，只需更改抽象层即可</p>\n</li>\n<li><p>```javascript<br>// 具体层<br>function Food1() {}<br>function Food2() {}<br>function Food3() {}</p>\n<p>// 抽象层<br>function foodList(food) {<br>  const foodMap = {</p>\n<pre><code>food1: new Food1(),\nfood2: new Food2(),\nfood3: new Food3()\n</code></pre>\n<p>  }<br>  return foodMap[food]<br>}</p>\n<p>// 上层<br>function order(food) {<br>  return foodList(food)<br>}</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><br><span class=\"hljs-bullet\">4.</span> 接口隔离原则<br><br><span class=\"hljs-bullet\">   1.</span> 我们的接口要细化，功能要单一，一个接口不要调用太多方法，使其能力单一，听起来像单一职责原则；但是 2 者的关注点不同， 单一职责原则主要关注于模块本身，接口隔离原则关注于接口；我们尽量细化接口，每个接口做的事情尽量单一化。<br><br><span class=\"hljs-bullet\">5.</span> 迪米特法则<br><br><span class=\"hljs-bullet\">   1.</span> 我们让 2 个对象之间产生沟通，我们最好让 2 个对象之间知道的越少越好，没必要 2 者之间非常的了解；我们的中介者模式是一个很好体现迪米特法则的设计模式，中介者模式让 2 个对象之间没必要直接的沟通，如果直接沟通需要了解 2 者之间的 api 和彼此的调用方式，这个时候我们可以采用一个中介者来转达我们的需求，而不用彼此知道<br><br><span class=\"hljs-bullet\">6.</span> 里氏替换原则<br><br><span class=\"hljs-bullet\">   1.</span> 它主要关注于继承，它的意义是任何使用父类的地方都可以用子类去替换，直白的说我们子类继承父类的时候，我们的子类必须完全保证继承父类的属性和方法，这样的话父类使用的地方，子类可以进行替换<br><br><span class=\"hljs-section\">### 1.2 设计模式的分类</span><br><br><span class=\"hljs-bullet\">1.</span> 创建型<br><br>   这些设计模式可以帮助我们优雅地创建对象<br><br><span class=\"hljs-bullet\">   -</span> 工厂模式-大量创建对象<br><span class=\"hljs-bullet\">   -</span> 单例模式-全局只有一个实例<br><span class=\"hljs-bullet\">   -</span> 建造者模式-精细化组合对象<br><span class=\"hljs-bullet\">   -</span> 原型模式-JavaScript 的灵魂<br><br><span class=\"hljs-bullet\">2.</span> 结构型<br><br>   帮助优雅地设计代码结构<br><br><span class=\"hljs-bullet\">   -</span> 外观模式-给你的一个套餐<br><span class=\"hljs-bullet\">   -</span> 适配器模式-用适配代替更改<br><span class=\"hljs-bullet\">   -</span> 装饰着模式-更优雅地扩展需求<br><span class=\"hljs-bullet\">   -</span> 享元模式-共享来减少数量<br><span class=\"hljs-bullet\">   -</span> 桥接模式-独立出来，然后再对接出去<br><br><span class=\"hljs-bullet\">3.</span> 行为型<br><br>   模块之间行为的模式总结，帮助组织模块行为<br><br><span class=\"hljs-bullet\">   -</span> 观察者模式-第三方转发<br><span class=\"hljs-bullet\">   -</span> 状态模式-用状态代替判断<br><span class=\"hljs-bullet\">   -</span> 策略模式-算法工厂<br><span class=\"hljs-bullet\">   -</span> 职责链模式-像生产线一样组织模块<br><span class=\"hljs-bullet\">   -</span> 命令模式-用命令去解耦<br><span class=\"hljs-bullet\">   -</span> 迭代器模式-告别 for 循环<br><br><span class=\"hljs-bullet\">4.</span> 技巧型<br><br>   帮助优化代码的技巧<br><br><span class=\"hljs-bullet\">   -</span> 链模式-链式调用<br><span class=\"hljs-bullet\">   -</span> 委托模式<br><span class=\"hljs-bullet\">   -</span> 数据访问模式-一个方便的数据管理器<br><span class=\"hljs-bullet\">   -</span> 惰性模式-第一次执行完后把状态记录下来<br><span class=\"hljs-bullet\">   -</span> 等待着模式-等你们都回来再吃饭<br><br><span class=\"hljs-section\">## 2.设计模式应用</span><br><br><span class=\"hljs-section\">### 2.1.封装对象（创建型设计模式）</span><br><br><span class=\"hljs-section\">#### 2.1.1 工厂模式(如：创建对象)</span><br><br><span class=\"hljs-strong\">**工厂模式的基本结构**</span><br><br><span class=\"hljs-code\">```javascript</span><br><span class=\"hljs-code\">function Factory (type) &#123;</span><br><span class=\"hljs-code\">    switch (type) &#123;</span><br><span class=\"hljs-code\">        case &#x27;type1&#x27;</span><br><span class=\"hljs-code\">        return new Type1()</span><br><span class=\"hljs-code\">        case &#x27;type2&#x27;</span><br><span class=\"hljs-code\">        return new Type2()</span><br><span class=\"hljs-code\">        case &#x27;type3&#x27;</span><br><span class=\"hljs-code\">        return new Type3()</span><br><span class=\"hljs-code\">    &#125;</span><br><span class=\"hljs-code\">&#125;</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p>工厂模式就是写一个方法，只需调用这个方法，就能拿到想要的对象</p>\n<h4 id=\"2-1-2-建造者模式（如：Vue2-源码中-Vue-类的初始化）\"><a href=\"#2-1-2-建造者模式（如：Vue2-源码中-Vue-类的初始化）\" class=\"headerlink\" title=\"2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）\"></a>2.1.2 建造者模式（如：Vue2 源码中 Vue 类的初始化）</h4><p><strong>建造者模式的基本结构</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//  模块1</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Mode1</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-comment\">// 模块2</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Mode2</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-comment\">// 最终使用的类</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Final</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode1</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Model</span>()<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mode2</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Mode2</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>建造者模式就是把一个复杂的类的各个部分，拆分成独立的类，然后再组合成一个最终的类</p>\n<h4 id=\"2-1-3-单例模式（如：-Vuex、Vue-router）\"><a href=\"#2-1-3-单例模式（如：-Vuex、Vue-router）\" class=\"headerlink\" title=\"2.1.3 单例模式（如： Vuex、Vue-router）\"></a>2.1.3 单例模式（如： Vuex、Vue-router）</h4><p><strong>单例模式的基本结构</strong></p>\n<p>单例模式的做法不是很固定，但是要保证全局只有一个对象的思想</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 作为单例实例化的对象</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">SingLeton</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">在SingLeton挂在一个getInstance方法，只能通过getInstance方法来获取</span><br><span class=\"hljs-comment\">SingLeton的实例化对象</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-title class_\">SingLeton</span>.<span class=\"hljs-property\">getInstance</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">instance</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SingLeton</span>(name))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过一个方法，使用时只允许通过此方法拿到存在内部的同一实例化的对象</p>\n<h3 id=\"2-2-提高复用性\"><a href=\"#2-2-提高复用性\" class=\"headerlink\" title=\"2.2 提高复用性\"></a>2.2 提高复用性</h3><h4 id=\"2-2-1-桥接模式\"><a href=\"#2-2-1-桥接模式\" class=\"headerlink\" title=\"2.2.1 桥接模式\"></a>2.2.1 桥接模式</h4><p>这个模式和建造者模式很类似，拆分再组合。但是建造者模式的核心是如何去构造对象，桥接模式是把耦合功能抽离出去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有三种形状，每种形状都有3种颜色</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">//矩形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">// 圆形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">delta</span>(<span class=\"hljs-params\">color</span>) &#123;<br>  <span class=\"hljs-comment\">// 三角形</span><br>  <span class=\"hljs-title function_\">showcolor</span>(color)<br>&#125;<br><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-string\">&#x27;red&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-享元模式\"><a href=\"#2-2-2-享元模式\" class=\"headerlink\" title=\"2.2.2 享元模式\"></a>2.2.2 享元模式</h4><p>提取出公有部分与私有部分，私有部分作为外部数据传入(抽离一个数组)，从而减少对象数量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有一百种不同文字的弹窗，每种弹窗行为相同，但是文字和样式不同，我们没必要新间一百个弹窗对象</span><br>   <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Pop</span>(<span class=\"hljs-params\"></span>)&#123;<br>   &#125;<br>   <span class=\"hljs-comment\">// 保留同样的行为</span><br>   <span class=\"hljs-title class_\">Pop</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">action</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>   <span class=\"hljs-comment\">//显示</span><br>   <span class=\"hljs-title class_\">Pop</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">show</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>   <span class=\"hljs-comment\">// 提取出每个弹窗不同的部分作为一个外部数组</span><br>   <span class=\"hljs-keyword\">var</span> popArr=[<br>       &#123;<span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">&quot;window1&quot;</span>,<span class=\"hljs-attr\">style</span>:[<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">400</span>]&#125;<br>       &#123;<span class=\"hljs-attr\">text</span>:<span class=\"hljs-string\">&quot;window2&quot;</span>,<span class=\"hljs-attr\">style</span>:[<span class=\"hljs-number\">400</span>,<span class=\"hljs-number\">200</span>]&#125;<br>   ]<br><br>   <span class=\"hljs-keyword\">var</span> poper=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pop</span>()<br><br>   <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">100</span>;i++)&#123;<br>       poper.<span class=\"hljs-title function_\">show</span>(popArr[i])<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-提高可扩展性\"><a href=\"#2-3-提高可扩展性\" class=\"headerlink\" title=\"2.3 提高可扩展性\"></a>2.3 提高可扩展性</h3><h4 id=\"2-3-1-适配器模式\"><a href=\"#2-3-1-适配器模式\" class=\"headerlink\" title=\"2.3.1 适配器模式\"></a>2.3.1 适配器模式</h4><p>当面临两个新老模块间接口 api 不匹配，可以用适配来转化 api</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// A框架调用的方式</span><br>A.<span class=\"hljs-title function_\">c</span>()<br><span class=\"hljs-comment\">// 假如我们项目中换成了jQuey，我们不想全部去替换A方法，就用适配器的方法</span><br>A.<span class=\"hljs-property\">c</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> $.on.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">arguments</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-装饰者模式（如：Vue-重写数组方法）\"><a href=\"#2-3-2-装饰者模式（如：Vue-重写数组方法）\" class=\"headerlink\" title=\"2.3.2 装饰者模式（如：Vue 重写数组方法）\"></a>2.3.2 装饰者模式（如：Vue 重写数组方法）</h4><p>当老的方法，不方便去直接修改，可以通装饰者来增加功能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * not type checking this file because flow doesn&#x27;t play well with</span><br><span class=\"hljs-comment\"> * dynamically accessing methods on Array prototype</span><br><span class=\"hljs-comment\"> */</span><br><br><span class=\"hljs-keyword\">import</span> &#123; def &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;../util/index&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> arrayProto = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> arrayMethods = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(arrayProto)<br><br><span class=\"hljs-keyword\">const</span> methodsToPatch = [<span class=\"hljs-string\">&#x27;push&#x27;</span>, <span class=\"hljs-string\">&#x27;pop&#x27;</span>, <span class=\"hljs-string\">&#x27;shift&#x27;</span>, <span class=\"hljs-string\">&#x27;unshift&#x27;</span>, <span class=\"hljs-string\">&#x27;splice&#x27;</span>, <span class=\"hljs-string\">&#x27;sort&#x27;</span>, <span class=\"hljs-string\">&#x27;reverse&#x27;</span>]<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Intercept mutating methods and emit events</span><br><span class=\"hljs-comment\"> */</span><br>methodsToPatch.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">method</span>) &#123;<br>  <span class=\"hljs-comment\">// cache original method</span><br>  <span class=\"hljs-keyword\">const</span> original = arrayProto[method]<br>  <span class=\"hljs-title function_\">def</span>(arrayMethods, method, <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mutator</span>(<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> result = original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args)<br>    <span class=\"hljs-keyword\">const</span> ob = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__ob__</span><br>    <span class=\"hljs-keyword\">let</span> inserted<br>    <span class=\"hljs-keyword\">switch</span> (method) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;push&#x27;</span>:<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;splice&#x27;</span>:<br>        inserted = args.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>)<br>        <span class=\"hljs-keyword\">break</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (inserted) ob.<span class=\"hljs-title function_\">observeArray</span>(inserted)<br>    <span class=\"hljs-comment\">// notify change</span><br>    ob.<span class=\"hljs-property\">dep</span>.<span class=\"hljs-title function_\">notify</span>()<br>    <span class=\"hljs-keyword\">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-命令模式\"><a href=\"#2-3-3-命令模式\" class=\"headerlink\" title=\"2.3.3 命令模式\"></a>2.3.3 命令模式</h4><p>解耦实现与具体命令，让是实现端和命令端扩展的更轻松</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> createImg = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> action = &#123;<br>    <span class=\"hljs-attr\">create</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) &#123;<br>      <span class=\"hljs-keyword\">var</span> htmlArr = []<br>      <span class=\"hljs-keyword\">var</span> _htmlstring = <span class=\"hljs-string\">&#x27;&#x27;</span><br>      <span class=\"hljs-keyword\">var</span> _htmlTemplate = <span class=\"hljs-string\">&quot;&lt;div&gt;&lt;img src=&#x27;&#123;&#123;img-url&#125;&#125;&#x27; /&gt;&lt;/div&gt;&lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;&quot;</span><br>      <span class=\"hljs-keyword\">var</span> displayWay = &#123;<br>        <span class=\"hljs-attr\">normal</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> arr<br>        &#125;,<br>        <span class=\"hljs-attr\">reverse</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">arr</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span> arr.<span class=\"hljs-property\">reverse</span><br>        &#125;<br>      &#125;<br><br>      obj.<span class=\"hljs-property\">imgArr</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">img</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">var</span> _html<br>        _html = _htmlTemplate.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;&#123;&#123;img-url&#125;&#125;&#x27;</span>, img.<span class=\"hljs-property\">img</span>).<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&#x27;&#123;&#123;title&#125;&#125;&#x27;</span>, img.<span class=\"hljs-property\">title</span>)<br>        htmlArr.<span class=\"hljs-title function_\">push</span>(_html)<br>      &#125;)<br>      htmlArr = displayWay[obj.<span class=\"hljs-property\">type</span>](htmlArr)<br>      _htmlstring = htmlArr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&lt;div&gt;&#x27;</span> + _htmlstring + <span class=\"hljs-string\">&#x27;&lt;/div&gt;&#x27;</span><br>    &#125;,<br>    <span class=\"hljs-attr\">display</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">obj</span>) &#123;<br>      <span class=\"hljs-keyword\">var</span> _html = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">create</span>(obj)<br>      obj.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">innerHTML</span> = _html<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">excute</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> _default = &#123;<br>      <span class=\"hljs-attr\">imgArr</span>: [&#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title&#x27;</span> &#125;],<br>      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;normal&#x27;</span>,<br>      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span><br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> item <span class=\"hljs-keyword\">in</span> _default) &#123;<br>      _default[item] = obj[item] || _default[item]<br>    &#125;<br>    action.<span class=\"hljs-title function_\">display</span>(_default)<br>  &#125;<br>&#125;)()<br><span class=\"hljs-title function_\">createImg</span>(&#123;<br>  <span class=\"hljs-attr\">imgArr</span>: [<br>    &#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title1&#x27;</span> &#125;,<br>    &#123; <span class=\"hljs-attr\">img</span>: <span class=\"hljs-string\">&#x27;xxxx&#x27;</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;default title2&#x27;</span> &#125;<br>  ],<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;normal&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-4-观察者模式\"><a href=\"#2-3-4-观察者模式\" class=\"headerlink\" title=\"2.3.4 观察者模式\"></a>2.3.4 观察者模式</h4><p>适用于不适合直接沟通的模块之间的组织</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> observe &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>=&#123;&#125;<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">regist</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type,fn</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]=fn<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">fire</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type</span>)&#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]()<br>&#125;<br><br>observe.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">remove</span>=<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">type</span>)&#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>[type]=<span class=\"hljs-literal\">null</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-5-职责链模式\"><a href=\"#2-3-5-职责链模式\" class=\"headerlink\" title=\"2.3.5 职责链模式\"></a>2.3.5 职责链模式</h4><p>组织同步模块，把要做的事情划分为模块，要做的事情一次传递</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 表单事件绑定-&gt;表单前端验证-&gt;表单后端验证</span><br><span class=\"hljs-comment\">// 思想：把你要做的事情拆分为模块，模块之间只做自己模块的事情</span><br><br>input.<span class=\"hljs-property\">onblur</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> _value = input.<span class=\"hljs-property\">value</span><br>  <span class=\"hljs-keyword\">var</span> _arr = [font, middle, back, fontAgain]<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> _result = _value<br>    <span class=\"hljs-keyword\">while</span> (_arr.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>      _result = <span class=\"hljs-keyword\">await</span> _arr.<span class=\"hljs-title function_\">shift</span>()(_result)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> _result<br>  &#125;<br>  <span class=\"hljs-title function_\">test</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">font</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">middle</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">back</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fontAgain</span>(<span class=\"hljs-params\">result</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-6-访问者模式\"><a href=\"#2-3-6-访问者模式\" class=\"headerlink\" title=\"2.3.6 访问者模式\"></a>2.3.6 访问者模式</h4><p>解耦数据操作与数据结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> data = []<br><br><span class=\"hljs-keyword\">var</span> handler = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br>handler.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">get</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><br><span class=\"hljs-keyword\">var</span> vistor = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">handler, data</span>) &#123;<br>  handler.<span class=\"hljs-title function_\">get</span>(data)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-提高代码质量\"><a href=\"#2-4-提高代码质量\" class=\"headerlink\" title=\"2.4 提高代码质量\"></a>2.4 提高代码质量</h3><h4 id=\"2-4-1-策略-状态模式\"><a href=\"#2-4-1-策略-状态模式\" class=\"headerlink\" title=\"2.4.1 策略/状态模式\"></a>2.4.1 策略/状态模式</h4><p>帮助我们优化 if-else 结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Strategy</span> (type,a,b) &#123;<br>  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Strategyer</span>=&#123;<br>    <span class=\"hljs-attr\">add</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a+b<br>    &#125;<br>    <span class=\"hljs-attr\">minus</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a-b<br>    &#125;<br>    <span class=\"hljs-attr\">division</span>:<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>)&#123;<br>      <span class=\"hljs-keyword\">return</span> a/b<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Strategyer</span>[type](a,b)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-2-外观模式\"><a href=\"#2-4-2-外观模式\" class=\"headerlink\" title=\"2.4.2 外观模式\"></a>2.4.2 外观模式</h4><p>一种套餐化接口的思想，封装常用方法为一个统一的接口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 划分功能，给使用者一个统一的接口</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tab</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dom</span> = <span class=\"hljs-literal\">null</span><br>&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">initHTML</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">changeTab</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eventBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dom</span>.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    self.<span class=\"hljs-title function_\">changeTab</span>()<br>  &#125;<br>&#125;<br>tab.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">init</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">config</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">initHTML</span>(config)<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">eventBind</span>()<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-3-迭代器模式\"><a href=\"#2-4-3-迭代器模式\" class=\"headerlink\" title=\"2.4.3 迭代器模式\"></a>2.4.3 迭代器模式</h4><p>帮助更好的遍历数据</p>\n<h4 id=\"2-4-4-备忘录模式\"><a href=\"#2-4-4-备忘录模式\" class=\"headerlink\" title=\"2.4.4 备忘录模式\"></a>2.4.4 备忘录模式</h4><p>缓存回到过去的状态</p>\n"},{"title":"浏览器缓存机制和缓存策略","keywords":"浏览器缓存机制和缓存策略","_content":"# 浏览器缓存机制和缓存策略\n\n## 1.前言\n\n**浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP的缓存标识进行的**\n\n## 2.缓存过程分析\n\n**浏览器和服务器的通信方式为应答模式**。即浏览器发起HTTP--服务端响应HTTP请求。浏览器第一次发起请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否将响应结果缓存，缓存，则将请求结果和缓存标识存入到浏览器缓存当中\n\n## 3.缓存策略\n\n**浏览器缓存策略分为两种：强缓存和协商缓存**。并且缓存策略都是通过设置HTTP header来实现的。\n\n客户端第一次向服务器请求数据，存在缓存时，客户端会将请求结果和缓存标识存入到内存或硬盘当中；当再次获取相同的资源，强缓存和协商缓存的应对方式也有所不同\n\n**强缓存**：客户端再次请求相同的资源时，不会向服务器发送请求，而是根据强缓存标识决定是否直接从内存/硬盘中读取数据\n\n**协商缓存**：客户端再次请求相同的资源时，先向服务器发起请求“询问”在本地缓存的资源文件相比服务器上的文件是否发生修改，如果有更改，则获取最新的文件资源并缓存，如果没有则从内存/硬盘中读取\n\n### 3.1强缓存\n\n**强缓存就是向浏览器缓存查找请求结果，并且根据该结果的缓存规则来决定是否使用该缓存结果的过程*\n\n强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的network选中可以看到该请求返回200的状态码，并且SIze显示from disk cache或from memory cache\n\n强缓存可以通过设置两种HTTP Header实现： Expires 和 Cache-Control。\n\n强缓存的情况主要有以下三种：\n\n1. 不存在该缓存结果和缓存标识，强缓存失效，直接向服务器发起请求（和第一次发起请求一致）\n2. 存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存\n3. 存在该缓存结果和缓存标识，且该结果没有生效，强缓存生效，直接返回该结果\n\n当浏览器向服务器发送请求的时候，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强缓存的字段分别是Expires和Cache-Control，其中Cache-Control的优先级比Expires高。\n\n#### 3.1.1Expires\n\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和last-modified结合使用。\n\nExpires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，而无需再次请求。\n\nExpires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效\n\n到了HTTP/1.1，Expires已经被Cache-Control替代。\n\n原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存可能会失效。\n\n#### 3.1.2Cache-Control\n\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control：max-age=300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会命中强缓存。\n\nCache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：\n\n- public：**所有内容都将被缓存（客户端和代理服务器都可缓存）**。具体来说响应可被任何中间节点缓存，如Browser <-- proxy1 <-- proxy2 <-- Server， 中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给Browser而不再向proxy2要\n- private：**所以内容只有客户端可以缓存， Cache-Control的默认取值**。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy会老老实实把Server返回的数据发送给Browser，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据\n- no-cache：**客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定**。表示不使用Cache-Control的缓存控制方式做前置验证号，而是使用Etag或者Last-Modified字段来控制缓存。注意：no-cache这个名字有一点误导。设置no-cahce，不代表浏览器不缓存水，而是浏览器在使用缓存数据时，通过协商缓存来判断数据是否和服务器保持一致\n- no-store：**所有内容都不会被缓存**，即不使用强制缓存，也不使用协商缓存\n- max-age：max-age=xxx 表示**缓存内容将在xxx秒后失效**\n- s-maxage： 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒钟，及时更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires。\n\n### 3.2协商缓存\n\n*协商缓存就是强缓存失效后，浏览器写到缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，*主要有以下两种情况\n\n**协商缓存生效，返回304和Not Modified**\n\n**协商缓存失效，返回200和请求结果**\n\n协商缓存可以通过设置两种HTTP Header实现： Last-modified 和 ETag。\n\n#### 3.2.1 Last-Modified 和 If-Modified-Since\n\nLast-Modified:\n\n- 浏览器在第一次访问资源的情况下，浏览器会在返回资源的同事，在response header中添加Last-Modified的header\n- header的值是这个资源在服务器上的最后修改时间\n- 浏览器接收后，缓存这个文件和header\n\nIf-Modified-Since：\n\n- 浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是浏览器添加If-Modified-Since这个header，值就是Last-Modified的值。\n- 服务器再次受到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比。如果没有变化，返回304和空的响应体，直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200.\n\n但是Last-Modified也存在一些弊端：\n\n- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源\n\n#### 3.2.2 ETag 和 If-None-Match\n\n**直接根据文件内容是否修改来决定缓存策略**。\n\nEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。\n\n- 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。\n  - 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。\n  - 如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。\n\n### 3.3比较\n\n- 在精确度上，Etag要优于Last-Modified。    Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n- 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。\n- 在优先级上，服务器校验优先考虑Etag\n\n## 4.缓存位置\n\n从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。\n\n- Service Worker\n- Memory Cache\n- Disk Cache\n- Push Cache","source":"_posts/浏览器缓存机制和缓存策略.md","raw":"---\ntitle:  浏览器缓存机制和缓存策略\ntag: 浏览器缓存机制和缓存策略\nkeywords: 浏览器缓存机制和缓存策略\ncategories: 浏览器相关知识\n---\n# 浏览器缓存机制和缓存策略\n\n## 1.前言\n\n**浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP的缓存标识进行的**\n\n## 2.缓存过程分析\n\n**浏览器和服务器的通信方式为应答模式**。即浏览器发起HTTP--服务端响应HTTP请求。浏览器第一次发起请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否将响应结果缓存，缓存，则将请求结果和缓存标识存入到浏览器缓存当中\n\n## 3.缓存策略\n\n**浏览器缓存策略分为两种：强缓存和协商缓存**。并且缓存策略都是通过设置HTTP header来实现的。\n\n客户端第一次向服务器请求数据，存在缓存时，客户端会将请求结果和缓存标识存入到内存或硬盘当中；当再次获取相同的资源，强缓存和协商缓存的应对方式也有所不同\n\n**强缓存**：客户端再次请求相同的资源时，不会向服务器发送请求，而是根据强缓存标识决定是否直接从内存/硬盘中读取数据\n\n**协商缓存**：客户端再次请求相同的资源时，先向服务器发起请求“询问”在本地缓存的资源文件相比服务器上的文件是否发生修改，如果有更改，则获取最新的文件资源并缓存，如果没有则从内存/硬盘中读取\n\n### 3.1强缓存\n\n**强缓存就是向浏览器缓存查找请求结果，并且根据该结果的缓存规则来决定是否使用该缓存结果的过程*\n\n强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的network选中可以看到该请求返回200的状态码，并且SIze显示from disk cache或from memory cache\n\n强缓存可以通过设置两种HTTP Header实现： Expires 和 Cache-Control。\n\n强缓存的情况主要有以下三种：\n\n1. 不存在该缓存结果和缓存标识，强缓存失效，直接向服务器发起请求（和第一次发起请求一致）\n2. 存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存\n3. 存在该缓存结果和缓存标识，且该结果没有生效，强缓存生效，直接返回该结果\n\n当浏览器向服务器发送请求的时候，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强缓存的字段分别是Expires和Cache-Control，其中Cache-Control的优先级比Expires高。\n\n#### 3.1.1Expires\n\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和last-modified结合使用。\n\nExpires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，而无需再次请求。\n\nExpires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效\n\n到了HTTP/1.1，Expires已经被Cache-Control替代。\n\n原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存可能会失效。\n\n#### 3.1.2Cache-Control\n\n在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control：max-age=300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会命中强缓存。\n\nCache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：\n\n- public：**所有内容都将被缓存（客户端和代理服务器都可缓存）**。具体来说响应可被任何中间节点缓存，如Browser <-- proxy1 <-- proxy2 <-- Server， 中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给Browser而不再向proxy2要\n- private：**所以内容只有客户端可以缓存， Cache-Control的默认取值**。具体来说，表示中间节点不允许缓存，对于Browser <-- proxy1 <-- proxy2 <-- Server，proxy会老老实实把Server返回的数据发送给Browser，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据\n- no-cache：**客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定**。表示不使用Cache-Control的缓存控制方式做前置验证号，而是使用Etag或者Last-Modified字段来控制缓存。注意：no-cache这个名字有一点误导。设置no-cahce，不代表浏览器不缓存水，而是浏览器在使用缓存数据时，通过协商缓存来判断数据是否和服务器保持一致\n- no-store：**所有内容都不会被缓存**，即不使用强制缓存，也不使用协商缓存\n- max-age：max-age=xxx 表示**缓存内容将在xxx秒后失效**\n- s-maxage： 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒钟，及时更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires。\n\n### 3.2协商缓存\n\n*协商缓存就是强缓存失效后，浏览器写到缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，*主要有以下两种情况\n\n**协商缓存生效，返回304和Not Modified**\n\n**协商缓存失效，返回200和请求结果**\n\n协商缓存可以通过设置两种HTTP Header实现： Last-modified 和 ETag。\n\n#### 3.2.1 Last-Modified 和 If-Modified-Since\n\nLast-Modified:\n\n- 浏览器在第一次访问资源的情况下，浏览器会在返回资源的同事，在response header中添加Last-Modified的header\n- header的值是这个资源在服务器上的最后修改时间\n- 浏览器接收后，缓存这个文件和header\n\nIf-Modified-Since：\n\n- 浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是浏览器添加If-Modified-Since这个header，值就是Last-Modified的值。\n- 服务器再次受到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比。如果没有变化，返回304和空的响应体，直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200.\n\n但是Last-Modified也存在一些弊端：\n\n- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源\n\n#### 3.2.2 ETag 和 If-None-Match\n\n**直接根据文件内容是否修改来决定缓存策略**。\n\nEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。\n\n- 浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。\n  - 如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。\n  - 如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。\n\n### 3.3比较\n\n- 在精确度上，Etag要优于Last-Modified。    Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n- 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。\n- 在优先级上，服务器校验优先考虑Etag\n\n## 4.缓存位置\n\n从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。\n\n- Service Worker\n- Memory Cache\n- Disk Cache\n- Push Cache","slug":"浏览器缓存机制和缓存策略","published":1,"date":"2022-11-03T08:35:18.072Z","updated":"2022-11-03T08:35:47.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9l1000ui024g8wxejmn","content":"<h1 id=\"浏览器缓存机制和缓存策略\"><a href=\"#浏览器缓存机制和缓存策略\" class=\"headerlink\" title=\"浏览器缓存机制和缓存策略\"></a>浏览器缓存机制和缓存策略</h1><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p><strong>浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP的缓存标识进行的</strong></p>\n<h2 id=\"2-缓存过程分析\"><a href=\"#2-缓存过程分析\" class=\"headerlink\" title=\"2.缓存过程分析\"></a>2.缓存过程分析</h2><p><strong>浏览器和服务器的通信方式为应答模式</strong>。即浏览器发起HTTP–服务端响应HTTP请求。浏览器第一次发起请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否将响应结果缓存，缓存，则将请求结果和缓存标识存入到浏览器缓存当中</p>\n<h2 id=\"3-缓存策略\"><a href=\"#3-缓存策略\" class=\"headerlink\" title=\"3.缓存策略\"></a>3.缓存策略</h2><p><strong>浏览器缓存策略分为两种：强缓存和协商缓存</strong>。并且缓存策略都是通过设置HTTP header来实现的。</p>\n<p>客户端第一次向服务器请求数据，存在缓存时，客户端会将请求结果和缓存标识存入到内存或硬盘当中；当再次获取相同的资源，强缓存和协商缓存的应对方式也有所不同</p>\n<p><strong>强缓存</strong>：客户端再次请求相同的资源时，不会向服务器发送请求，而是根据强缓存标识决定是否直接从内存/硬盘中读取数据</p>\n<p><strong>协商缓存</strong>：客户端再次请求相同的资源时，先向服务器发起请求“询问”在本地缓存的资源文件相比服务器上的文件是否发生修改，如果有更改，则获取最新的文件资源并缓存，如果没有则从内存/硬盘中读取</p>\n<h3 id=\"3-1强缓存\"><a href=\"#3-1强缓存\" class=\"headerlink\" title=\"3.1强缓存\"></a>3.1强缓存</h3><p>*<em>强缓存就是向浏览器缓存查找请求结果，并且根据该结果的缓存规则来决定是否使用该缓存结果的过程</em></p>\n<p>强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的network选中可以看到该请求返回200的状态码，并且SIze显示from disk cache或from memory cache</p>\n<p>强缓存可以通过设置两种HTTP Header实现： Expires 和 Cache-Control。</p>\n<p>强缓存的情况主要有以下三种：</p>\n<ol>\n<li>不存在该缓存结果和缓存标识，强缓存失效，直接向服务器发起请求（和第一次发起请求一致）</li>\n<li>存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存</li>\n<li>存在该缓存结果和缓存标识，且该结果没有生效，强缓存生效，直接返回该结果</li>\n</ol>\n<p>当浏览器向服务器发送请求的时候，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强缓存的字段分别是Expires和Cache-Control，其中Cache-Control的优先级比Expires高。</p>\n<h4 id=\"3-1-1Expires\"><a href=\"#3-1-1Expires\" class=\"headerlink\" title=\"3.1.1Expires\"></a>3.1.1Expires</h4><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和last-modified结合使用。</p>\n<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，而无需再次请求。</p>\n<p>Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>\n<p>到了HTTP/1.1，Expires已经被Cache-Control替代。</p>\n<p>原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存可能会失效。</p>\n<h4 id=\"3-1-2Cache-Control\"><a href=\"#3-1-2Cache-Control\" class=\"headerlink\" title=\"3.1.2Cache-Control\"></a>3.1.2Cache-Control</h4><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control：max-age=300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会命中强缓存。</p>\n<p>Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：</p>\n<ul>\n<li>public：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。具体来说响应可被任何中间节点缓存，如Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server， 中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给Browser而不再向proxy2要</li>\n<li>private：<strong>所以内容只有客户端可以缓存， Cache-Control的默认取值</strong>。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy会老老实实把Server返回的数据发送给Browser，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据</li>\n<li>no-cache：<strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定</strong>。表示不使用Cache-Control的缓存控制方式做前置验证号，而是使用Etag或者Last-Modified字段来控制缓存。注意：no-cache这个名字有一点误导。设置no-cahce，不代表浏览器不缓存水，而是浏览器在使用缓存数据时，通过协商缓存来判断数据是否和服务器保持一致</li>\n<li>no-store：<strong>所有内容都不会被缓存</strong>，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age：max-age=xxx 表示<strong>缓存内容将在xxx秒后失效</strong></li>\n<li>s-maxage： 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒钟，及时更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires。</li>\n</ul>\n<h3 id=\"3-2协商缓存\"><a href=\"#3-2协商缓存\" class=\"headerlink\" title=\"3.2协商缓存\"></a>3.2协商缓存</h3><p><em>协商缓存就是强缓存失效后，浏览器写到缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，</em>主要有以下两种情况</p>\n<p><strong>协商缓存生效，返回304和Not Modified</strong></p>\n<p><strong>协商缓存失效，返回200和请求结果</strong></p>\n<p>协商缓存可以通过设置两种HTTP Header实现： Last-modified 和 ETag。</p>\n<h4 id=\"3-2-1-Last-Modified-和-If-Modified-Since\"><a href=\"#3-2-1-Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"3.2.1 Last-Modified 和 If-Modified-Since\"></a>3.2.1 Last-Modified 和 If-Modified-Since</h4><p>Last-Modified:</p>\n<ul>\n<li>浏览器在第一次访问资源的情况下，浏览器会在返回资源的同事，在response header中添加Last-Modified的header</li>\n<li>header的值是这个资源在服务器上的最后修改时间</li>\n<li>浏览器接收后，缓存这个文件和header</li>\n</ul>\n<p>If-Modified-Since：</p>\n<ul>\n<li>浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是浏览器添加If-Modified-Since这个header，值就是Last-Modified的值。</li>\n<li>服务器再次受到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比。如果没有变化，返回304和空的响应体，直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200.</li>\n</ul>\n<p>但是Last-Modified也存在一些弊端：</p>\n<ul>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ul>\n<h4 id=\"3-2-2-ETag-和-If-None-Match\"><a href=\"#3-2-2-ETag-和-If-None-Match\" class=\"headerlink\" title=\"3.2.2 ETag 和 If-None-Match\"></a>3.2.2 ETag 和 If-None-Match</h4><p><strong>直接根据文件内容是否修改来决定缓存策略</strong>。</p>\n<p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</p>\n<ul>\n<li>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<ul>\n<li>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。</li>\n<li>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3比较\"><a href=\"#3-3比较\" class=\"headerlink\" title=\"3.3比较\"></a>3.3比较</h3><ul>\n<li>在精确度上，Etag要优于Last-Modified。    Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li>\n<li>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li>\n<li>在优先级上，服务器校验优先考虑Etag</li>\n</ul>\n<h2 id=\"4-缓存位置\"><a href=\"#4-缓存位置\" class=\"headerlink\" title=\"4.缓存位置\"></a>4.缓存位置</h2><p>从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>\n<ul>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n</ul>\n","site":{"data":{}},"wordcount":3506,"excerpt":"","more":"<h1 id=\"浏览器缓存机制和缓存策略\"><a href=\"#浏览器缓存机制和缓存策略\" class=\"headerlink\" title=\"浏览器缓存机制和缓存策略\"></a>浏览器缓存机制和缓存策略</h1><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p><strong>浏览器的缓存机制也就是HTTP缓存机制，其机制是根据HTTP的缓存标识进行的</strong></p>\n<h2 id=\"2-缓存过程分析\"><a href=\"#2-缓存过程分析\" class=\"headerlink\" title=\"2.缓存过程分析\"></a>2.缓存过程分析</h2><p><strong>浏览器和服务器的通信方式为应答模式</strong>。即浏览器发起HTTP–服务端响应HTTP请求。浏览器第一次发起请求，拿到请求结果后，会根据响应报文中响应头的缓存标识，决定是否将响应结果缓存，缓存，则将请求结果和缓存标识存入到浏览器缓存当中</p>\n<h2 id=\"3-缓存策略\"><a href=\"#3-缓存策略\" class=\"headerlink\" title=\"3.缓存策略\"></a>3.缓存策略</h2><p><strong>浏览器缓存策略分为两种：强缓存和协商缓存</strong>。并且缓存策略都是通过设置HTTP header来实现的。</p>\n<p>客户端第一次向服务器请求数据，存在缓存时，客户端会将请求结果和缓存标识存入到内存或硬盘当中；当再次获取相同的资源，强缓存和协商缓存的应对方式也有所不同</p>\n<p><strong>强缓存</strong>：客户端再次请求相同的资源时，不会向服务器发送请求，而是根据强缓存标识决定是否直接从内存/硬盘中读取数据</p>\n<p><strong>协商缓存</strong>：客户端再次请求相同的资源时，先向服务器发起请求“询问”在本地缓存的资源文件相比服务器上的文件是否发生修改，如果有更改，则获取最新的文件资源并缓存，如果没有则从内存/硬盘中读取</p>\n<h3 id=\"3-1强缓存\"><a href=\"#3-1强缓存\" class=\"headerlink\" title=\"3.1强缓存\"></a>3.1强缓存</h3><p>*<em>强缓存就是向浏览器缓存查找请求结果，并且根据该结果的缓存规则来决定是否使用该缓存结果的过程</em></p>\n<p>强缓存不会向服务器发送请求，而是直接从缓存中读取资源，在chrome控制台的network选中可以看到该请求返回200的状态码，并且SIze显示from disk cache或from memory cache</p>\n<p>强缓存可以通过设置两种HTTP Header实现： Expires 和 Cache-Control。</p>\n<p>强缓存的情况主要有以下三种：</p>\n<ol>\n<li>不存在该缓存结果和缓存标识，强缓存失效，直接向服务器发起请求（和第一次发起请求一致）</li>\n<li>存在该缓存结果和缓存标识，但是结果已经失效，强缓存失效，则使用协商缓存</li>\n<li>存在该缓存结果和缓存标识，且该结果没有生效，强缓存生效，直接返回该结果</li>\n</ol>\n<p>当浏览器向服务器发送请求的时候，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强缓存的字段分别是Expires和Cache-Control，其中Cache-Control的优先级比Expires高。</p>\n<h4 id=\"3-1-1Expires\"><a href=\"#3-1-1Expires\" class=\"headerlink\" title=\"3.1.1Expires\"></a>3.1.1Expires</h4><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和last-modified结合使用。</p>\n<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存获取数据，而无需再次请求。</p>\n<p>Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p>\n<p>到了HTTP/1.1，Expires已经被Cache-Control替代。</p>\n<p>原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，强制缓存可能会失效。</p>\n<h4 id=\"3-1-2Cache-Control\"><a href=\"#3-1-2Cache-Control\" class=\"headerlink\" title=\"3.1.2Cache-Control\"></a>3.1.2Cache-Control</h4><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control：max-age=300时，则代表在这个请求正确返回时间的5分钟内再次加载资源，就会命中强缓存。</p>\n<p>Cache-Control可以在请求头或者响应头中设置，并且可以组合使用多种指令，主要取值为：</p>\n<ul>\n<li>public：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。具体来说响应可被任何中间节点缓存，如Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server， 中间的proxy也可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给Browser而不再向proxy2要</li>\n<li>private：<strong>所以内容只有客户端可以缓存， Cache-Control的默认取值</strong>。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;– proxy2 &lt;– Server，proxy会老老实实把Server返回的数据发送给Browser，自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据</li>\n<li>no-cache：<strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定</strong>。表示不使用Cache-Control的缓存控制方式做前置验证号，而是使用Etag或者Last-Modified字段来控制缓存。注意：no-cache这个名字有一点误导。设置no-cahce，不代表浏览器不缓存水，而是浏览器在使用缓存数据时，通过协商缓存来判断数据是否和服务器保持一致</li>\n<li>no-store：<strong>所有内容都不会被缓存</strong>，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age：max-age=xxx 表示<strong>缓存内容将在xxx秒后失效</strong></li>\n<li>s-maxage： 同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒钟，及时更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires。</li>\n</ul>\n<h3 id=\"3-2协商缓存\"><a href=\"#3-2协商缓存\" class=\"headerlink\" title=\"3.2协商缓存\"></a>3.2协商缓存</h3><p><em>协商缓存就是强缓存失效后，浏览器写到缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，</em>主要有以下两种情况</p>\n<p><strong>协商缓存生效，返回304和Not Modified</strong></p>\n<p><strong>协商缓存失效，返回200和请求结果</strong></p>\n<p>协商缓存可以通过设置两种HTTP Header实现： Last-modified 和 ETag。</p>\n<h4 id=\"3-2-1-Last-Modified-和-If-Modified-Since\"><a href=\"#3-2-1-Last-Modified-和-If-Modified-Since\" class=\"headerlink\" title=\"3.2.1 Last-Modified 和 If-Modified-Since\"></a>3.2.1 Last-Modified 和 If-Modified-Since</h4><p>Last-Modified:</p>\n<ul>\n<li>浏览器在第一次访问资源的情况下，浏览器会在返回资源的同事，在response header中添加Last-Modified的header</li>\n<li>header的值是这个资源在服务器上的最后修改时间</li>\n<li>浏览器接收后，缓存这个文件和header</li>\n</ul>\n<p>If-Modified-Since：</p>\n<ul>\n<li>浏览器下一次请求这个资源，浏览器检测到有Last-Modified这个header，于是浏览器添加If-Modified-Since这个header，值就是Last-Modified的值。</li>\n<li>服务器再次受到这个资源请求，会根据If-Modified-Since中的值与服务器中这个资源的最后修改时间对比。如果没有变化，返回304和空的响应体，直接从缓存读取。如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200.</li>\n</ul>\n<p>但是Last-Modified也存在一些弊端：</p>\n<ul>\n<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>\n</ul>\n<h4 id=\"3-2-2-ETag-和-If-None-Match\"><a href=\"#3-2-2-ETag-和-If-None-Match\" class=\"headerlink\" title=\"3.2.2 ETag 和 If-None-Match\"></a>3.2.2 ETag 和 If-None-Match</h4><p><strong>直接根据文件内容是否修改来决定缓存策略</strong>。</p>\n<p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。</p>\n<ul>\n<li>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag值是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<ul>\n<li>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端。</li>\n<li>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3比较\"><a href=\"#3-3比较\" class=\"headerlink\" title=\"3.3比较\"></a>3.3比较</h3><ul>\n<li>在精确度上，Etag要优于Last-Modified。    Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</li>\n<li>在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li>\n<li>在优先级上，服务器校验优先考虑Etag</li>\n</ul>\n<h2 id=\"4-缓存位置\"><a href=\"#4-缓存位置\" class=\"headerlink\" title=\"4.缓存位置\"></a>4.缓存位置</h2><p>从缓存位置上来说分为4种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>\n<ul>\n<li>Service Worker</li>\n<li>Memory Cache</li>\n<li>Disk Cache</li>\n<li>Push Cache</li>\n</ul>\n"},{"title":"浏览器页面的渲染过程","keywords":"浏览器渲染","_content":"# 浏览器页面的渲染过程\n\n### 1.输入网址\n\n当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL\n\n- 如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址\n- 如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL\n\n当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作\n\n### 2.解析URL\n\nURL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求\n\n### 3.检查浏览器缓存\n\n接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程\n\n优化：1.开启浏览器缓存；2.第三方库公共模块抽取\n\n### 4.DNS解析\n\n在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址\n\n优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）\n\n### 5.TCP/IP报文\n\n三次握手\n\n### 6.http请求\n\n连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息\n\n### 7.服务器解析请求并返回http报文\n\n服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了\n\n### 8.浏览器渲染页面\n\n- DOM树（DOM）\n  - 字节（Bytes） -> 字符（Characters） > 令牌（token） -> 节点（Nodes）-> 文档对象模型（DOM）\n- CSS对象模型（CSSOM）\n- 布局树Layout Tree\n  - DOM树与CSSOM树合并后形成渲染树（RenderTree）\n  - 渲染树只包含渲染网页所需的节点\n  - 布局计算每个对象的精确位置和大小\n  - 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上\n- 渲染\n  1. 获取DOM后分割为多个图层\n  2. 对每个图层的节点计算样式结果（Recalculate style --样式重计算）\n  3. 为每个节点生成图形和位置（Layout --重排，回流）\n  4. 将每个节点绘制填充到图层位图中（Paint --重绘）\n  5. 图层作为纹理上传至GPU\n  6. 组合多个图层到页面上生成最终屏幕图像（Composite Layers-- 图层重组）\n- 回流和重绘\n  - 重绘\n    - 当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘\n  - 回流\n    - 当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流\n  - 回流必将引起重绘，而重绘不一定会引起回流\n- 优化：\n  1. 静态资源使用CDN，缩短静态资源请求时间\n  2. 将css放在文件头部，JavaScript文件放在底部\n  3. 图片优化\n     1. 图片压缩\n     2. 图片懒加载\n     3. 使用svg响应式图片\n     4. 使用webp格式的图片\n  4. 压缩文件\n     1. JavaScript：UglifyPlugin\n     2. CSS ：MiniCssExtractPlugin\n     3. HTML：HtmlWebpackPlugin\n  5. 减少重绘重排\n  6. 代码分割（如路由懒加载）\n  7. Tree Shaking\n     - Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除\n  8. 使用服务端渲染\n\n### 9.断开连接\n\n四次分手","source":"_posts/浏览器页面的渲染过程.md","raw":"---\ntitle:  浏览器页面的渲染过程\ntag: 浏览器渲染\nkeywords: 浏览器渲染\ncategories: 浏览器相关知识\n---\n# 浏览器页面的渲染过程\n\n### 1.输入网址\n\n当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL\n\n- 如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址\n- 如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL\n\n当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作\n\n### 2.解析URL\n\nURL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求\n\n### 3.检查浏览器缓存\n\n接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程\n\n优化：1.开启浏览器缓存；2.第三方库公共模块抽取\n\n### 4.DNS解析\n\n在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址\n\n优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）\n\n### 5.TCP/IP报文\n\n三次握手\n\n### 6.http请求\n\n连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息\n\n### 7.服务器解析请求并返回http报文\n\n服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了\n\n### 8.浏览器渲染页面\n\n- DOM树（DOM）\n  - 字节（Bytes） -> 字符（Characters） > 令牌（token） -> 节点（Nodes）-> 文档对象模型（DOM）\n- CSS对象模型（CSSOM）\n- 布局树Layout Tree\n  - DOM树与CSSOM树合并后形成渲染树（RenderTree）\n  - 渲染树只包含渲染网页所需的节点\n  - 布局计算每个对象的精确位置和大小\n  - 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上\n- 渲染\n  1. 获取DOM后分割为多个图层\n  2. 对每个图层的节点计算样式结果（Recalculate style --样式重计算）\n  3. 为每个节点生成图形和位置（Layout --重排，回流）\n  4. 将每个节点绘制填充到图层位图中（Paint --重绘）\n  5. 图层作为纹理上传至GPU\n  6. 组合多个图层到页面上生成最终屏幕图像（Composite Layers-- 图层重组）\n- 回流和重绘\n  - 重绘\n    - 当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘\n  - 回流\n    - 当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流\n  - 回流必将引起重绘，而重绘不一定会引起回流\n- 优化：\n  1. 静态资源使用CDN，缩短静态资源请求时间\n  2. 将css放在文件头部，JavaScript文件放在底部\n  3. 图片优化\n     1. 图片压缩\n     2. 图片懒加载\n     3. 使用svg响应式图片\n     4. 使用webp格式的图片\n  4. 压缩文件\n     1. JavaScript：UglifyPlugin\n     2. CSS ：MiniCssExtractPlugin\n     3. HTML：HtmlWebpackPlugin\n  5. 减少重绘重排\n  6. 代码分割（如路由懒加载）\n  7. Tree Shaking\n     - Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除\n  8. 使用服务端渲染\n\n### 9.断开连接\n\n四次分手","slug":"浏览器页面的渲染过程","published":1,"date":"2022-02-21T16:43:21.702Z","updated":"2022-02-21T16:47:00.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9l2000xi024gqaof5p2","content":"<h1 id=\"浏览器页面的渲染过程\"><a href=\"#浏览器页面的渲染过程\" class=\"headerlink\" title=\"浏览器页面的渲染过程\"></a>浏览器页面的渲染过程</h1><h3 id=\"1-输入网址\"><a href=\"#1-输入网址\" class=\"headerlink\" title=\"1.输入网址\"></a>1.输入网址</h3><p>当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址</li>\n<li>如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL</li>\n</ul>\n<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作</p>\n<h3 id=\"2-解析URL\"><a href=\"#2-解析URL\" class=\"headerlink\" title=\"2.解析URL\"></a>2.解析URL</h3><p>URL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求</p>\n<h3 id=\"3-检查浏览器缓存\"><a href=\"#3-检查浏览器缓存\" class=\"headerlink\" title=\"3.检查浏览器缓存\"></a>3.检查浏览器缓存</h3><p>接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程</p>\n<p>优化：1.开启浏览器缓存；2.第三方库公共模块抽取</p>\n<h3 id=\"4-DNS解析\"><a href=\"#4-DNS解析\" class=\"headerlink\" title=\"4.DNS解析\"></a>4.DNS解析</h3><p>在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址</p>\n<p>优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）</p>\n<h3 id=\"5-TCP-IP报文\"><a href=\"#5-TCP-IP报文\" class=\"headerlink\" title=\"5.TCP/IP报文\"></a>5.TCP/IP报文</h3><p>三次握手</p>\n<h3 id=\"6-http请求\"><a href=\"#6-http请求\" class=\"headerlink\" title=\"6.http请求\"></a>6.http请求</h3><p>连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息</p>\n<h3 id=\"7-服务器解析请求并返回http报文\"><a href=\"#7-服务器解析请求并返回http报文\" class=\"headerlink\" title=\"7.服务器解析请求并返回http报文\"></a>7.服务器解析请求并返回http报文</h3><p>服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了</p>\n<h3 id=\"8-浏览器渲染页面\"><a href=\"#8-浏览器渲染页面\" class=\"headerlink\" title=\"8.浏览器渲染页面\"></a>8.浏览器渲染页面</h3><ul>\n<li>DOM树（DOM）<ul>\n<li>字节（Bytes） -&gt; 字符（Characters） &gt; 令牌（token） -&gt; 节点（Nodes）-&gt; 文档对象模型（DOM）</li>\n</ul>\n</li>\n<li>CSS对象模型（CSSOM）</li>\n<li>布局树Layout Tree<ul>\n<li>DOM树与CSSOM树合并后形成渲染树（RenderTree）</li>\n<li>渲染树只包含渲染网页所需的节点</li>\n<li>布局计算每个对象的精确位置和大小</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上</li>\n</ul>\n</li>\n<li>渲染<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style –样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout –重排，回流）</li>\n<li>将每个节点绘制填充到图层位图中（Paint –重绘）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>组合多个图层到页面上生成最终屏幕图像（Composite Layers– 图层重组）</li>\n</ol>\n</li>\n<li>回流和重绘<ul>\n<li>重绘<ul>\n<li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘</li>\n</ul>\n</li>\n<li>回流<ul>\n<li>当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流</li>\n</ul>\n</li>\n<li>回流必将引起重绘，而重绘不一定会引起回流</li>\n</ul>\n</li>\n<li>优化：<ol>\n<li>静态资源使用CDN，缩短静态资源请求时间</li>\n<li>将css放在文件头部，JavaScript文件放在底部</li>\n<li>图片优化<ol>\n<li>图片压缩</li>\n<li>图片懒加载</li>\n<li>使用svg响应式图片</li>\n<li>使用webp格式的图片</li>\n</ol>\n</li>\n<li>压缩文件<ol>\n<li>JavaScript：UglifyPlugin</li>\n<li>CSS ：MiniCssExtractPlugin</li>\n<li>HTML：HtmlWebpackPlugin</li>\n</ol>\n</li>\n<li>减少重绘重排</li>\n<li>代码分割（如路由懒加载）</li>\n<li>Tree Shaking<ul>\n<li>Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除</li>\n</ul>\n</li>\n<li>使用服务端渲染</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"9-断开连接\"><a href=\"#9-断开连接\" class=\"headerlink\" title=\"9.断开连接\"></a>9.断开连接</h3><p>四次分手</p>\n","site":{"data":{}},"wordcount":1530,"excerpt":"","more":"<h1 id=\"浏览器页面的渲染过程\"><a href=\"#浏览器页面的渲染过程\" class=\"headerlink\" title=\"浏览器页面的渲染过程\"></a>浏览器页面的渲染过程</h1><h3 id=\"1-输入网址\"><a href=\"#1-输入网址\" class=\"headerlink\" title=\"1.输入网址\"></a>1.输入网址</h3><p>当用户在地址栏输入一个搜索关键字时，地址栏会判断当前输入的关键字是搜索内容，还是请求的URL</p>\n<ul>\n<li>如果是搜索内容，地址栏会使用浏览器设置的默认的搜索引擎，生成对应的带搜索关键字的URL地址</li>\n<li>如果输入的内容符合URL规则，那么地址栏根据规则，把这段内容加上协议，合成为完整的URL</li>\n</ul>\n<p>当用户输入关键字并键入回车之后，这意味着当前页面即将要替换成新的页面，不过在这个流程继续之前，浏览器会给当前页面一次执行beforeunload事件，以执行一些数据清理操作</p>\n<h3 id=\"2-解析URL\"><a href=\"#2-解析URL\" class=\"headerlink\" title=\"2.解析URL\"></a>2.解析URL</h3><p>URL主要由协议、主机、端口、路径、查询参数和锚点6部分构成。输入URL之后，浏览器会将这些信息构成一个HTTP请求</p>\n<h3 id=\"3-检查浏览器缓存\"><a href=\"#3-检查浏览器缓存\" class=\"headerlink\" title=\"3.检查浏览器缓存\"></a>3.检查浏览器缓存</h3><p>接下来，网络进程会查找本地缓存是否缓存该URL地址的资源。如果有缓存资源，那么会直接将缓存的资源返回给浏览器进程；如果没有在缓存没有找到缓存资源，那么直接进入到网络请求流程</p>\n<p>优化：1.开启浏览器缓存；2.第三方库公共模块抽取</p>\n<h3 id=\"4-DNS解析\"><a href=\"#4-DNS解析\" class=\"headerlink\" title=\"4.DNS解析\"></a>4.DNS解析</h3><p>在发起http请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器，DNS服务器会返回给浏览器对应的IP地址</p>\n<p>优化：1.DNS预解析（大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿）</p>\n<h3 id=\"5-TCP-IP报文\"><a href=\"#5-TCP-IP报文\" class=\"headerlink\" title=\"5.TCP/IP报文\"></a>5.TCP/IP报文</h3><p>三次握手</p>\n<h3 id=\"6-http请求\"><a href=\"#6-http请求\" class=\"headerlink\" title=\"6.http请求\"></a>6.http请求</h3><p>连接建立之后，浏览器端会构建请求行、请求头和请求体等信息，并把和该域名想换的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息</p>\n<h3 id=\"7-服务器解析请求并返回http报文\"><a href=\"#7-服务器解析请求并返回http报文\" class=\"headerlink\" title=\"7.服务器解析请求并返回http报文\"></a>7.服务器解析请求并返回http报文</h3><p>服务器接收到请求信息后，会根据请求信息生成相应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应的内容了</p>\n<h3 id=\"8-浏览器渲染页面\"><a href=\"#8-浏览器渲染页面\" class=\"headerlink\" title=\"8.浏览器渲染页面\"></a>8.浏览器渲染页面</h3><ul>\n<li>DOM树（DOM）<ul>\n<li>字节（Bytes） -&gt; 字符（Characters） &gt; 令牌（token） -&gt; 节点（Nodes）-&gt; 文档对象模型（DOM）</li>\n</ul>\n</li>\n<li>CSS对象模型（CSSOM）</li>\n<li>布局树Layout Tree<ul>\n<li>DOM树与CSSOM树合并后形成渲染树（RenderTree）</li>\n<li>渲染树只包含渲染网页所需的节点</li>\n<li>布局计算每个对象的精确位置和大小</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上</li>\n</ul>\n</li>\n<li>渲染<ol>\n<li>获取DOM后分割为多个图层</li>\n<li>对每个图层的节点计算样式结果（Recalculate style –样式重计算）</li>\n<li>为每个节点生成图形和位置（Layout –重排，回流）</li>\n<li>将每个节点绘制填充到图层位图中（Paint –重绘）</li>\n<li>图层作为纹理上传至GPU</li>\n<li>组合多个图层到页面上生成最终屏幕图像（Composite Layers– 图层重组）</li>\n</ol>\n</li>\n<li>回流和重绘<ul>\n<li>重绘<ul>\n<li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如color、backgroundColor、visibility等），浏览器会将新样式赋予给元素并重置绘制它，这个过程称为重绘</li>\n</ul>\n</li>\n<li>回流<ul>\n<li>当Render Tree中部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流</li>\n</ul>\n</li>\n<li>回流必将引起重绘，而重绘不一定会引起回流</li>\n</ul>\n</li>\n<li>优化：<ol>\n<li>静态资源使用CDN，缩短静态资源请求时间</li>\n<li>将css放在文件头部，JavaScript文件放在底部</li>\n<li>图片优化<ol>\n<li>图片压缩</li>\n<li>图片懒加载</li>\n<li>使用svg响应式图片</li>\n<li>使用webp格式的图片</li>\n</ol>\n</li>\n<li>压缩文件<ol>\n<li>JavaScript：UglifyPlugin</li>\n<li>CSS ：MiniCssExtractPlugin</li>\n<li>HTML：HtmlWebpackPlugin</li>\n</ol>\n</li>\n<li>减少重绘重排</li>\n<li>代码分割（如路由懒加载）</li>\n<li>Tree Shaking<ul>\n<li>Tree Shaking的作用就是，通过程序流分析找出代码中无用的代码并剔除</li>\n</ul>\n</li>\n<li>使用服务端渲染</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"9-断开连接\"><a href=\"#9-断开连接\" class=\"headerlink\" title=\"9.断开连接\"></a>9.断开连接</h3><p>四次分手</p>\n"},{"title":"d3相关笔记","keywords":"d3","_content":"### 一.使用d3查询svg\n\nd3.select()、d3.selectAll()\n\n### 二.使用d3设置svg中的属性\n\nd3.attr()\n\n常见的属性：\n\n- id、class\n- x，y，cx，cy（cx、cy是圆的xy坐标）\n- fill（颜色填充color）、stroke（边框border）\n- height、width、r（圆的半径）\n- transform（translate、rotate、scale）\n\n### 三.使用d3添加、删除svg元素\n\nelement.append()、element.remove()\n\n### 四.d3的比例尺\n\n#### 1.d3.scaleLinear()：线性比例尺\n\ndomain:：连续型 range：连续型\n\n```javascript\nconst xScale = d3.scaleLinear()\n.domain([min_d, max_d]) // 连续型\n.range(min, max) // 连续型\n\nconst yScale = d3.scaleLinear()\n.domain([0, d3.max(data, item => item.value)])\n.range([0, innerWidth])\n```\n\nd3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值\n\n#### 2.d3.scaleBand()：序数比例尺\n\ndomain：离散型 range：连续性\n\n可以理解为用domain将range分割\n\n```javascript\nconst scale_b = d3.scaleBand()\n.domian([1,2,3,4]) // 离散型\n.range([0, 100]) // 连续型\n```\n\n#### 3.d3.scaleOrdinal()：序数比例尺\n\ndomain：离散型 range：离散型\n\n可以简单理解为map映射\n\n```javascript\nconst scaleO = d3.scaleOrdinal()\n.domain(['a','b','c']) // 离散型\n.range([10, 20, 30]) // 离散型\n```\n\n生成颜色比例尺\n\n```javascript\nconst color = d3.scaleOrdinal().domain(naiveKeys).range(d3.schemeSet2)\n```\n\n\n\n#### 4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\n\ndomain：连续型 range：离散型\n\n可以理解为scaleBand的逆变换\n\n```javascript\nconst scaleQ = d3.scaleQuantize()\n.domain([0, 10]) // 连续型\n.range(['a', 'b', 'c']) // 离散型\n```\n\n#### 5.d3.scaleTime()：时间比例尺\n\ndomain：连续型，是时间 range：连续，是刻度\n\n类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴\n\n```javascript\nconst scaleT = d3.scaleTime()\n.domain([new Date(2020, 01, 01), new Date(2021, 01, 01)]) // 连续型\n.range([0, 100]) // 连续型\n```\n\n#### 6.颜色比例尺\n\nd3提供了一些颜色比例尺，10就是10种颜色\n\n①Categorical系列——离散型颜色\nd3.schemeCategory10 // 10就是10种颜色\n\n![category10](/css/images/d3/category10.png)\n\nd3.schemeAccent\n\n![Accent](/css/images/d3/Accent.png)\n\n```javascript\n// 定义一个序数颜色比例尺\nconst color = d3.scaleLinear(d3.schemeCategory10)\n```\n\n②Diverging——连续型颜色（渐变颜色）\n\n方式一：d3.**interpolateBrBG**(*t*)——t => [0, 1]\n\n### 五.Data Join\n\n#### 1.本质上是将数据与图元进行绑定\n\nd3.selectAll(.class类名).data(data)\n\n#### 2.d3绑定数据的三个状态\n\nenter:\n\n- 有数据没有图元\n\n- d3会自动搞清楚哪些数据是新增的\n\n- 根据新增的数据生成对应的图元\n\n- 生成图元的占位，占位的内容需要通过append添加\n\n ```javascript\n  const p = d3.selectAll('.class').data(data).enter().append('rect').attr(...)\n  ```\nupdate:\n\n- 有图元有数据\n\n- update作为实际可视化任务最常用的状态，经常被单独封装为一个函数\n\n- updateSelection.merge(enterSelection).attr().attr()\n\n  - 将两个selection合并到一起操作\n  - enterSelection需要至少append()图元\n\n ```javascript\n  d3.selectAll(.class).data(data).update().transition().durantion(3000).attr('width', d => xScale(d.value))\n  ```\nexit\n\n- 有图元没数据\n\n- d3会自动搞清楚哪些图元是不绑定数据的\n\n ```\n  const p = d3.selectAll('.class').data(data).exit().remove()\n  ```\n\n#### 3.读取数据\n\nd3.csv('path/tp/data.csv').then(res => {})\n\n### 六.path\n\n#### 1.path元素的形状是通过属性d来定义的\n\n#### 2.d3 Path生成器\n\n- d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5) ----用于折线图\n- d3.geoPath().projection() ----用于地图\n- d3.area() ----用于主题河流\n- d3.arc().innerRadius().outerRadius() ----用于饼图\n- d3.lineRadial().angle().radius() ----极坐标系版本的d3.line()\n\n#### 3.d3.line()\n\nconst line = d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5)\n\n使用line:\n\nd3.select('path').datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据\n\n.attr('d', line) // 给path配置line\n\n### 七.interaction\n\n#### 1.地图数据的表达: Topojson & Geojson\n\n#### 2.json数据的读取\n\n```javascript\nd3.json('path/to/data.json').then( data => {… … …} ) \n```\n\n#### 3.topojson转geojson\n\n借助topojson.js库\n\n```javascript\ngeojson = topojson.feature(data, data.objects.countries)\n```\n\n#### 4.地图数据的可视化\n\n```javascript\nconst projection = d3.geoNaturalEarth1();\nconst pathGenerator = d3.geoPath().projection(projection)\n// geo适应宽高\nprojection.fitSize([innerWidth, innerHeight], geojson);\n// path使用geo\ng.selectAll(path).data(geojson.features).join()\n\t.attr('d',pathGenerator  )\n```\n\n#### 5.事件\n\n事件的设置对应于D3中的.on(‘eventName’, callBack) \n\n```javascript\nd3.selectAll('path').on('click', function () {\n  d3.select(this).attr()\n})\n```\n\n图元.on(事件类型, 触发动作) \n\n#### 6.d3-tip\n\ntooltip库，自动在‘合适’的位置显示对话框\n\n### 八.stack(堆叠)\n\n#### 1.d3.stack()\n\n本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）\n\n#### 2.语法\n\n```javascript\nconst stackData = d3.stack()\n\t.keys(naiveKeys) // 需要堆叠哪些字段的数据\n\t.order(d3.stackOrderNone) // 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序\n\t(naiveData)\n```\n\n### 九.tree\n\n#### 1.层级数据预处理d3.hierarchy\n\n- d3.hierarchy\n\n\n- 保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: \n- height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）\n\n\n- •d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中\n\n ```javascript\n  const root = d3.hierarchy(data)\n  ```\n\n#### 2.层级数据预处理d3.tree()\n\n- d3.tree().size([innerHeight, innerWidth])\n\n- 返回一个函数\n\n- 接受参数为d3.hierarchy\n\n- 函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）\n\n ```javascript\n  root = d3.tree().size([innerHeight, innerWidth])(root)\n  ```\n\n#### 3.root.links()和 d3.linkHorizontal()\n\n- root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用\n\n- d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来\n\n ```javascript\n  g.selectAll(\"path\")\n  \t.data(root.links())\n  \t.join(\"path\")\n  \t.attr(\"fill\", \"none\")\n  \t.attr(\"stroke\", \"black\")\n  \t.attr(\"stroke-width\", 1.5)\n  \t.attr(\"d\", d3.linkHorizontal().x(d => d.y).y(d => d.x));\n  ```\n\n#### 4.root.descendants()\n\n- root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组\n\n ```javascript\n  g.selectAll('text')\n  \t.data(root.descendants())\n  \t.join('text')\n  \t.text(d => d.data.name)\n  \t.attr('x', d => d.children ? d.y - 8 : d.y + 8)\n  \t.attr('y', d => d.x + 5)\n  \t.attr('font-size', '0.8em')\n  \t.attr('text-anchor', d => d.children ? 'end' : 'start')\n  ```\n\n  ​","source":"_posts/d3.md","raw":"---\ntitle: d3相关笔记\ntag: d3js\nkeywords: d3\ncategories: 前端可视化库\n---\n### 一.使用d3查询svg\n\nd3.select()、d3.selectAll()\n\n### 二.使用d3设置svg中的属性\n\nd3.attr()\n\n常见的属性：\n\n- id、class\n- x，y，cx，cy（cx、cy是圆的xy坐标）\n- fill（颜色填充color）、stroke（边框border）\n- height、width、r（圆的半径）\n- transform（translate、rotate、scale）\n\n### 三.使用d3添加、删除svg元素\n\nelement.append()、element.remove()\n\n### 四.d3的比例尺\n\n#### 1.d3.scaleLinear()：线性比例尺\n\ndomain:：连续型 range：连续型\n\n```javascript\nconst xScale = d3.scaleLinear()\n.domain([min_d, max_d]) // 连续型\n.range(min, max) // 连续型\n\nconst yScale = d3.scaleLinear()\n.domain([0, d3.max(data, item => item.value)])\n.range([0, innerWidth])\n```\n\nd3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值\n\n#### 2.d3.scaleBand()：序数比例尺\n\ndomain：离散型 range：连续性\n\n可以理解为用domain将range分割\n\n```javascript\nconst scale_b = d3.scaleBand()\n.domian([1,2,3,4]) // 离散型\n.range([0, 100]) // 连续型\n```\n\n#### 3.d3.scaleOrdinal()：序数比例尺\n\ndomain：离散型 range：离散型\n\n可以简单理解为map映射\n\n```javascript\nconst scaleO = d3.scaleOrdinal()\n.domain(['a','b','c']) // 离散型\n.range([10, 20, 30]) // 离散型\n```\n\n生成颜色比例尺\n\n```javascript\nconst color = d3.scaleOrdinal().domain(naiveKeys).range(d3.schemeSet2)\n```\n\n\n\n#### 4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\n\ndomain：连续型 range：离散型\n\n可以理解为scaleBand的逆变换\n\n```javascript\nconst scaleQ = d3.scaleQuantize()\n.domain([0, 10]) // 连续型\n.range(['a', 'b', 'c']) // 离散型\n```\n\n#### 5.d3.scaleTime()：时间比例尺\n\ndomain：连续型，是时间 range：连续，是刻度\n\n类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴\n\n```javascript\nconst scaleT = d3.scaleTime()\n.domain([new Date(2020, 01, 01), new Date(2021, 01, 01)]) // 连续型\n.range([0, 100]) // 连续型\n```\n\n#### 6.颜色比例尺\n\nd3提供了一些颜色比例尺，10就是10种颜色\n\n①Categorical系列——离散型颜色\nd3.schemeCategory10 // 10就是10种颜色\n\n![category10](/css/images/d3/category10.png)\n\nd3.schemeAccent\n\n![Accent](/css/images/d3/Accent.png)\n\n```javascript\n// 定义一个序数颜色比例尺\nconst color = d3.scaleLinear(d3.schemeCategory10)\n```\n\n②Diverging——连续型颜色（渐变颜色）\n\n方式一：d3.**interpolateBrBG**(*t*)——t => [0, 1]\n\n### 五.Data Join\n\n#### 1.本质上是将数据与图元进行绑定\n\nd3.selectAll(.class类名).data(data)\n\n#### 2.d3绑定数据的三个状态\n\nenter:\n\n- 有数据没有图元\n\n- d3会自动搞清楚哪些数据是新增的\n\n- 根据新增的数据生成对应的图元\n\n- 生成图元的占位，占位的内容需要通过append添加\n\n ```javascript\n  const p = d3.selectAll('.class').data(data).enter().append('rect').attr(...)\n  ```\nupdate:\n\n- 有图元有数据\n\n- update作为实际可视化任务最常用的状态，经常被单独封装为一个函数\n\n- updateSelection.merge(enterSelection).attr().attr()\n\n  - 将两个selection合并到一起操作\n  - enterSelection需要至少append()图元\n\n ```javascript\n  d3.selectAll(.class).data(data).update().transition().durantion(3000).attr('width', d => xScale(d.value))\n  ```\nexit\n\n- 有图元没数据\n\n- d3会自动搞清楚哪些图元是不绑定数据的\n\n ```\n  const p = d3.selectAll('.class').data(data).exit().remove()\n  ```\n\n#### 3.读取数据\n\nd3.csv('path/tp/data.csv').then(res => {})\n\n### 六.path\n\n#### 1.path元素的形状是通过属性d来定义的\n\n#### 2.d3 Path生成器\n\n- d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5) ----用于折线图\n- d3.geoPath().projection() ----用于地图\n- d3.area() ----用于主题河流\n- d3.arc().innerRadius().outerRadius() ----用于饼图\n- d3.lineRadial().angle().radius() ----极坐标系版本的d3.line()\n\n#### 3.d3.line()\n\nconst line = d3.line().x(d => xScale(xValue)).y(d => yScale(yValue)).curve(d3.curveCardinal.tension(0.5)\n\n使用line:\n\nd3.select('path').datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据\n\n.attr('d', line) // 给path配置line\n\n### 七.interaction\n\n#### 1.地图数据的表达: Topojson & Geojson\n\n#### 2.json数据的读取\n\n```javascript\nd3.json('path/to/data.json').then( data => {… … …} ) \n```\n\n#### 3.topojson转geojson\n\n借助topojson.js库\n\n```javascript\ngeojson = topojson.feature(data, data.objects.countries)\n```\n\n#### 4.地图数据的可视化\n\n```javascript\nconst projection = d3.geoNaturalEarth1();\nconst pathGenerator = d3.geoPath().projection(projection)\n// geo适应宽高\nprojection.fitSize([innerWidth, innerHeight], geojson);\n// path使用geo\ng.selectAll(path).data(geojson.features).join()\n\t.attr('d',pathGenerator  )\n```\n\n#### 5.事件\n\n事件的设置对应于D3中的.on(‘eventName’, callBack) \n\n```javascript\nd3.selectAll('path').on('click', function () {\n  d3.select(this).attr()\n})\n```\n\n图元.on(事件类型, 触发动作) \n\n#### 6.d3-tip\n\ntooltip库，自动在‘合适’的位置显示对话框\n\n### 八.stack(堆叠)\n\n#### 1.d3.stack()\n\n本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）\n\n#### 2.语法\n\n```javascript\nconst stackData = d3.stack()\n\t.keys(naiveKeys) // 需要堆叠哪些字段的数据\n\t.order(d3.stackOrderNone) // 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序\n\t(naiveData)\n```\n\n### 九.tree\n\n#### 1.层级数据预处理d3.hierarchy\n\n- d3.hierarchy\n\n\n- 保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: \n- height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）\n\n\n- •d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中\n\n ```javascript\n  const root = d3.hierarchy(data)\n  ```\n\n#### 2.层级数据预处理d3.tree()\n\n- d3.tree().size([innerHeight, innerWidth])\n\n- 返回一个函数\n\n- 接受参数为d3.hierarchy\n\n- 函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）\n\n ```javascript\n  root = d3.tree().size([innerHeight, innerWidth])(root)\n  ```\n\n#### 3.root.links()和 d3.linkHorizontal()\n\n- root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用\n\n- d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来\n\n ```javascript\n  g.selectAll(\"path\")\n  \t.data(root.links())\n  \t.join(\"path\")\n  \t.attr(\"fill\", \"none\")\n  \t.attr(\"stroke\", \"black\")\n  \t.attr(\"stroke-width\", 1.5)\n  \t.attr(\"d\", d3.linkHorizontal().x(d => d.y).y(d => d.x));\n  ```\n\n#### 4.root.descendants()\n\n- root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组\n\n ```javascript\n  g.selectAll('text')\n  \t.data(root.descendants())\n  \t.join('text')\n  \t.text(d => d.data.name)\n  \t.attr('x', d => d.children ? d.y - 8 : d.y + 8)\n  \t.attr('y', d => d.x + 5)\n  \t.attr('font-size', '0.8em')\n  \t.attr('text-anchor', d => d.children ? 'end' : 'start')\n  ```\n\n  ​","slug":"d3","published":1,"date":"2021-07-14T06:42:56.000Z","updated":"2021-10-14T01:38:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldmrd9l30011i024be3qdils","content":"<h3 id=\"一-使用d3查询svg\"><a href=\"#一-使用d3查询svg\" class=\"headerlink\" title=\"一.使用d3查询svg\"></a>一.使用d3查询svg</h3><p>d3.select()、d3.selectAll()</p>\n<h3 id=\"二-使用d3设置svg中的属性\"><a href=\"#二-使用d3设置svg中的属性\" class=\"headerlink\" title=\"二.使用d3设置svg中的属性\"></a>二.使用d3设置svg中的属性</h3><p>d3.attr()</p>\n<p>常见的属性：</p>\n<ul>\n<li>id、class</li>\n<li>x，y，cx，cy（cx、cy是圆的xy坐标）</li>\n<li>fill（颜色填充color）、stroke（边框border）</li>\n<li>height、width、r（圆的半径）</li>\n<li>transform（translate、rotate、scale）</li>\n</ul>\n<h3 id=\"三-使用d3添加、删除svg元素\"><a href=\"#三-使用d3添加、删除svg元素\" class=\"headerlink\" title=\"三.使用d3添加、删除svg元素\"></a>三.使用d3添加、删除svg元素</h3><p>element.append()、element.remove()</p>\n<h3 id=\"四-d3的比例尺\"><a href=\"#四-d3的比例尺\" class=\"headerlink\" title=\"四.d3的比例尺\"></a>四.d3的比例尺</h3><h4 id=\"1-d3-scaleLinear-：线性比例尺\"><a href=\"#1-d3-scaleLinear-：线性比例尺\" class=\"headerlink\" title=\"1.d3.scaleLinear()：线性比例尺\"></a>1.d3.scaleLinear()：线性比例尺</h4><p>domain:：连续型 range：连续型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> xScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([min_d, max_d]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>(min, max) <span class=\"hljs-comment\">// 连续型</span><br><br><span class=\"hljs-keyword\">const</span> yScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, d3.<span class=\"hljs-title function_\">max</span>(data, <span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-property\">value</span>)])<br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, innerWidth])<br></code></pre></td></tr></table></figure>\n\n<p>d3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值</p>\n<h4 id=\"2-d3-scaleBand-：序数比例尺\"><a href=\"#2-d3-scaleBand-：序数比例尺\" class=\"headerlink\" title=\"2.d3.scaleBand()：序数比例尺\"></a>2.d3.scaleBand()：序数比例尺</h4><p>domain：离散型 range：连续性</p>\n<p>可以理解为用domain将range分割</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scale_b = d3.<span class=\"hljs-title function_\">scaleBand</span>()<br>.<span class=\"hljs-title function_\">domian</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-d3-scaleOrdinal-：序数比例尺\"><a href=\"#3-d3-scaleOrdinal-：序数比例尺\" class=\"headerlink\" title=\"3.d3.scaleOrdinal()：序数比例尺\"></a>3.d3.scaleOrdinal()：序数比例尺</h4><p>domain：离散型 range：离散型</p>\n<p>可以简单理解为map映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleO = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<p>生成颜色比例尺</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>().<span class=\"hljs-title function_\">domain</span>(naiveKeys).<span class=\"hljs-title function_\">range</span>(d3.<span class=\"hljs-property\">schemeSet2</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\"><a href=\"#4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\" class=\"headerlink\" title=\"4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\"></a>4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)</h4><p>domain：连续型 range：离散型</p>\n<p>可以理解为scaleBand的逆变换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleQ = d3.<span class=\"hljs-title function_\">scaleQuantize</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-d3-scaleTime-：时间比例尺\"><a href=\"#5-d3-scaleTime-：时间比例尺\" class=\"headerlink\" title=\"5.d3.scaleTime()：时间比例尺\"></a>5.d3.scaleTime()：时间比例尺</h4><p>domain：连续型，是时间 range：连续，是刻度</p>\n<p>类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleT = d3.<span class=\"hljs-title function_\">scaleTime</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2020</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>)]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-颜色比例尺\"><a href=\"#6-颜色比例尺\" class=\"headerlink\" title=\"6.颜色比例尺\"></a>6.颜色比例尺</h4><p>d3提供了一些颜色比例尺，10就是10种颜色</p>\n<p>①Categorical系列——离散型颜色<br>d3.schemeCategory10 // 10就是10种颜色</p>\n<p><img src=\"/css/images/d3/category10.png\" alt=\"category10\"></p>\n<p>d3.schemeAccent</p>\n<p><img src=\"/css/images/d3/Accent.png\" alt=\"Accent\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义一个序数颜色比例尺</span><br><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleLinear</span>(d3.<span class=\"hljs-property\">schemeCategory10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>②Diverging——连续型颜色（渐变颜色）</p>\n<p>方式一：d3.<strong>interpolateBrBG</strong>(<em>t</em>)——t =&gt; [0, 1]</p>\n<h3 id=\"五-Data-Join\"><a href=\"#五-Data-Join\" class=\"headerlink\" title=\"五.Data Join\"></a>五.Data Join</h3><h4 id=\"1-本质上是将数据与图元进行绑定\"><a href=\"#1-本质上是将数据与图元进行绑定\" class=\"headerlink\" title=\"1.本质上是将数据与图元进行绑定\"></a>1.本质上是将数据与图元进行绑定</h4><p>d3.selectAll(.class类名).data(data)</p>\n<h4 id=\"2-d3绑定数据的三个状态\"><a href=\"#2-d3绑定数据的三个状态\" class=\"headerlink\" title=\"2.d3绑定数据的三个状态\"></a>2.d3绑定数据的三个状态</h4><p>enter:</p>\n<ul>\n<li><p>有数据没有图元</p>\n</li>\n<li><p>d3会自动搞清楚哪些数据是新增的</p>\n</li>\n<li><p>根据新增的数据生成对应的图元</p>\n</li>\n<li><p>生成图元的占位，占位的内容需要通过append添加</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">enter</span>().<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;rect&#x27;</span>).<span class=\"hljs-title function_\">attr</span>(...)<br></code></pre></td></tr></table></figure>\n<p>update:</p>\n<ul>\n<li><p>有图元有数据</p>\n</li>\n<li><p>update作为实际可视化任务最常用的状态，经常被单独封装为一个函数</p>\n</li>\n<li><p>updateSelection.merge(enterSelection).attr().attr()</p>\n<ul>\n<li>将两个selection合并到一起操作</li>\n<li>enterSelection需要至少append()图元</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(.<span class=\"hljs-property\">class</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">update</span>().<span class=\"hljs-title function_\">transition</span>().<span class=\"hljs-title function_\">durantion</span>(<span class=\"hljs-number\">3000</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;width&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> <span class=\"hljs-title function_\">xScale</span>(d.<span class=\"hljs-property\">value</span>))<br></code></pre></td></tr></table></figure>\n<p>exit</p>\n<ul>\n<li><p>有图元没数据</p>\n</li>\n<li><p>d3会自动搞清楚哪些图元是不绑定数据的</p>\n</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const p = d3.selectAll(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).data(data).<span class=\"hljs-keyword\">exit</span>().remove()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-读取数据\"><a href=\"#3-读取数据\" class=\"headerlink\" title=\"3.读取数据\"></a>3.读取数据</h4><p>d3.csv(‘path/tp/data.csv’).then(res =&gt; {})</p>\n<h3 id=\"六-path\"><a href=\"#六-path\" class=\"headerlink\" title=\"六.path\"></a>六.path</h3><h4 id=\"1-path元素的形状是通过属性d来定义的\"><a href=\"#1-path元素的形状是通过属性d来定义的\" class=\"headerlink\" title=\"1.path元素的形状是通过属性d来定义的\"></a>1.path元素的形状是通过属性d来定义的</h4><h4 id=\"2-d3-Path生成器\"><a href=\"#2-d3-Path生成器\" class=\"headerlink\" title=\"2.d3 Path生成器\"></a>2.d3 Path生成器</h4><ul>\n<li>d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5) —-用于折线图</li>\n<li>d3.geoPath().projection() —-用于地图</li>\n<li>d3.area() —-用于主题河流</li>\n<li>d3.arc().innerRadius().outerRadius() —-用于饼图</li>\n<li>d3.lineRadial().angle().radius() —-极坐标系版本的d3.line()</li>\n</ul>\n<h4 id=\"3-d3-line\"><a href=\"#3-d3-line\" class=\"headerlink\" title=\"3.d3.line()\"></a>3.d3.line()</h4><p>const line = d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5)</p>\n<p>使用line:</p>\n<p>d3.select(‘path’).datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据</p>\n<p>.attr(‘d’, line) // 给path配置line</p>\n<h3 id=\"七-interaction\"><a href=\"#七-interaction\" class=\"headerlink\" title=\"七.interaction\"></a>七.interaction</h3><h4 id=\"1-地图数据的表达-Topojson-amp-Geojson\"><a href=\"#1-地图数据的表达-Topojson-amp-Geojson\" class=\"headerlink\" title=\"1.地图数据的表达: Topojson &amp; Geojson\"></a>1.地图数据的表达: Topojson &amp; Geojson</h4><h4 id=\"2-json数据的读取\"><a href=\"#2-json数据的读取\" class=\"headerlink\" title=\"2.json数据的读取\"></a>2.json数据的读取</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">json</span>(<span class=\"hljs-string\">&#x27;path/to/data.json&#x27;</span>).<span class=\"hljs-title function_\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;… … …&#125; ) <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-topojson转geojson\"><a href=\"#3-topojson转geojson\" class=\"headerlink\" title=\"3.topojson转geojson\"></a>3.topojson转geojson</h4><p>借助topojson.js库</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">geojson = topojson.<span class=\"hljs-title function_\">feature</span>(data, data.<span class=\"hljs-property\">objects</span>.<span class=\"hljs-property\">countries</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-地图数据的可视化\"><a href=\"#4-地图数据的可视化\" class=\"headerlink\" title=\"4.地图数据的可视化\"></a>4.地图数据的可视化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> projection = d3.<span class=\"hljs-title function_\">geoNaturalEarth1</span>();<br><span class=\"hljs-keyword\">const</span> pathGenerator = d3.<span class=\"hljs-title function_\">geoPath</span>().<span class=\"hljs-title function_\">projection</span>(projection)<br><span class=\"hljs-comment\">// geo适应宽高</span><br>projection.<span class=\"hljs-title function_\">fitSize</span>([innerWidth, innerHeight], geojson);<br><span class=\"hljs-comment\">// path使用geo</span><br>g.<span class=\"hljs-title function_\">selectAll</span>(path).<span class=\"hljs-title function_\">data</span>(geojson.<span class=\"hljs-property\">features</span>).<span class=\"hljs-title function_\">join</span>()<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>,pathGenerator  )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-事件\"><a href=\"#5-事件\" class=\"headerlink\" title=\"5.事件\"></a>5.事件</h4><p>事件的设置对应于D3中的.on(‘eventName’, callBack) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  d3.<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>图元.on(事件类型, 触发动作) </p>\n<h4 id=\"6-d3-tip\"><a href=\"#6-d3-tip\" class=\"headerlink\" title=\"6.d3-tip\"></a>6.d3-tip</h4><p>tooltip库，自动在‘合适’的位置显示对话框</p>\n<h3 id=\"八-stack-堆叠\"><a href=\"#八-stack-堆叠\" class=\"headerlink\" title=\"八.stack(堆叠)\"></a>八.stack(堆叠)</h3><h4 id=\"1-d3-stack\"><a href=\"#1-d3-stack\" class=\"headerlink\" title=\"1.d3.stack()\"></a>1.d3.stack()</h4><p>本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）</p>\n<h4 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2.语法\"></a>2.语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> stackData = d3.<span class=\"hljs-title function_\">stack</span>()<br>\t.<span class=\"hljs-title function_\">keys</span>(naiveKeys) <span class=\"hljs-comment\">// 需要堆叠哪些字段的数据</span><br>\t.<span class=\"hljs-title function_\">order</span>(d3.<span class=\"hljs-property\">stackOrderNone</span>) <span class=\"hljs-comment\">// 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序</span><br>\t(naiveData)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"九-tree\"><a href=\"#九-tree\" class=\"headerlink\" title=\"九.tree\"></a>九.tree</h3><h4 id=\"1-层级数据预处理d3-hierarchy\"><a href=\"#1-层级数据预处理d3-hierarchy\" class=\"headerlink\" title=\"1.层级数据预处理d3.hierarchy\"></a>1.层级数据预处理d3.hierarchy</h4><ul>\n<li>d3.hierarchy</li>\n</ul>\n<ul>\n<li>保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: </li>\n<li>height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）</li>\n</ul>\n<ul>\n<li>•d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-层级数据预处理d3-tree\"><a href=\"#2-层级数据预处理d3-tree\" class=\"headerlink\" title=\"2.层级数据预处理d3.tree()\"></a>2.层级数据预处理d3.tree()</h4><ul>\n<li><p>d3.tree().size([innerHeight, innerWidth])</p>\n</li>\n<li><p>返回一个函数</p>\n</li>\n<li><p>接受参数为d3.hierarchy</p>\n</li>\n<li><p>函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">root = d3.<span class=\"hljs-title function_\">tree</span>().<span class=\"hljs-title function_\">size</span>([innerHeight, innerWidth])(root)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-root-links-和-d3-linkHorizontal\"><a href=\"#3-root-links-和-d3-linkHorizontal\" class=\"headerlink\" title=\"3.root.links()和 d3.linkHorizontal()\"></a>3.root.links()和 d3.linkHorizontal()</h4><ul>\n<li><p>root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用</p>\n</li>\n<li><p>d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">links</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;fill&quot;</span>, <span class=\"hljs-string\">&quot;none&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke&quot;</span>, <span class=\"hljs-string\">&quot;black&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke-width&quot;</span>, <span class=\"hljs-number\">1.5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;d&quot;</span>, d3.<span class=\"hljs-title function_\">linkHorizontal</span>().<span class=\"hljs-title function_\">x</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">y</span>).<span class=\"hljs-title function_\">y</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span>));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-root-descendants\"><a href=\"#4-root-descendants\" class=\"headerlink\" title=\"4.root.descendants()\"></a>4.root.descendants()</h4><ul>\n<li>root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">descendants</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">name</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? d.<span class=\"hljs-property\">y</span> - <span class=\"hljs-number\">8</span> : d.<span class=\"hljs-property\">y</span> + <span class=\"hljs-number\">8</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span> + <span class=\"hljs-number\">5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;font-size&#x27;</span>, <span class=\"hljs-string\">&#x27;0.8em&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;text-anchor&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? <span class=\"hljs-string\">&#x27;end&#x27;</span> : <span class=\"hljs-string\">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  ​</p>\n","site":{"data":{}},"wordcount":4783,"excerpt":"","more":"<h3 id=\"一-使用d3查询svg\"><a href=\"#一-使用d3查询svg\" class=\"headerlink\" title=\"一.使用d3查询svg\"></a>一.使用d3查询svg</h3><p>d3.select()、d3.selectAll()</p>\n<h3 id=\"二-使用d3设置svg中的属性\"><a href=\"#二-使用d3设置svg中的属性\" class=\"headerlink\" title=\"二.使用d3设置svg中的属性\"></a>二.使用d3设置svg中的属性</h3><p>d3.attr()</p>\n<p>常见的属性：</p>\n<ul>\n<li>id、class</li>\n<li>x，y，cx，cy（cx、cy是圆的xy坐标）</li>\n<li>fill（颜色填充color）、stroke（边框border）</li>\n<li>height、width、r（圆的半径）</li>\n<li>transform（translate、rotate、scale）</li>\n</ul>\n<h3 id=\"三-使用d3添加、删除svg元素\"><a href=\"#三-使用d3添加、删除svg元素\" class=\"headerlink\" title=\"三.使用d3添加、删除svg元素\"></a>三.使用d3添加、删除svg元素</h3><p>element.append()、element.remove()</p>\n<h3 id=\"四-d3的比例尺\"><a href=\"#四-d3的比例尺\" class=\"headerlink\" title=\"四.d3的比例尺\"></a>四.d3的比例尺</h3><h4 id=\"1-d3-scaleLinear-：线性比例尺\"><a href=\"#1-d3-scaleLinear-：线性比例尺\" class=\"headerlink\" title=\"1.d3.scaleLinear()：线性比例尺\"></a>1.d3.scaleLinear()：线性比例尺</h4><p>domain:：连续型 range：连续型</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> xScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([min_d, max_d]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>(min, max) <span class=\"hljs-comment\">// 连续型</span><br><br><span class=\"hljs-keyword\">const</span> yScale = d3.<span class=\"hljs-title function_\">scaleLinear</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, d3.<span class=\"hljs-title function_\">max</span>(data, <span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-property\">value</span>)])<br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, innerWidth])<br></code></pre></td></tr></table></figure>\n\n<p>d3.max(数据，回调：如何提取数据的值)：求出数据某一属性的最大值</p>\n<h4 id=\"2-d3-scaleBand-：序数比例尺\"><a href=\"#2-d3-scaleBand-：序数比例尺\" class=\"headerlink\" title=\"2.d3.scaleBand()：序数比例尺\"></a>2.d3.scaleBand()：序数比例尺</h4><p>domain：离散型 range：连续性</p>\n<p>可以理解为用domain将range分割</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scale_b = d3.<span class=\"hljs-title function_\">scaleBand</span>()<br>.<span class=\"hljs-title function_\">domian</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-d3-scaleOrdinal-：序数比例尺\"><a href=\"#3-d3-scaleOrdinal-：序数比例尺\" class=\"headerlink\" title=\"3.d3.scaleOrdinal()：序数比例尺\"></a>3.d3.scaleOrdinal()：序数比例尺</h4><p>domain：离散型 range：离散型</p>\n<p>可以简单理解为map映射</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleO = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<p>生成颜色比例尺</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleOrdinal</span>().<span class=\"hljs-title function_\">domain</span>(naiveKeys).<span class=\"hljs-title function_\">range</span>(d3.<span class=\"hljs-property\">schemeSet2</span>)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\"><a href=\"#4-d3-scaleQuantize-：量化比例尺-把连续性的值转换为离散型的值\" class=\"headerlink\" title=\"4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)\"></a>4.d3.scaleQuantize()：量化比例尺(把连续性的值转换为离散型的值)</h4><p>domain：连续型 range：离散型</p>\n<p>可以理解为scaleBand的逆变换</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleQ = d3.<span class=\"hljs-title function_\">scaleQuantize</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]) <span class=\"hljs-comment\">// 离散型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-d3-scaleTime-：时间比例尺\"><a href=\"#5-d3-scaleTime-：时间比例尺\" class=\"headerlink\" title=\"5.d3.scaleTime()：时间比例尺\"></a>5.d3.scaleTime()：时间比例尺</h4><p>domain：连续型，是时间 range：连续，是刻度</p>\n<p>类似于d3.scaleLinear()线性比例尺，只不过输入域变成了时间轴</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> scaleT = d3.<span class=\"hljs-title function_\">scaleTime</span>()<br>.<span class=\"hljs-title function_\">domain</span>([<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2020</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">01</span>, <span class=\"hljs-number\">01</span>)]) <span class=\"hljs-comment\">// 连续型</span><br>.<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>]) <span class=\"hljs-comment\">// 连续型</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"6-颜色比例尺\"><a href=\"#6-颜色比例尺\" class=\"headerlink\" title=\"6.颜色比例尺\"></a>6.颜色比例尺</h4><p>d3提供了一些颜色比例尺，10就是10种颜色</p>\n<p>①Categorical系列——离散型颜色<br>d3.schemeCategory10 // 10就是10种颜色</p>\n<p><img src=\"/css/images/d3/category10.png\" alt=\"category10\"></p>\n<p>d3.schemeAccent</p>\n<p><img src=\"/css/images/d3/Accent.png\" alt=\"Accent\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义一个序数颜色比例尺</span><br><span class=\"hljs-keyword\">const</span> color = d3.<span class=\"hljs-title function_\">scaleLinear</span>(d3.<span class=\"hljs-property\">schemeCategory10</span>)<br></code></pre></td></tr></table></figure>\n\n<p>②Diverging——连续型颜色（渐变颜色）</p>\n<p>方式一：d3.<strong>interpolateBrBG</strong>(<em>t</em>)——t =&gt; [0, 1]</p>\n<h3 id=\"五-Data-Join\"><a href=\"#五-Data-Join\" class=\"headerlink\" title=\"五.Data Join\"></a>五.Data Join</h3><h4 id=\"1-本质上是将数据与图元进行绑定\"><a href=\"#1-本质上是将数据与图元进行绑定\" class=\"headerlink\" title=\"1.本质上是将数据与图元进行绑定\"></a>1.本质上是将数据与图元进行绑定</h4><p>d3.selectAll(.class类名).data(data)</p>\n<h4 id=\"2-d3绑定数据的三个状态\"><a href=\"#2-d3绑定数据的三个状态\" class=\"headerlink\" title=\"2.d3绑定数据的三个状态\"></a>2.d3绑定数据的三个状态</h4><p>enter:</p>\n<ul>\n<li><p>有数据没有图元</p>\n</li>\n<li><p>d3会自动搞清楚哪些数据是新增的</p>\n</li>\n<li><p>根据新增的数据生成对应的图元</p>\n</li>\n<li><p>生成图元的占位，占位的内容需要通过append添加</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p = d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">enter</span>().<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;rect&#x27;</span>).<span class=\"hljs-title function_\">attr</span>(...)<br></code></pre></td></tr></table></figure>\n<p>update:</p>\n<ul>\n<li><p>有图元有数据</p>\n</li>\n<li><p>update作为实际可视化任务最常用的状态，经常被单独封装为一个函数</p>\n</li>\n<li><p>updateSelection.merge(enterSelection).attr().attr()</p>\n<ul>\n<li>将两个selection合并到一起操作</li>\n<li>enterSelection需要至少append()图元</li>\n</ul>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(.<span class=\"hljs-property\">class</span>).<span class=\"hljs-title function_\">data</span>(data).<span class=\"hljs-title function_\">update</span>().<span class=\"hljs-title function_\">transition</span>().<span class=\"hljs-title function_\">durantion</span>(<span class=\"hljs-number\">3000</span>).<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;width&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> <span class=\"hljs-title function_\">xScale</span>(d.<span class=\"hljs-property\">value</span>))<br></code></pre></td></tr></table></figure>\n<p>exit</p>\n<ul>\n<li><p>有图元没数据</p>\n</li>\n<li><p>d3会自动搞清楚哪些图元是不绑定数据的</p>\n</li>\n</ul>\n <figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const p = d3.selectAll(<span class=\"hljs-string\">&#x27;.class&#x27;</span>).data(data).<span class=\"hljs-keyword\">exit</span>().remove()<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-读取数据\"><a href=\"#3-读取数据\" class=\"headerlink\" title=\"3.读取数据\"></a>3.读取数据</h4><p>d3.csv(‘path/tp/data.csv’).then(res =&gt; {})</p>\n<h3 id=\"六-path\"><a href=\"#六-path\" class=\"headerlink\" title=\"六.path\"></a>六.path</h3><h4 id=\"1-path元素的形状是通过属性d来定义的\"><a href=\"#1-path元素的形状是通过属性d来定义的\" class=\"headerlink\" title=\"1.path元素的形状是通过属性d来定义的\"></a>1.path元素的形状是通过属性d来定义的</h4><h4 id=\"2-d3-Path生成器\"><a href=\"#2-d3-Path生成器\" class=\"headerlink\" title=\"2.d3 Path生成器\"></a>2.d3 Path生成器</h4><ul>\n<li>d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5) —-用于折线图</li>\n<li>d3.geoPath().projection() —-用于地图</li>\n<li>d3.area() —-用于主题河流</li>\n<li>d3.arc().innerRadius().outerRadius() —-用于饼图</li>\n<li>d3.lineRadial().angle().radius() —-极坐标系版本的d3.line()</li>\n</ul>\n<h4 id=\"3-d3-line\"><a href=\"#3-d3-line\" class=\"headerlink\" title=\"3.d3.line()\"></a>3.d3.line()</h4><p>const line = d3.line().x(d =&gt; xScale(xValue)).y(d =&gt; yScale(yValue)).curve(d3.curveCardinal.tension(0.5)</p>\n<p>使用line:</p>\n<p>d3.select(‘path’).datum(data) // 给特定一个图元绑定一个数据，data是给一批图元绑定一批数据</p>\n<p>.attr(‘d’, line) // 给path配置line</p>\n<h3 id=\"七-interaction\"><a href=\"#七-interaction\" class=\"headerlink\" title=\"七.interaction\"></a>七.interaction</h3><h4 id=\"1-地图数据的表达-Topojson-amp-Geojson\"><a href=\"#1-地图数据的表达-Topojson-amp-Geojson\" class=\"headerlink\" title=\"1.地图数据的表达: Topojson &amp; Geojson\"></a>1.地图数据的表达: Topojson &amp; Geojson</h4><h4 id=\"2-json数据的读取\"><a href=\"#2-json数据的读取\" class=\"headerlink\" title=\"2.json数据的读取\"></a>2.json数据的读取</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">json</span>(<span class=\"hljs-string\">&#x27;path/to/data.json&#x27;</span>).<span class=\"hljs-title function_\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;… … …&#125; ) <br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-topojson转geojson\"><a href=\"#3-topojson转geojson\" class=\"headerlink\" title=\"3.topojson转geojson\"></a>3.topojson转geojson</h4><p>借助topojson.js库</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">geojson = topojson.<span class=\"hljs-title function_\">feature</span>(data, data.<span class=\"hljs-property\">objects</span>.<span class=\"hljs-property\">countries</span>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-地图数据的可视化\"><a href=\"#4-地图数据的可视化\" class=\"headerlink\" title=\"4.地图数据的可视化\"></a>4.地图数据的可视化</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> projection = d3.<span class=\"hljs-title function_\">geoNaturalEarth1</span>();<br><span class=\"hljs-keyword\">const</span> pathGenerator = d3.<span class=\"hljs-title function_\">geoPath</span>().<span class=\"hljs-title function_\">projection</span>(projection)<br><span class=\"hljs-comment\">// geo适应宽高</span><br>projection.<span class=\"hljs-title function_\">fitSize</span>([innerWidth, innerHeight], geojson);<br><span class=\"hljs-comment\">// path使用geo</span><br>g.<span class=\"hljs-title function_\">selectAll</span>(path).<span class=\"hljs-title function_\">data</span>(geojson.<span class=\"hljs-property\">features</span>).<span class=\"hljs-title function_\">join</span>()<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>,pathGenerator  )<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-事件\"><a href=\"#5-事件\" class=\"headerlink\" title=\"5.事件\"></a>5.事件</h4><p>事件的设置对应于D3中的.on(‘eventName’, callBack) </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>).<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  d3.<span class=\"hljs-title function_\">select</span>(<span class=\"hljs-variable language_\">this</span>).<span class=\"hljs-title function_\">attr</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>图元.on(事件类型, 触发动作) </p>\n<h4 id=\"6-d3-tip\"><a href=\"#6-d3-tip\" class=\"headerlink\" title=\"6.d3-tip\"></a>6.d3-tip</h4><p>tooltip库，自动在‘合适’的位置显示对话框</p>\n<h3 id=\"八-stack-堆叠\"><a href=\"#八-stack-堆叠\" class=\"headerlink\" title=\"八.stack(堆叠)\"></a>八.stack(堆叠)</h3><h4 id=\"1-d3-stack\"><a href=\"#1-d3-stack\" class=\"headerlink\" title=\"1.d3.stack()\"></a>1.d3.stack()</h4><p>本质上是d3.js提供的用于数据预处理的接口（生成堆叠数据）</p>\n<h4 id=\"2-语法\"><a href=\"#2-语法\" class=\"headerlink\" title=\"2.语法\"></a>2.语法</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> stackData = d3.<span class=\"hljs-title function_\">stack</span>()<br>\t.<span class=\"hljs-title function_\">keys</span>(naiveKeys) <span class=\"hljs-comment\">// 需要堆叠哪些字段的数据</span><br>\t.<span class=\"hljs-title function_\">order</span>(d3.<span class=\"hljs-property\">stackOrderNone</span>) <span class=\"hljs-comment\">// 怎么排序 stackOrderNone：按原生数据的顺序 stackAscending: 升序排序 stackDescending: 降序排序</span><br>\t(naiveData)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"九-tree\"><a href=\"#九-tree\" class=\"headerlink\" title=\"九.tree\"></a>九.tree</h3><h4 id=\"1-层级数据预处理d3-hierarchy\"><a href=\"#1-层级数据预处理d3-hierarchy\" class=\"headerlink\" title=\"1.层级数据预处理d3.hierarchy\"></a>1.层级数据预处理d3.hierarchy</h4><ul>\n<li>d3.hierarchy</li>\n</ul>\n<ul>\n<li>保持数据的原始结构，并将输入层级数据转换成D3中的hierarcy对象(result instanceof d3.hierarchy)，同时引入: </li>\n<li>height （* 不是逐层递减）、depth、children (原始结构) parent、（data 原始数据的映射）</li>\n</ul>\n<ul>\n<li>•d3.hierarchy可作为一个‘中间结果’，继续输入到更多D3.js提供的数据预处理接口中</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-层级数据预处理d3-tree\"><a href=\"#2-层级数据预处理d3-tree\" class=\"headerlink\" title=\"2.层级数据预处理d3.tree()\"></a>2.层级数据预处理d3.tree()</h4><ul>\n<li><p>d3.tree().size([innerHeight, innerWidth])</p>\n</li>\n<li><p>返回一个函数</p>\n</li>\n<li><p>接受参数为d3.hierarchy</p>\n</li>\n<li><p>函数会根据设置的size将树形结构的每个节点映射到空间中‘合适’的位置（添加横纵坐标节点）</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">root = d3.<span class=\"hljs-title function_\">tree</span>().<span class=\"hljs-title function_\">size</span>([innerHeight, innerWidth])(root)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-root-links-和-d3-linkHorizontal\"><a href=\"#3-root-links-和-d3-linkHorizontal\" class=\"headerlink\" title=\"3.root.links()和 d3.linkHorizontal()\"></a>3.root.links()和 d3.linkHorizontal()</h4><ul>\n<li><p>root.links()返回树形结构中存在的所有‘链接’(带有source和target树形)，作为data join的参数，供后续设置三次贝塞尔曲线的x和y使用</p>\n</li>\n<li><p>d3.linkHorizontal()生成一个从source到target的三次贝塞尔曲线。.x(…)与.y(…)分别表示如何在source与target中取横纵坐标值。默认生成的是纵向的树形图，横纵坐标值取相反的值将图形翻转过来</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">links</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&quot;path&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;fill&quot;</span>, <span class=\"hljs-string\">&quot;none&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke&quot;</span>, <span class=\"hljs-string\">&quot;black&quot;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;stroke-width&quot;</span>, <span class=\"hljs-number\">1.5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&quot;d&quot;</span>, d3.<span class=\"hljs-title function_\">linkHorizontal</span>().<span class=\"hljs-title function_\">x</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">y</span>).<span class=\"hljs-title function_\">y</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span>));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-root-descendants\"><a href=\"#4-root-descendants\" class=\"headerlink\" title=\"4.root.descendants()\"></a>4.root.descendants()</h4><ul>\n<li>root.descendants()返回层级结构中的所有节点，广度优先（层次优先），返回的内容本质上是对象的数组</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">g.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">data</span>(root.<span class=\"hljs-title function_\">descendants</span>())<br>\t.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;text&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">name</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;x&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? d.<span class=\"hljs-property\">y</span> - <span class=\"hljs-number\">8</span> : d.<span class=\"hljs-property\">y</span> + <span class=\"hljs-number\">8</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;y&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">x</span> + <span class=\"hljs-number\">5</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;font-size&#x27;</span>, <span class=\"hljs-string\">&#x27;0.8em&#x27;</span>)<br>\t.<span class=\"hljs-title function_\">attr</span>(<span class=\"hljs-string\">&#x27;text-anchor&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">children</span> ? <span class=\"hljs-string\">&#x27;end&#x27;</span> : <span class=\"hljs-string\">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>  ​</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cldmrd9km0001i0242i0980ao","category_id":"cldmrd9ks0004i024d3fr7mug","_id":"cldmrd9kv000ci024ftycbk6q"},{"post_id":"cldmrd9kq0003i024g7288bfo","category_id":"cldmrd9ku0009i02437ragvvd","_id":"cldmrd9kv000ei024dejd78go"},{"post_id":"cldmrd9kw000fi024baql32el","category_id":"cldmrd9kx000hi024gfpp0gmo","_id":"cldmrd9l1000ri02403k8e7tu"},{"post_id":"cldmrd9ky000li02488sz67n4","category_id":"cldmrd9ks0004i024d3fr7mug","_id":"cldmrd9l2000vi0241kggee3w"},{"post_id":"cldmrd9kx000gi024ed3m1f2f","category_id":"cldmrd9kz000mi024fqekh1u2","_id":"cldmrd9l3000yi024gxpq6e9i"},{"post_id":"cldmrd9kx000ji024c0vsdswz","category_id":"cldmrd9l1000si02406nyg36b","_id":"cldmrd9l40013i024ffd85y4f"},{"post_id":"cldmrd9l30011i024be3qdils","category_id":"cldmrd9ks0004i024d3fr7mug","_id":"cldmrd9l40017i024hikf7x5y"},{"post_id":"cldmrd9ky000ki024a0hehacj","category_id":"cldmrd9l3000zi024d22411pz","_id":"cldmrd9l40018i024e2mx2xd9"},{"post_id":"cldmrd9kz000pi0242uwlejpx","category_id":"cldmrd9l40014i02464zx585e","_id":"cldmrd9l4001ci024gduagdke"},{"post_id":"cldmrd9l0000qi024ekbq2km7","category_id":"cldmrd9l40019i02459i52q7z","_id":"cldmrd9l6001hi0241fcv47th"},{"post_id":"cldmrd9l1000ui024g8wxejmn","category_id":"cldmrd9l40014i02464zx585e","_id":"cldmrd9l7001ki0248bv80myq"},{"post_id":"cldmrd9l2000xi024gqaof5p2","category_id":"cldmrd9l40014i02464zx585e","_id":"cldmrd9l8001ni024fbr31lqj"}],"PostTag":[{"post_id":"cldmrd9km0001i0242i0980ao","tag_id":"cldmrd9ks0005i024ffhi2zwd","_id":"cldmrd9ku000bi024fm805hkx"},{"post_id":"cldmrd9kq0003i024g7288bfo","tag_id":"cldmrd9ku000ai024cxqw4d7o","_id":"cldmrd9kv000di024d2jmfp47"},{"post_id":"cldmrd9kw000fi024baql32el","tag_id":"cldmrd9kx000ii024415eac2g","_id":"cldmrd9kz000oi024d7g63ahp"},{"post_id":"cldmrd9kx000gi024ed3m1f2f","tag_id":"cldmrd9kz000ni024bcc3d5ne","_id":"cldmrd9l2000wi0243fu7c8pb"},{"post_id":"cldmrd9kx000ji024c0vsdswz","tag_id":"cldmrd9l1000ti02415123ohb","_id":"cldmrd9l30012i0244k4ffl5y"},{"post_id":"cldmrd9ky000ki024a0hehacj","tag_id":"cldmrd9l30010i0248sef3jxc","_id":"cldmrd9l40016i0247uo32ngr"},{"post_id":"cldmrd9ky000li02488sz67n4","tag_id":"cldmrd9l40015i024939eh8ve","_id":"cldmrd9l4001bi024cz65gobt"},{"post_id":"cldmrd9kz000pi0242uwlejpx","tag_id":"cldmrd9l4001ai024bar3b8wf","_id":"cldmrd9l6001fi0248ytv6ome"},{"post_id":"cldmrd9l0000qi024ekbq2km7","tag_id":"cldmrd9l5001ei0245hud5cnc","_id":"cldmrd9l7001ji024e849603u"},{"post_id":"cldmrd9l1000ui024g8wxejmn","tag_id":"cldmrd9l7001ii0249f9oelq8","_id":"cldmrd9l8001mi024amqngikv"},{"post_id":"cldmrd9l2000xi024gqaof5p2","tag_id":"cldmrd9l8001li0245sfwgk9m","_id":"cldmrd9l8001pi024acihhsih"},{"post_id":"cldmrd9l30011i024be3qdils","tag_id":"cldmrd9l8001oi0247axz9tgq","_id":"cldmrd9l8001qi0247utshgmf"}],"Tag":[{"name":"echarts","_id":"cldmrd9ks0005i024ffhi2zwd"},{"name":"h5与ue4","_id":"cldmrd9ku000ai024cxqw4d7o"},{"name":"JS模块化","_id":"cldmrd9kx000ii024415eac2g"},{"name":"Javascript","_id":"cldmrd9kz000ni024bcc3d5ne"},{"name":"jenkins","_id":"cldmrd9l1000ti02415123ohb"},{"name":"react","_id":"cldmrd9l30010i0248sef3jxc"},{"name":"svg","_id":"cldmrd9l40015i024939eh8ve"},{"name":"浏览器的进程和线程","_id":"cldmrd9l4001ai024bar3b8wf"},{"name":"设计模式","_id":"cldmrd9l5001ei0245hud5cnc"},{"name":"浏览器缓存机制和缓存策略","_id":"cldmrd9l7001ii0249f9oelq8"},{"name":"浏览器渲染","_id":"cldmrd9l8001li0245sfwgk9m"},{"name":"d3js","_id":"cldmrd9l8001oi0247axz9tgq"}]}}